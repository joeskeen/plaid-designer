// put this file in the following location:
// node_modules/@healthcatalyst/cashmere/__ivy_ngcc__/fesm2015/healthcatalyst-cashmere.js

import {
  EventEmitter,
  Component,
  ViewEncapsulation,
  Input,
  Output,
  HostBinding,
  ChangeDetectionStrategy,
  NgModule,
  InjectionToken,
  Injectable,
  Inject,
  Directive,
  ElementRef,
  HostListener,
  Optional,
  ViewChild,
  TemplateRef,
  ContentChildren,
  NgZone,
  ViewContainerRef,
  ComponentFactoryResolver,
  Pipe,
  Attribute,
  Renderer2,
  forwardRef,
  Self,
  ɵɵdefineInjectable,
  inject,
  LOCALE_ID,
  ChangeDetectorRef,
  ContentChild,
  ViewChildren,
  Injector,
  ApplicationRef,
  RendererFactory2,
  isDevMode,
  SkipSelf,
  IterableDiffers,
  ComponentRef,
} from "@angular/core";
import {
  trigger,
  state,
  style,
  transition,
  animate,
  keyframes,
  query,
  animateChild,
} from "@angular/animations";
import {
  Subject,
  of,
  ReplaySubject,
  merge,
  Subscription,
  BehaviorSubject,
  Observable,
  from,
  fromEvent,
  combineLatest,
} from "rxjs";
import {
  takeUntil,
  take,
  tap,
  filter,
  map,
  debounceTime,
  startWith,
  distinctUntilChanged,
  skip,
} from "rxjs/operators";
import { CommonModule, DOCUMENT, DatePipe } from "@angular/common";
import { HttpClient, HttpClientModule } from "@angular/common/http";
import {
  OverlayConfig,
  ConnectionPositionPair,
  Overlay,
  OverlayModule,
  OverlayRef,
} from "@angular/cdk/overlay";
import { FocusTrapFactory, A11yModule } from "@angular/cdk/a11y";
import { Directionality, BidiModule } from "@angular/cdk/bidi";
import {
  coerceBooleanProperty as coerceBooleanProperty$1,
  coerceNumberProperty,
  _isNumberValue,
} from "@angular/cdk/coercion";
import {
  ESCAPE,
  SPACE,
  ENTER,
  PAGE_DOWN,
  PAGE_UP,
  END,
  HOME,
  DOWN_ARROW,
  UP_ARROW,
  RIGHT_ARROW,
  LEFT_ARROW,
} from "@angular/cdk/keycodes";
import {
  TemplatePortal,
  ComponentPortal,
  PortalModule,
  PortalInjector,
} from "@angular/cdk/portal";
import {
  NavigationEnd,
  PRIMARY_OUTLET,
  ActivatedRoute,
  Router,
  RouterModule,
  UrlSerializer,
} from "@angular/router";
import {
  NgForm,
  FormGroupDirective,
  NgControl,
  NG_VALIDATORS,
  CheckboxRequiredValidator,
  FormsModule,
  FormControl,
  NG_VALUE_ACCESSOR,
  Validators,
  ReactiveFormsModule,
} from "@angular/forms";
import { Platform, PlatformModule } from "@angular/cdk/platform";
import { CdkScrollable, ScrollingModule } from "@angular/cdk/scrolling";
import {
  CdkColumnDef,
  CdkTable,
  CDK_TABLE_TEMPLATE,
  CdkCellDef,
  CdkHeaderCellDef,
  CdkFooterCellDef,
  CdkHeaderCell,
  CdkFooterCell,
  CdkCell,
  CdkHeaderRowDef,
  CdkFooterRowDef,
  CdkRowDef,
  CdkHeaderRow,
  CDK_ROW_TEMPLATE,
  CdkFooterRow,
  CdkRow,
  CdkTableModule,
  DataSource,
} from "@angular/cdk/table";
import { __decorate, __metadata } from "tslib";
import { isString } from "util";

/**
 * @fileoverview added by tsickle
 * Generated from: lib/util.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
import * as ɵngcc0 from "@angular/core";
import * as ɵngcc1 from "@angular/common";
import * as ɵngcc2 from "@angular/cdk/a11y";
import * as ɵngcc3 from "@angular/cdk/overlay";
import * as ɵngcc4 from "@angular/cdk/bidi";
import * as ɵngcc5 from "@angular/common/http";
import * as ɵngcc6 from "@angular/router";
import * as ɵngcc7 from "@angular/forms";
import * as ɵngcc8 from "@angular/cdk/portal";
import * as ɵngcc9 from "@angular/cdk/platform";
import * as ɵngcc10 from "@angular/cdk/scrolling";

const _c0 = function (a0, a1) {
  return [a0, a1];
};
function AccordionComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener(
      "click",
      function AccordionComponent_div_0_Template_div_click_0_listener($event) {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r1 = ɵngcc0.ɵɵnextContext();
        return ctx_r1._triggerClick($event, true);
      }
    );
    ɵngcc0.ɵɵelementStart(1, "button", 4);
    ɵngcc0.ɵɵlistener(
      "click",
      function AccordionComponent_div_0_Template_button_click_1_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r3 = ɵngcc0.ɵɵnextContext();
        return ctx_r3._triggerClick($event, false);
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction2(1, _c0, ctx_r0._pointer, ctx_r0._alignment)
    );
  }
}
const _c1 = ["*", [["hc-accordion-toolbar"]]];
const _c2 = ["*", "hc-accordion-toolbar"];
const _c3 = ["*"];
function AppSwitcherComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 6);
    ɵngcc0.ɵɵtext(1, " View All ");
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "href",
      ctx_r0.appSwitcherService.allApplicationsUri,
      ɵngcc0.ɵɵsanitizeUrl
    );
  }
}
const _c4 = function (a0) {
  return { "hc-app-switcher-link-highlighted": a0 };
};
const _c5 = function (a0, a1, a2) {
  return { width: a0, height: a1, "background-image": a2 };
};
function AppSwitcherComponent_ng_container_4_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "a", 10);
    ɵngcc0.ɵɵelement(2, "div", 11);
    ɵngcc0.ɵɵelementStart(3, "div", 12);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵpipe(5, "ellipsis");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const app_r6 = ctx.$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(8, _c4, ctx_r5.appIsMe(app_r6))
    )(
      "title",
      ctx_r5.appIsMe(app_r6) ? "Current Application" : app_r6.Description
    );
    ɵngcc0.ɵɵattribute(
      "href",
      ctx_r5.linkIfNotMe(app_r6),
      ɵngcc0.ɵɵsanitizeUrl
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngStyle",
      ɵngcc0.ɵɵpureFunction3(
        10,
        _c5,
        ctx_r5.iconHeight + "px",
        ctx_r5.iconHeight + "px",
        "url(" + app_r6.Icon + ")"
      )
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(
      ɵngcc0.ɵɵpipeBind2(5, 5, app_r6 == null ? null : app_r6.FriendlyName, 18)
    );
  }
}
function AppSwitcherComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 7);
    ɵngcc0.ɵɵtemplate(
      2,
      AppSwitcherComponent_ng_container_4_div_2_Template,
      6,
      14,
      "div",
      8
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.applications);
  }
}
function AppSwitcherComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵelement(1, "hc-progress-spinner", 14);
    ɵngcc0.ɵɵelementEnd();
  }
}
function AppSwitcherComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵelement(1, "span", 16);
    ɵngcc0.ɵɵelementStart(2, "em");
    ɵngcc0.ɵɵtext(3, "Failed to load applications.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "a", 17);
    ɵngcc0.ɵɵlistener(
      "click",
      function AppSwitcherComponent_div_7_Template_a_click_4_listener() {
        ɵngcc0.ɵɵrestoreView(_r8);
        const ctx_r7 = ɵngcc0.ɵɵnextContext();
        return ctx_r7.loadApplications();
      }
    );
    ɵngcc0.ɵɵtext(5, "Retry now.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
}
function AppSwitcherComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵelement(1, "span", 18);
    ɵngcc0.ɵɵelementStart(2, "em");
    ɵngcc0.ɵɵtext(3, "No applications available.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
}
const _c6 = ["focusTrapElement"];
function HcPopComponent_ng_template_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMapInterpolate2(
      "hc-pop-arrow ",
      ctx_r2._yAlignClass,
      " ",
      ctx_r2._xAlignClass,
      ""
    );
  }
}
function HcPopComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
    ɵngcc0.ɵɵlistener(
      "click",
      function HcPopComponent_ng_template_0_Template_div_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r4);
        const ctx_r3 = ɵngcc0.ɵɵnextContext();
        return ctx_r3._popContainerClicked();
      }
    )(
      "@transformPopover.done",
      function HcPopComponent_ng_template_0_Template_div_animation_transformPopover_done_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r4);
        const ctx_r5 = ɵngcc0.ɵɵnextContext();
        return ctx_r5._onAnimationDone($event);
      }
    );
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵtemplate(
      3,
      HcPopComponent_ng_template_0_div_3_Template,
      1,
      4,
      "div",
      2
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate2(
      "",
      ctx_r0._yAlignClass,
      " ",
      ctx_r0._xAlignClass,
      ""
    );
    ɵngcc0.ɵɵclassProp("hc-pop-container-basic", !ctx_r0.disableStyle);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0._classList)(
      "@transformPopover",
      ctx_r0._getAnimation()
    );
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showArrow);
  }
}
function HcTooltipComponent_ng_template_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 4);
  }
}
function HcTooltipComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener(
      "@transformPopover.done",
      function HcTooltipComponent_ng_template_0_Template_div_animation_transformPopover_done_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r4);
        const ctx_r3 = ɵngcc0.ɵɵnextContext();
        return ctx_r3._onAnimationDone($event);
      }
    );
    ɵngcc0.ɵɵelementStart(1, "span", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      3,
      HcTooltipComponent_ng_template_0_div_3_Template,
      1,
      0,
      "div",
      3
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate2(
      "",
      ctx_r1._yAlignClass,
      " ",
      ctx_r1._xAlignClass,
      ""
    );
    ɵngcc0.ɵɵclassProp("hc-pop-container-basic", !ctx_r1.disableStyle);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1._classList)(
      "@transformPopover",
      ctx_r1._getAnimation()
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tooltipContent, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.showArrow);
  }
}
const _c7 =
  ".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-pop-before.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .hc-pop-before.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.hc-pop-before.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .hc-pop-before.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}.hc-pop-before.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .hc-pop-before.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}.hc-pop-center.hc-pop-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.hc-pop-center.hc-pop-below{-webkit-transform-origin:center top;transform-origin:center top}.hc-pop-after.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .hc-pop-after.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.hc-pop-after.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .hc-pop-after.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}.hc-pop-after.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .hc-pop-after.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}.hc-pop-container-basic{background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;padding:12px}.hc-pop-show-arrow .hc-pop-arrow{background-color:#fff;border-style:solid;border-width:1px;display:block;height:10px;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:10px}.hc-pop-arrow-x-start .hc-pop-arrow{left:5px}.hc-pop-arrow-x-center .hc-pop-arrow{left:calc(50% - 6px)}.hc-pop-arrow-x-end .hc-pop-arrow{left:calc(100% - 15px)}.hc-pop-arrow-y-start .hc-pop-arrow{top:5px}.hc-pop-arrow-y-center .hc-pop-arrow{top:calc(50% - 6px)}.hc-pop-arrow-y-end .hc-pop-arrow{top:calc(100% - 15px)}.hc-pop-arrow-y-above .hc-pop-arrow{border-color:transparent #ccc #ccc transparent;bottom:-6px}.hc-pop-arrow-y-below .hc-pop-arrow{border-color:#ccc transparent transparent #ccc;top:-6px}.hc-pop-arrow-x-before .hc-pop-arrow{border-color:#ccc #ccc transparent transparent;right:-6px}.hc-pop-arrow-x-after .hc-pop-arrow{border-color:transparent transparent #ccc #ccc;left:-6px}.hc-pop-arrow-y-above.hc-pop-show-arrow,.hc-pop-arrow-y-below.hc-pop-show-arrow{margin:6px 0;position:relative}.hc-pop-arrow-x-after.hc-pop-show-arrow,.hc-pop-arrow-x-before.hc-pop-show-arrow{margin:0 6px;position:relative}";
const _c8 = function (a0) {
  return { "center-spinner": a0 };
};
const _c9 = function (a0, a1) {
  return { "indeterminate-spin": a0, "large-spinner": a1 };
};
const _c10 = function (a0) {
  return { "spinner-base": a0 };
};
const _c11 = function (a0) {
  return { "center-dots": a0 };
};
const _c12 = function (a0, a1) {
  return { "loader-light": a0, "loader-mini": a1 };
};
function HcBannerComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵelement(1, "div", 3);
    ɵngcc0.ɵɵelementEnd();
  }
}
const _c13 = function (a0) {
  return { "hc-banner-dismiss": a0 };
};
const _c14 = function (a0) {
  return [a0];
};
function BreadcrumbsComponent_li_1_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "a", 10);
  }
  if (rf & 2) {
    const breadcrumb_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate(
      "queryParamsHandling",
      ctx_r3.queryParamsHandling
    );
    ɵngcc0.ɵɵproperty(
      "routerLink",
      ɵngcc0.ɵɵpureFunction1(3, _c14, breadcrumb_r1.url)
    )("innerText", breadcrumb_r1.label);
  }
}
function BreadcrumbsComponent_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
  }
  if (rf & 2) {
    const breadcrumb_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("innerText", breadcrumb_r1.label);
  }
}
function BreadcrumbsComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 6);
    ɵngcc0.ɵɵtemplate(1, BreadcrumbsComponent_li_1_a_1_Template, 1, 5, "a", 7);
    ɵngcc0.ɵɵtemplate(
      2,
      BreadcrumbsComponent_li_1_span_2_Template,
      1,
      1,
      "span",
      8
    );
    ɵngcc0.ɵɵelement(3, "i", 9);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const last_r2 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", last_r2);
  }
}
const _c15 = ["hc-button", ""];
const _c16 =
  ".hc-button{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:none;border-radius:5px;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif}.hc-button[disabled]{cursor:not-allowed}.hc-button:focus{outline:0;border-bottom:none;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button:active{background-image:none;outline:0}.hc-button::-moz-focus-inner{border:0}.hc-button.hc-primary{color:#fff;background-color:#00a859}.hc-button.hc-primary:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-primary:hover{background-color:#009750;color:#fff}.hc-button.hc-primary:active{background-color:#008647;color:#fff}.hc-button.hc-primary[disabled],.hc-button.hc-primary[disabled]:active,.hc-button.hc-primary[disabled]:focus,.hc-button.hc-primary[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-primary-alt{color:#fff;background-color:#6e53a3}.hc-button.hc-primary-alt:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-primary-alt:hover{background-color:#634b93;color:#fff}.hc-button.hc-primary-alt:active{background-color:#584282;color:#fff}.hc-button.hc-primary-alt[disabled],.hc-button.hc-primary-alt[disabled]:active,.hc-button.hc-primary-alt[disabled]:focus,.hc-button.hc-primary-alt[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-destructive{color:#fff;background-color:#f13c45}.hc-button.hc-destructive:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-destructive:hover{background-color:#d9363e;color:#fff}.hc-button.hc-destructive:active{background-color:#c13037;color:#fff}.hc-button.hc-destructive[disabled],.hc-button.hc-destructive[disabled]:active,.hc-button.hc-destructive[disabled]:focus,.hc-button.hc-destructive[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-neutral{color:#fff;background-color:#6d6e70}.hc-button.hc-neutral:focus{background-color:#57585a;box-shadow:0 0 0 3px rgba(109,110,112,.4)}.hc-button.hc-neutral:hover{background-color:#626365;color:#fff}.hc-button.hc-neutral:active{background-color:#57585a;color:#fff}.hc-button.hc-neutral[disabled],.hc-button.hc-neutral[disabled]:active,.hc-button.hc-neutral[disabled]:focus,.hc-button.hc-neutral[disabled]:hover{background-color:#6d6e70;opacity:.35}.hc-button.hc-secondary{background-color:#f1f1f1;color:#515353;border:1.5px solid #ccc;height:36px;line-height:33px;padding-right:19px}.hc-button.hc-secondary:focus{background-color:#d9d9d9;box-shadow:0 0 0 3px rgba(241,241,241,.4);box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button.hc-secondary:hover{background-color:#e5e5e5}.hc-button.hc-secondary:active{background-color:#d9d9d9;color:#fff}.hc-button.hc-secondary[disabled],.hc-button.hc-secondary[disabled]:active,.hc-button.hc-secondary[disabled]:focus,.hc-button.hc-secondary[disabled]:hover{background-color:#f1f1f1;opacity:.35}.hc-button.hc-secondary:hover{color:#333}.hc-button.hc-secondary[disabled]:hover{color:#515353}.hc-button.hc-minimal{background-color:transparent;color:#6d6e70}.hc-button.hc-minimal:hover{color:#333;background-color:#e0e0e0}.hc-button.hc-minimal:active{background-color:#d3d3d3}.hc-button.hc-minimal[disabled],.hc-button.hc-minimal[disabled]:active,.hc-button.hc-minimal[disabled]:focus,.hc-button.hc-minimal[disabled]:hover{background-color:transparent;color:#ccc}.hc-button.hc-sm{padding:3px 12px;height:26px;min-width:auto;font-size:1rem;line-height:14px}.hc-button.hc-md{padding:0 20px;height:35px;min-width:150px;font-size:1.07143rem;line-height:15px}.hc-button.hc-lg{padding:0 30px;height:40px;min-width:200px;font-size:1.21429rem;line-height:17px}.hc-button.hc-link,.hc-button.hc-link-inline{background-color:transparent;color:#00aeff;font-weight:600}.hc-button.hc-link .label,.hc-button.hc-link-inline .label{color:#6d6e70;font-weight:400;margin-right:10px}.hc-button.hc-link .value,.hc-button.hc-link-inline .value{color:#333;font-weight:400;margin-right:10px}.hc-button.hc-link-inline:hover,.hc-button.hc-link:hover{color:#33beff}.hc-button.hc-link-inline:active,.hc-button.hc-link:active{color:#008bcc}.hc-button.hc-link-inline[disabled],.hc-button.hc-link-inline[disabled]:active,.hc-button.hc-link-inline[disabled]:focus,.hc-button.hc-link-inline[disabled]:hover,.hc-button.hc-link[disabled],.hc-button.hc-link[disabled]:active,.hc-button.hc-link[disabled]:focus,.hc-button.hc-link[disabled]:hover{opacity:.35;color:#00aeff}.hc-button.hc-link-inline[disabled] .label,.hc-button.hc-link-inline[disabled] .value,.hc-button.hc-link-inline[disabled]:active .label,.hc-button.hc-link-inline[disabled]:active .value,.hc-button.hc-link-inline[disabled]:focus .label,.hc-button.hc-link-inline[disabled]:focus .value,.hc-button.hc-link-inline[disabled]:hover .label,.hc-button.hc-link-inline[disabled]:hover .value,.hc-button.hc-link[disabled] .label,.hc-button.hc-link[disabled] .value,.hc-button.hc-link[disabled]:active .label,.hc-button.hc-link[disabled]:active .value,.hc-button.hc-link[disabled]:focus .label,.hc-button.hc-link[disabled]:focus .value,.hc-button.hc-link[disabled]:hover .label,.hc-button.hc-link[disabled]:hover .value{color:#333}.hc-button.hc-link-inline{padding:0;height:auto;width:auto;min-width:0;font-size:inherit;line-height:inherit;text-align:inherit;white-space:inherit;vertical-align:inherit;font-family:inherit;border:none}.hc-button.hc-link-inline:focus{outline:0;border-radius:0;box-shadow:0 2px 0 0 #00aeff}.hc-button.hc-button-blue{color:#fff;background-color:#00aeff}.hc-button.hc-button-blue:focus{background-color:#008bcc;box-shadow:0 0 0 3px rgba(0,174,255,.4)}.hc-button.hc-button-blue:hover{background-color:#009de6;color:#fff}.hc-button.hc-button-blue:active{background-color:#008bcc;color:#fff}.hc-button.hc-button-blue[disabled],.hc-button.hc-button-blue[disabled]:active,.hc-button.hc-button-blue[disabled]:focus,.hc-button.hc-button-blue[disabled]:hover{background-color:#00aeff;opacity:.35}.hc-button.hc-button-green{color:#fff;background-color:#00a859}.hc-button.hc-button-green:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-button-green:hover{background-color:#009750;color:#fff}.hc-button.hc-button-green:active{background-color:#008647;color:#fff}.hc-button.hc-button-green[disabled],.hc-button.hc-button-green[disabled]:active,.hc-button.hc-button-green[disabled]:focus,.hc-button.hc-button-green[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-button-purple{color:#fff;background-color:#6e53a3}.hc-button.hc-button-purple:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-button-purple:hover{background-color:#634b93;color:#fff}.hc-button.hc-button-purple:active{background-color:#584282;color:#fff}.hc-button.hc-button-purple[disabled],.hc-button.hc-button-purple[disabled]:active,.hc-button.hc-button-purple[disabled]:focus,.hc-button.hc-button-purple[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-button-red{color:#fff;background-color:#f13c45}.hc-button.hc-button-red:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-button-red:hover{background-color:#d9363e;color:#fff}.hc-button.hc-button-red:active{background-color:#c13037;color:#fff}.hc-button.hc-button-red[disabled],.hc-button.hc-button-red[disabled]:active,.hc-button.hc-button-red[disabled]:focus,.hc-button.hc-button-red[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-button-orange{color:#fff;background-color:#f8961d}.hc-button.hc-button-orange:focus{background-color:#c67817;box-shadow:0 0 0 3px rgba(248,150,29,.4)}.hc-button.hc-button-orange:hover{background-color:#df871a;color:#fff}.hc-button.hc-button-orange:active{background-color:#c67817;color:#fff}.hc-button.hc-button-orange[disabled],.hc-button.hc-button-orange[disabled]:active,.hc-button.hc-button-orange[disabled]:focus,.hc-button.hc-button-orange[disabled]:hover{background-color:#f8961d;opacity:.35}.hc-button.hc-button-ruby-red{color:#fff;background-color:#951c1e}.hc-button.hc-button-ruby-red:focus{background-color:#771618;box-shadow:0 0 0 3px rgba(149,28,30,.4)}.hc-button.hc-button-ruby-red:hover{background-color:#86191b;color:#fff}.hc-button.hc-button-ruby-red:active{background-color:#771618;color:#fff}.hc-button.hc-button-ruby-red[disabled],.hc-button.hc-button-ruby-red[disabled]:active,.hc-button.hc-button-ruby-red[disabled]:focus,.hc-button.hc-button-ruby-red[disabled]:hover{background-color:#951c1e;opacity:.35}.hc-button.hc-button-deep-red{color:#fff;background-color:#cc2027}.hc-button.hc-button-deep-red:focus{background-color:#a31a1f;box-shadow:0 0 0 3px rgba(204,32,39,.4)}.hc-button.hc-button-deep-red:hover{background-color:#b81d23;color:#fff}.hc-button.hc-button-deep-red:active{background-color:#a31a1f;color:#fff}.hc-button.hc-button-deep-red[disabled],.hc-button.hc-button-deep-red[disabled]:active,.hc-button.hc-button-deep-red[disabled]:focus,.hc-button.hc-button-deep-red[disabled]:hover{background-color:#cc2027;opacity:.35}.hc-button.hc-button-red-orange{color:#fff;background-color:#f05323}.hc-button.hc-button-red-orange:focus{background-color:#c0421c;box-shadow:0 0 0 3px rgba(240,83,35,.4)}.hc-button.hc-button-red-orange:hover{background-color:#d84b20;color:#fff}.hc-button.hc-button-red-orange:active{background-color:#c0421c;color:#fff}.hc-button.hc-button-red-orange[disabled],.hc-button.hc-button-red-orange[disabled]:active,.hc-button.hc-button-red-orange[disabled]:focus,.hc-button.hc-button-red-orange[disabled]:hover{background-color:#f05323;opacity:.35}.hc-button.hc-button-magenta{color:#fff;background-color:#a94c9d}.hc-button.hc-button-magenta:focus{background-color:#873d7e;box-shadow:0 0 0 3px rgba(169,76,157,.4)}.hc-button.hc-button-magenta:hover{background-color:#98448d;color:#fff}.hc-button.hc-button-magenta:active{background-color:#873d7e;color:#fff}.hc-button.hc-button-magenta[disabled],.hc-button.hc-button-magenta[disabled]:active,.hc-button.hc-button-magenta[disabled]:focus,.hc-button.hc-button-magenta[disabled]:hover{background-color:#a94c9d;opacity:.35}.hc-button.hc-button-pink{color:#fff;background-color:#ef4767}.hc-button.hc-button-pink:focus{background-color:#bf3952;box-shadow:0 0 0 3px rgba(239,71,103,.4)}.hc-button.hc-button-pink:hover{background-color:#d7405d;color:#fff}.hc-button.hc-button-pink:active{background-color:#bf3952;color:#fff}.hc-button.hc-button-pink[disabled],.hc-button.hc-button-pink[disabled]:active,.hc-button.hc-button-pink[disabled]:focus,.hc-button.hc-button-pink[disabled]:hover{background-color:#ef4767;opacity:.35}.hc-button.hc-button-light-pink{color:#fff;background-color:#f8c8db}.hc-button.hc-button-light-pink:focus{background-color:#c6a0af;box-shadow:0 0 0 3px rgba(248,200,219,.4)}.hc-button.hc-button-light-pink:hover{background-color:#dfb4c5;color:#fff}.hc-button.hc-button-light-pink:active{background-color:#c6a0af;color:#fff}.hc-button.hc-button-light-pink[disabled],.hc-button.hc-button-light-pink[disabled]:active,.hc-button.hc-button-light-pink[disabled]:focus,.hc-button.hc-button-light-pink[disabled]:hover{background-color:#f8c8db;opacity:.35}.hc-button.hc-button-azure{color:#fff;background-color:#007bff}.hc-button.hc-button-azure:focus{background-color:#0062cc;box-shadow:0 0 0 3px rgba(0,123,255,.4)}.hc-button.hc-button-azure:hover{background-color:#006fe6;color:#fff}.hc-button.hc-button-azure:active{background-color:#0062cc;color:#fff}.hc-button.hc-button-azure[disabled],.hc-button.hc-button-azure[disabled]:active,.hc-button.hc-button-azure[disabled]:focus,.hc-button.hc-button-azure[disabled]:hover{background-color:#007bff;opacity:.35}.hc-button.hc-button-teal{color:#fff;background-color:#00acac}.hc-button.hc-button-teal:focus{background-color:#008a8a;box-shadow:0 0 0 3px rgba(0,172,172,.4)}.hc-button.hc-button-teal:hover{background-color:#009b9b;color:#fff}.hc-button.hc-button-teal:active{background-color:#008a8a;color:#fff}.hc-button.hc-button-teal[disabled],.hc-button.hc-button-teal[disabled]:active,.hc-button.hc-button-teal[disabled]:focus,.hc-button.hc-button-teal[disabled]:hover{background-color:#00acac;opacity:.35}.hc-button.hc-button-dark-green{color:#fff;background-color:#006c4e}.hc-button.hc-button-dark-green:focus{background-color:#00563e;box-shadow:0 0 0 3px rgba(0,108,78,.4)}.hc-button.hc-button-dark-green:hover{background-color:#006146;color:#fff}.hc-button.hc-button-dark-green:active{background-color:#00563e;color:#fff}.hc-button.hc-button-dark-green[disabled],.hc-button.hc-button-dark-green[disabled]:active,.hc-button.hc-button-dark-green[disabled]:focus,.hc-button.hc-button-dark-green[disabled]:hover{background-color:#006c4e;opacity:.35}.hc-button.hc-button-brown{color:#fff;background-color:#553e36}.hc-button.hc-button-brown:focus{background-color:#44322b;box-shadow:0 0 0 3px rgba(85,62,54,.4)}.hc-button.hc-button-brown:hover{background-color:#4d3831;color:#fff}.hc-button.hc-button-brown:active{background-color:#44322b;color:#fff}.hc-button.hc-button-brown[disabled],.hc-button.hc-button-brown[disabled]:active,.hc-button.hc-button-brown[disabled]:focus,.hc-button.hc-button-brown[disabled]:hover{background-color:#553e36;opacity:.35}.hc-button.hc-button-purple-gray{color:#fff;background-color:#776c7f}.hc-button.hc-button-purple-gray:focus{background-color:#5f5666;box-shadow:0 0 0 3px rgba(119,108,127,.4)}.hc-button.hc-button-purple-gray:hover{background-color:#6b6172;color:#fff}.hc-button.hc-button-purple-gray:active{background-color:#5f5666;color:#fff}.hc-button.hc-button-purple-gray[disabled],.hc-button.hc-button-purple-gray[disabled]:active,.hc-button.hc-button-purple-gray[disabled]:focus,.hc-button.hc-button-purple-gray[disabled]:hover{background-color:#776c7f;opacity:.35}.hc-button.hc-button-yellow{color:#fff;background-color:#f5ed56}.hc-button.hc-button-yellow:focus{background-color:#c4be45;box-shadow:0 0 0 3px rgba(245,237,86,.4)}.hc-button.hc-button-yellow:hover{background-color:#ddd54d;color:#fff}.hc-button.hc-button-yellow:active{background-color:#c4be45;color:#fff}.hc-button.hc-button-yellow[disabled],.hc-button.hc-button-yellow[disabled]:active,.hc-button.hc-button-yellow[disabled]:focus,.hc-button.hc-button-yellow[disabled]:hover{background-color:#f5ed56;opacity:.35}.hc-button.hc-button-yellow-orange{color:#fff;background-color:#e7c447}.hc-button.hc-button-yellow-orange:focus{background-color:#b99d39;box-shadow:0 0 0 3px rgba(231,196,71,.4)}.hc-button.hc-button-yellow-orange:hover{background-color:#d0b040;color:#fff}.hc-button.hc-button-yellow-orange:active{background-color:#b99d39;color:#fff}.hc-button.hc-button-yellow-orange[disabled],.hc-button.hc-button-yellow-orange[disabled]:active,.hc-button.hc-button-yellow-orange[disabled]:focus,.hc-button.hc-button-yellow-orange[disabled]:hover{background-color:#e7c447;opacity:.35}.hc-button.hc-button-tan{color:#fff;background-color:#ebba82}.hc-button.hc-button-tan:focus{background-color:#bc9568;box-shadow:0 0 0 3px rgba(235,186,130,.4)}.hc-button.hc-button-tan:hover{background-color:#d4a775;color:#fff}.hc-button.hc-button-tan:active{background-color:#bc9568;color:#fff}.hc-button.hc-button-tan[disabled],.hc-button.hc-button-tan[disabled]:active,.hc-button.hc-button-tan[disabled]:focus,.hc-button.hc-button-tan[disabled]:hover{background-color:#ebba82;opacity:.35}.hc-icon-button{display:inline-block;position:relative;height:35px;width:35px;line-height:35px;border-radius:5px;outline:0;border:none;margin:0;padding:0;background:0 0;text-decoration:none;cursor:pointer;white-space:nowrap;display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.hc-icon-button:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-icon-button::-moz-focus-inner{border:0}.hc-split-button{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal){min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal)::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-secondary{min-width:auto;padding:8px 12px;margin-left:0;border-left:0;border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle.hc-secondary::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-minimal{min-width:auto;padding:8px 12px;margin-left:0;border-bottom-left-radius:0;border-top-left-radius:0;border-left:2px solid rgba(0,0,0,.12)!important}.hc-split-button .hc-split-button-toggle.hc-minimal::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-sm{padding:3px 7px}.hc-split-button .hc-split-button-toggle.hc-sm::after{width:10px;height:6px;margin-top:1px}.hc-split-button .hc-split-button-toggle.hc-lg{padding:0 16px}.hc-split-button .hc-split-button-toggle.hc-lg::after{width:14px;height:9px}.hc-filters-icon{width:19px;height:19px;display:block;margin-right:7px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjU0NjEgNDcuMjUgMTkuMjgxIDIwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0iRmlsdGVyc19CdXR0b24iIGRhdGEtbmFtZT0iRmlsdGVycyBCdXR0b24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU0NjEgNjcuMjUpIHJvdGF0ZSgtOTApIj4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNCIgZGF0YS1uYW1lPSJQYXRoIDMwNCIgY2xhc3M9ImNscy0xIiBkPSJNOS45MzksMi45OTNWLjcxOUEuNzE5LjcxOSwwLDAsMCw4LjUuNzE5djIuMzZtMCw0Ljg5MnYxMC41OWgwYS43MTkuNzE5LDAsMSwwLDEuNDM5LDBWNy45NDIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02LjA1NCkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNSIgZGF0YS1uYW1lPSJQYXRoIDMwNSIgY2xhc3M9ImNscy0xIiBkPSJNNi40NzUsMTEuMDIzYTMuMjM3LDMuMjM3LDAsMCwwLTYuNDc1LDAsMy4yMzcsMy4yMzcsMCwwLDAsNi40NzUsMFptLTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEsMS43ODQsMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMS40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDYiIGRhdGEtbmFtZT0iUGF0aCAzMDYiIGNsYXNzPSJjbHMtMSIgZD0iTTU2LjkzOSwyLjk5M1YuNzE5YS43MTkuNzE5LDAsMCwwLTEuNDM5LDB2Mi4zNm0wLDQuODkydjEwLjU5aDBhLjcxOS43MTksMCwxLDAsMS40MzksMFY3Ljk0MiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTM5LjUyOSkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNyIgZGF0YS1uYW1lPSJQYXRoIDMwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTMuNDc1LDExLjAyM2EzLjIzNywzLjIzNywwLDEsMC0zLjI1MiwzLjIyM0EzLjIxOCwzLjIxOCwwLDAsMCw1My40NzUsMTEuMDIzWm0tNS4wMzYsMGExLjc4NCwxLjc4NCwwLDEsMSwxLjc4NCwxLjc4NEExLjc5MywxLjc5MywwLDAsMSw0OC40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMzLjQ3NSAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDgiIGRhdGEtbmFtZT0iUGF0aCAzMDgiIGNsYXNzPSJjbHMtMSIgZD0iTTMyLjUsMTYuMjg4djIuMjczYS43MTkuNzE5LDAsMCwwLDEuNDM5LDBWMTYuMm0wLTQuODkyVi43MTloMGEuNzE5LjcxOSwwLDAsMC0xLjQzOSwwVjExLjMzOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzLjE0NykiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwOSIgZGF0YS1uYW1lPSJQYXRoIDMwOSIgY2xhc3M9ImNscy0xIiBkPSJNMjMuNSw0MC4wMjNBMy4yMzcsMy4yMzcsMCwxLDAsMjYuNzUyLDM2LjgsMy4yMTgsMy4yMTgsMCwwLDAsMjMuNSw0MC4wMjNabTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEtMS43ODQtMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMjguNTM2LDQwLjAyM1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNi43MzcgLTI2LjIxKSIvPgogIDwvZz4KPC9zdmc+Cg==)}";
const _c17 = ["splitBtnToggle"];
const _c18 = ["splitMenu"];
const _c19 = [
  "*",
  [
    ["", "hcButtonItem", ""],
    ["", "hcMenuItem", ""],
  ],
];
const _c20 = ["*", "[hcButtonItem], [hcMenuItem]"];
function CheckboxGroup_hc_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-checkbox", 1);
    ɵngcc0.ɵɵlistener(
      "change",
      function CheckboxGroup_hc_checkbox_0_Template_hc_checkbox_change_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r1 = ɵngcc0.ɵɵnextContext();
        return ctx_r1.toggleCheckAll();
      }
    );
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("checked", ctx_r0._groupState)(
      "indeterminate",
      ctx_r0._isIndeterminate
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0._parentLabel);
  }
}
const _c21 = ["checkboxInput"];
function ChipComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 1);
    ɵngcc0.ɵɵlistener(
      "click",
      function ChipComponent_span_3_Template_span_click_0_listener($event) {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r1 = ɵngcc0.ɵɵnextContext();
        return ctx_r1._closeClick($event);
      }
    );
    ɵngcc0.ɵɵelement(1, "span", 2);
    ɵngcc0.ɵɵelementEnd();
  }
}
const _c22 = function (a0) {
  return { "hc-chip-single-row": a0 };
};
const _c23 =
  "@charset \"UTF-8\";.hc-chip{font-size:1rem;border-radius:6px;display:-webkit-inline-box;display:inline-flex;margin:5px;padding-left:15px;padding-right:15px}.hc-chip-content-neutral{display:-webkit-box;display:flex;padding-top:9px;padding-bottom:9px}.hc-chip-content-green,.hc-chip-content-red,.hc-chip-content-yellow{display:-webkit-box;display:flex;padding-top:7px;padding-bottom:7px}.hc-chip-close{padding:6px 12px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;margin-right:-12px;margin-left:auto;cursor:pointer}.hc-chip-neutral{background-color:#e4e4e4;color:#333}.hc-chip-red{background-color:#efdddd;border:2px solid #e5c6c7;color:#951c1e}.hc-chip-yellow{background-color:#faf3da;border:2px solid #f3e2a3;color:#ad9335}.hc-chip-green{background-color:#d9eedf;border:2px solid #bce1c6;color:#00a859}.hc-chip-close-icon{background-repeat:no-repeat;background-size:contain;display:inline-block;height:10px;opacity:.4;width:10px}.hc-chip-neutral .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMSIgZGF0YS1uYW1lPSJQYXRoIDEiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMzMzIi8+Cjwvc3ZnPgo=)}.hc-chip-red .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMiIgZGF0YS1uYW1lPSJQYXRoIDIiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjOTUxYzFlIi8+Cjwvc3ZnPgo=)}.hc-chip-yellow .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMyIgZGF0YS1uYW1lPSJQYXRoIDMiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjYWQ5MzM1Ii8+Cjwvc3ZnPgo=)}.hc-chip-green .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfNCIgZGF0YS1uYW1lPSJQYXRoIDQiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMDBhODU5Ii8+Cjwvc3ZnPgo=)}.hc-chip-row-contents{display:inline-block}.hc-chip-single-row{height:42px;overflow:hidden}.hc-chip-single-row::before{content:'';float:left;height:50px;width:5px}.hc-chip-single-row>:first-child{float:right;margin-left:-5px;width:100%}.hc-chip-single-row::after{content:'\u2026more';box-sizing:content-box;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;float:right;left:100%;margin-left:-3.5em;padding-right:5px;position:relative;text-align:right;top:-35px;width:3.5em}.hc-chip-row-buffer{margin-right:3.5em}";
const _c24 = ["hc-calendar-body", ""];
function CalendarBodyComponent_tr_0_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td", 4);
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("colspan", ctx_r3._firstRowOffset);
  }
}
function CalendarBodyComponent_tr_0_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "td", 5);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarBodyComponent_tr_0_td_2_Template_td_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r8);
        const item_r5 = ctx.$implicit;
        const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r7._cellClicked(item_r5);
      }
    );
    ɵngcc0.ɵɵelementStart(1, "div", 6);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const colIndex_r6 = ctx.index;
    const rowIndex_r2 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r4._cellWidth)(
      "padding-top",
      ctx_r4._cellPadding
    )("padding-bottom", ctx_r4._cellPadding);
    ɵngcc0.ɵɵclassProp(
      "hc-calendar-body-available",
      item_r5.enabled && !ctx_r4._isActiveCell(rowIndex_r2, colIndex_r6)
    )("hc-calendar-body-disabled", !item_r5.enabled)(
      "hc-calendar-body-active",
      ctx_r4._isActiveCell(rowIndex_r2, colIndex_r6)
    );
    ɵngcc0.ɵɵproperty("ngClass", item_r5.cssClasses)(
      "tabindex",
      ctx_r4._isActiveCell(rowIndex_r2, colIndex_r6) ? 0 : -1
    );
    ɵngcc0.ɵɵattribute("aria-label", item_r5.ariaLabel)(
      "aria-disabled",
      !item_r5.enabled || null
    )("aria-selected", ctx_r4.selectedValue === item_r5.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp(
      "hc-calendar-body-selected",
      ctx_r4.selectedValue === item_r5.value
    )("hc-calendar-body-today", ctx_r4.todayValue === item_r5.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", item_r5.displayValue, " ");
  }
}
function CalendarBodyComponent_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 1);
    ɵngcc0.ɵɵtemplate(
      1,
      CalendarBodyComponent_tr_0_td_1_Template,
      1,
      1,
      "td",
      2
    );
    ɵngcc0.ɵɵtemplate(
      2,
      CalendarBodyComponent_tr_0_td_2_Template,
      3,
      22,
      "td",
      3
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r1 = ctx.$implicit;
    const rowIndex_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", rowIndex_r2 === 0 && ctx_r0._firstRowOffset);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", row_r1);
  }
}
function MonthViewComponent_th_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("aria-label", day_r1.long);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r1.narrow);
  }
}
function CalendarHeaderComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵelementStart(2, "button", 3);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarHeaderComponent_div_0_Template_button_click_2_listener() {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r1 = ɵngcc0.ɵɵnextContext();
        return ctx_r1._todayClicked();
      }
    );
    ɵngcc0.ɵɵtext(3, " Today ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵelementStart(5, "button", 4);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarHeaderComponent_div_0_Template_button_click_5_listener() {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r3 = ɵngcc0.ɵɵnextContext();
        return ctx_r3.previousClicked();
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span", 5);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "button", 6);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarHeaderComponent_div_0_Template_button_click_8_listener() {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r4 = ɵngcc0.ɵɵnextContext();
        return ctx_r4.nextClicked();
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(9);
    ɵngcc0.ɵɵelementStart(10, "button", 7);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarHeaderComponent_div_0_Template_button_click_10_listener() {
        ɵngcc0.ɵɵrestoreView(_r2);
        const ctx_r5 = ɵngcc0.ɵɵnextContext();
        return ctx_r5.currentPeriodClicked();
      }
    );
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelement(12, "div", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r0._todayEnabled())(
      "title",
      ctx_r0._todayButtonLabel
    );
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0._todayButtonLabel);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r0.previousEnabled())(
      "title",
      ctx_r0.prevButtonLabel
    );
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.prevButtonLabel);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.monthButtonText, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r0.nextEnabled())(
      "title",
      ctx_r0.nextButtonLabel
    );
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.nextButtonLabel);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("title", ctx_r0.periodButtonLabel);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r0.periodButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.periodButtonText, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp(
      "hc-calendar-dropdown-caret-invert",
      ctx_r0.calendar.currentView != "month"
    );
  }
}
function CalendarComponent_ng_template_0_Template(rf, ctx) {}
function CalendarComponent_ng_container_1_hc_month_view_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-month-view", 7);
    ɵngcc0.ɵɵlistener(
      "activeDateChange",
      function CalendarComponent_ng_container_1_hc_month_view_2_Template_hc_month_view_activeDateChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r7);
        const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
        return (ctx_r6.activeDate = $event);
      }
    )(
      "selectedChange",
      function CalendarComponent_ng_container_1_hc_month_view_2_Template_hc_month_view_selectedChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r7);
        const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r8._dateSelected($event);
      }
    )(
      "_userSelection",
      function CalendarComponent_ng_container_1_hc_month_view_2_Template_hc_month_view__userSelection_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r7);
        const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r9._userSelected();
      }
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("activeDate", ctx_r3.activeDate)(
      "selected",
      ctx_r3.selected
    )("dateFilter", ctx_r3.dateFilter)("maxDate", ctx_r3.maxDate)(
      "minDate",
      ctx_r3.minDate
    )("dateClass", ctx_r3.dateClass);
  }
}
function CalendarComponent_ng_container_1_hc_year_view_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-year-view", 8);
    ɵngcc0.ɵɵlistener(
      "activeDateChange",
      function CalendarComponent_ng_container_1_hc_year_view_3_Template_hc_year_view_activeDateChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r11);
        const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
        return (ctx_r10.activeDate = $event);
      }
    )(
      "monthSelected",
      function CalendarComponent_ng_container_1_hc_year_view_3_Template_hc_year_view_monthSelected_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r11);
        const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r12._monthSelectedInYearView($event);
      }
    )(
      "selectedChange",
      function CalendarComponent_ng_container_1_hc_year_view_3_Template_hc_year_view_selectedChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r11);
        const ctx_r13 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r13._goToDateInView($event, "month");
      }
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("activeDate", ctx_r4.activeDate)(
      "selected",
      ctx_r4.selected
    )("dateFilter", ctx_r4.dateFilter)("maxDate", ctx_r4.maxDate)(
      "minDate",
      ctx_r4.minDate
    );
  }
}
function CalendarComponent_ng_container_1_hc_multi_year_view_4_Template(
  rf,
  ctx
) {
  if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-multi-year-view", 9);
    ɵngcc0.ɵɵlistener(
      "activeDateChange",
      function CalendarComponent_ng_container_1_hc_multi_year_view_4_Template_hc_multi_year_view_activeDateChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r15);
        const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
        return (ctx_r14.activeDate = $event);
      }
    )(
      "yearSelected",
      function CalendarComponent_ng_container_1_hc_multi_year_view_4_Template_hc_multi_year_view_yearSelected_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r15);
        const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r16._yearSelectedInMultiYearView($event);
      }
    )(
      "selectedChange",
      function CalendarComponent_ng_container_1_hc_multi_year_view_4_Template_hc_multi_year_view_selectedChange_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r15);
        const ctx_r17 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r17._goToDateInView($event, "year");
      }
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("activeDate", ctx_r5.activeDate)(
      "selected",
      ctx_r5.selected
    )("dateFilter", ctx_r5.dateFilter)("maxDate", ctx_r5.maxDate)(
      "minDate",
      ctx_r5.minDate
    );
  }
}
function CalendarComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵtemplate(
      2,
      CalendarComponent_ng_container_1_hc_month_view_2_Template,
      1,
      6,
      "hc-month-view",
      4
    );
    ɵngcc0.ɵɵtemplate(
      3,
      CalendarComponent_ng_container_1_hc_year_view_3_Template,
      1,
      5,
      "hc-year-view",
      5
    );
    ɵngcc0.ɵɵtemplate(
      4,
      CalendarComponent_ng_container_1_hc_multi_year_view_4_Template,
      1,
      5,
      "hc-multi-year-view",
      6
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r1.currentView);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "month");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "year");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", "multi-year");
  }
}
function CalendarComponent_div_2_hc_form_field_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-form-field", 12);
    ɵngcc0.ɵɵelementStart(1, "hc-select", 20);
    ɵngcc0.ɵɵlistener(
      "change",
      function CalendarComponent_div_2_hc_form_field_16_Template_hc_select_change_1_listener() {
        ɵngcc0.ɵɵrestoreView(_r20);
        const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r19._periodChange();
      }
    );
    ɵngcc0.ɵɵelementStart(2, "option", 21);
    ɵngcc0.ɵɵtext(3, "AM");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "option", 22);
    ɵngcc0.ɵɵtext(5, "PM");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("formControl", ctx_r18._period);
  }
}
function CalendarComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵelement(1, "hc-icon", 11);
    ɵngcc0.ɵɵelementStart(2, "hc-form-field", 12);
    ɵngcc0.ɵɵelementStart(3, "input", 13);
    ɵngcc0.ɵɵlistener(
      "ngModelChange",
      function CalendarComponent_div_2_Template_input_ngModelChange_3_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r21 = ɵngcc0.ɵɵnextContext();
        return (ctx_r21.hours = $event);
      }
    )(
      "keydown.arrowup",
      function CalendarComponent_div_2_Template_input_keydown_arrowup_3_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r23 = ɵngcc0.ɵɵnextContext();
        return ctx_r23._hoursUp();
      }
    )(
      "keydown.arrowdown",
      function CalendarComponent_div_2_Template_input_keydown_arrowdown_3_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r24 = ɵngcc0.ɵɵnextContext();
        return ctx_r24._hoursDown();
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span", 14);
    ɵngcc0.ɵɵelementStart(5, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarComponent_div_2_Template_button_click_5_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r25 = ɵngcc0.ɵɵnextContext();
        return ctx_r25._hoursUp();
      }
    );
    ɵngcc0.ɵɵelement(6, "hc-icon", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarComponent_div_2_Template_button_click_7_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r26 = ɵngcc0.ɵɵnextContext();
        return ctx_r26._hoursDown();
      }
    );
    ɵngcc0.ɵɵelement(8, "hc-icon", 17);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "hc-form-field", 12);
    ɵngcc0.ɵɵelementStart(10, "input", 18);
    ɵngcc0.ɵɵlistener(
      "ngModelChange",
      function CalendarComponent_div_2_Template_input_ngModelChange_10_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r27 = ɵngcc0.ɵɵnextContext();
        return (ctx_r27.minutes = $event);
      }
    )(
      "keydown.arrowup",
      function CalendarComponent_div_2_Template_input_keydown_arrowup_10_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r28 = ɵngcc0.ɵɵnextContext();
        return ctx_r28._minutesUp();
      }
    )(
      "keydown.arrowdown",
      function CalendarComponent_div_2_Template_input_keydown_arrowdown_10_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r29 = ɵngcc0.ɵɵnextContext();
        return ctx_r29._minutesDown();
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "span", 14);
    ɵngcc0.ɵɵelementStart(12, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarComponent_div_2_Template_button_click_12_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r30 = ɵngcc0.ɵɵnextContext();
        return ctx_r30._minutesUp();
      }
    );
    ɵngcc0.ɵɵelement(13, "hc-icon", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function CalendarComponent_div_2_Template_button_click_14_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const ctx_r31 = ɵngcc0.ɵɵnextContext();
        return ctx_r31._minutesDown();
      }
    );
    ɵngcc0.ɵɵelement(15, "hc-icon", 17);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      16,
      CalendarComponent_div_2_hc_form_field_16_Template,
      6,
      1,
      "hc-form-field",
      19
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r2.hours);
    ɵngcc0.ɵɵadvance(7);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r2.minutes);
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2._hourCycle === 12);
  }
}
function HcFormFieldComponent_span_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 7);
    ɵngcc0.ɵɵtext(1, "\u00A0*");
    ɵngcc0.ɵɵelementEnd();
  }
}
function HcFormFieldComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵelementStart(1, "label", 5);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵtemplate(
      3,
      HcFormFieldComponent_span_1_span_3_Template,
      2,
      0,
      "span",
      6
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("hc-form-field-label-wrapper-tight", ctx_r0.tight);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ctx_r0.inline
        ? "hc-form-field-label-wrapper-inline"
        : "hc-form-field-label-wrapper"
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("hc-form-field-label-tight", ctx_r0.tight);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ctx_r0.inline ? "hc-form-field-label-inline" : "hc-form-field-label"
    );
    ɵngcc0.ɵɵattribute("for", ctx_r0._control._componentId);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r0._control._isRequired && !ctx_r0._control._isDisabled
    );
  }
}
function HcFormFieldComponent_div_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵprojection(1, 3);
    ɵngcc0.ɵɵelementEnd();
  }
}
function HcFormFieldComponent_div_4_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵprojection(1, 4);
    ɵngcc0.ɵɵelementEnd();
  }
}
function HcFormFieldComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(
      1,
      HcFormFieldComponent_div_4_div_1_Template,
      2,
      0,
      "div",
      8
    );
    ɵngcc0.ɵɵelementStart(2, "div", 9, 10);
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      5,
      HcFormFieldComponent_div_4_div_5_Template,
      2,
      0,
      "div",
      11
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("hc-form-field-flex", !ctx_r1.inline)(
      "hc-form-field-flex-inline",
      ctx_r1.inline
    )("hc-form-field-invalid", ctx_r1._shouldShowErrorMessages())(
      "hc-form-field-flex-focused",
      ctx_r1._hasFocusedInput
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1._prefixChildren.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("hc-form-field-infix-tight", ctx_r1.tight);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1._suffixChildren.length);
  }
}
function HcFormFieldComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵprojection(1, 5);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("hc-form-field-non-input", !ctx_r2.inline)(
      "hc-form-field-non-input-inline",
      ctx_r2.inline
    )("hc-form-field-non-input-inline-tight", ctx_r2.inline && ctx_r2.tight)(
      "hc-form-field-invalid",
      ctx_r2._shouldShowErrorMessages()
    );
  }
}
function HcFormFieldComponent_div_6_hc_error_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "hc-error");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r8._control._errorMessage);
  }
}
function HcFormFieldComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(
      1,
      HcFormFieldComponent_div_6_hc_error_1_Template,
      2,
      1,
      "hc-error",
      15
    );
    ɵngcc0.ɵɵprojection(2, 6);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r3._control._errorMessage && ctx_r3._control._errorMessage.length
    );
  }
}
const _c25 = [
  [["hc-label-ext"]],
  [["hc-label"]],
  [["", "hcInput", ""]],
  [["", "hcPrefix", ""]],
  [["", "hcSuffix", ""]],
  "*",
  [["hc-error"]],
];
const _c26 = [
  "hc-label-ext",
  "hc-label",
  "[hcInput]",
  "[hcPrefix]",
  "[hcSuffix]",
  "*",
  "hc-error",
];
const _c27 = ["button"];
function DatepickerToggleComponent_hc_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "hc-icon", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "fontIcon",
      ctx_r1.datepicker.mode === "time" ? "fa-clock-o" : "fa-calendar"
    );
  }
}
const _c28 = [[["", "hcDatepickerToggleIcon", ""]]];
const _c29 = ["[hcDatepickerToggleIcon]"];
const _c30 = ["selectInput"];
function SelectComponent_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.placeholder);
  }
}
function PickerOverlayComponent_div_0_hc_radio_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "hc-radio-button", 12);
    ɵngcc0.ɵɵlistener(
      "change",
      function PickerOverlayComponent_div_0_hc_radio_button_8_Template_hc_radio_button_change_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r7);
        const i_r5 = ctx.index;
        const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r6._updateRangeByPreset(i_r5);
      }
    );
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const p_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    ɵngcc0.ɵɵproperty("value", i_r5);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", p_r4.presetLabel, " ");
  }
}
function PickerOverlayComponent_div_0_hc_chip_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "hc-chip", 13);
    ɵngcc0.ɵɵelement(1, "span", 14);
    ɵngcc0.ɵɵtext(2, "The start date cannot be after the end date. ");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PickerOverlayComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵelementStart(2, "hc-calendar-wrapper", 3);
    ɵngcc0.ɵɵlistener(
      "selectedDateChange",
      function PickerOverlayComponent_div_0_Template_hc_calendar_wrapper_selectedDateChange_2_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r9);
        const ctx_r8 = ɵngcc0.ɵɵnextContext();
        return ctx_r8._updateFromDate($event);
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 2);
    ɵngcc0.ɵɵelementStart(4, "hc-calendar-wrapper", 3);
    ɵngcc0.ɵɵlistener(
      "selectedDateChange",
      function PickerOverlayComponent_div_0_Template_hc_calendar_wrapper_selectedDateChange_4_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r9);
        const ctx_r10 = ɵngcc0.ɵɵnextContext();
        return ctx_r10._updateToDate($event);
      }
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 4);
    ɵngcc0.ɵɵelementStart(6, "div", 5);
    ɵngcc0.ɵɵelementStart(7, "hc-radio-group", 6);
    ɵngcc0.ɵɵlistener(
      "ngModelChange",
      function PickerOverlayComponent_div_0_Template_hc_radio_group_ngModelChange_7_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r9);
        const ctx_r11 = ɵngcc0.ɵɵnextContext();
        return (ctx_r11._selectedPreset = $event);
      }
    );
    ɵngcc0.ɵɵtemplate(
      8,
      PickerOverlayComponent_div_0_hc_radio_button_8_Template,
      2,
      2,
      "hc-radio-button",
      7
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 8);
    ɵngcc0.ɵɵelementStart(10, "button", 9);
    ɵngcc0.ɵɵlistener(
      "click",
      function PickerOverlayComponent_div_0_Template_button_click_10_listener() {
        ɵngcc0.ɵɵrestoreView(_r9);
        const ctx_r12 = ɵngcc0.ɵɵnextContext();
        return ctx_r12._discardNewDates();
      }
    );
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "button", 10);
    ɵngcc0.ɵɵlistener(
      "click",
      function PickerOverlayComponent_div_0_Template_button_click_12_listener() {
        ɵngcc0.ɵɵrestoreView(_r9);
        const ctx_r13 = ɵngcc0.ɵɵnextContext();
        return ctx_r13._applyNewDates();
      }
    );
    ɵngcc0.ɵɵtext(13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      14,
      PickerOverlayComponent_div_0_hc_chip_14_Template,
      3,
      0,
      "hc-chip",
      11
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const options_r1 = ctx.ngIf;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("prefixLabel", options_r1.startDatePrefix)(
      "selectedDate",
      ctx_r0._fromDate
    )(
      "minDate",
      options_r1.fromMinMax == null ? null : options_r1.fromMinMax.fromDate
    )(
      "maxDate",
      options_r1.fromMinMax == null ? null : options_r1.fromMinMax.toDate
    )("excludeWeekends", options_r1.excludeWeekends)(
      "dateFormat",
      options_r1.format
    )("invalidDateLabel", options_r1.invalidDateLabel)("mode", options_r1.mode)(
      "hourCycle",
      options_r1.hourCycle
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("prefixLabel", options_r1.endDatePrefix)(
      "selectedDate",
      ctx_r0._toDate
    )(
      "minDate",
      options_r1.toMinMax == null ? null : options_r1.toMinMax.fromDate
    )(
      "maxDate",
      options_r1.toMinMax == null ? null : options_r1.toMinMax.toDate
    )("excludeWeekends", options_r1.excludeWeekends)(
      "dateFormat",
      options_r1.format
    )("invalidDateLabel", options_r1.invalidDateLabel)("mode", options_r1.mode)(
      "hourCycle",
      options_r1.hourCycle
    );
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r0._selectedPreset);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", options_r1.presets);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", options_r1.cancelLabel, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", !(ctx_r0._toDate && ctx_r0._fromDate));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", options_r1.applyLabel, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0._rangeIsInvalid);
  }
}
const _c31 = [[["hc-drawer"], ["hc-menu-drawer"]], "*"];
const _c32 = ["hc-drawer,hc-menu-drawer", "*"];
const _c33 =
  ".hc-drawer,.hc-menu-drawer{bottom:0;box-sizing:border-box;display:block;height:100%;outline:0;overflow-y:auto;position:absolute;top:0;z-index:3}.hc-drawer.hc-drawer-opened:not(.drawer-side),.hc-drawer.hc-drawer-opening:not(.drawer-side),.hc-menu-drawer.hc-drawer-opened:not(.drawer-side),.hc-menu-drawer.hc-drawer-opening:not(.drawer-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.hc-drawer-right{right:0}.hc-drawer-container{position:relative;z-index:1;box-sizing:border-box;display:block;overflow:hidden}.hc-drawer-content{position:relative;z-index:1;display:block;height:100%;left:0;overflow:auto;padding:10px 20px;right:0;-webkit-transition-duration:.4s;transition-duration:.4s;-webkit-transition-property:margin-left,margin-right,-webkit-transform;transition-property:transform,margin-left,margin-right,-webkit-transform;-webkit-transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-timing-function:cubic-bezier(.25,.8,.25,1)}";
const _c34 = [[["", "hcDrawerToolbar", ""]], [["hc-drawer-item"]]];
const _c35 = ["[hcDrawerToolbar]", "hc-drawer-item"];
const _c36 = [
  [
    ["", "hcListAvatar", ""],
    ["", "hcListIcon", ""],
  ],
  [["", "hcListLine", ""]],
  "*",
];
const _c37 = ["[hcListAvatar], [hcListIcon]", "[hcListLine]", "*"];
const _c38 = function (a0, a1) {
  return { active: a0, inactive: a1 };
};
const _c39 = function (a0) {
  return { exact: a0 };
};
function NavbarLinkComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵprojection(2);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("title", ctx_r0.linkText);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r0.uri)(
      "ngClass",
      ɵngcc0.ɵɵpureFunction2(
        5,
        _c38,
        ctx_r0.active === true,
        ctx_r0.active === false
      )
    )("routerLinkActiveOptions", ɵngcc0.ɵɵpureFunction1(8, _c39, ctx_r0.exact));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.linkText, "");
  }
}
const _c40 = ["navbarMobile"];
const _c41 = ["navbar"];
const _c42 = ["navlinks"];
const _c43 = ["moreLink"];
const _c44 = ["navbarMore"];
function NavbarComponent_img_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "img", 19);
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("src", ctx_r1.brandIcon, ɵngcc0.ɵɵsanitizeUrl);
  }
}
const _c45 = function (a0, a1) {
  return { height: a0, "font-size": a1 };
};
function NavbarComponent_hc_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "hc-icon", 20);
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("fontSet", ctx_r2._brandIconSet())(
      "fontIcon",
      ctx_r2._brandIconGlyph()
    )(
      "ngStyle",
      ɵngcc0.ɵɵpureFunction2(
        3,
        _c45,
        ctx_r2._brandIconSize(),
        ctx_r2._brandIconSize()
      )
    );
  }
}
function NavbarComponent_a_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 21);
    ɵngcc0.ɵɵelement(1, "img", 19);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("routerLink", ctx_r3.homeUri);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("src", ctx_r3.appIcon, ɵngcc0.ɵɵsanitizeUrl);
  }
}
function NavbarComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 22, 23);
    ɵngcc0.ɵɵtext(2, " More ");
    ɵngcc0.ɵɵelement(3, "hc-icon", 24);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r8 = ɵngcc0.ɵɵreference(19);
    ɵngcc0.ɵɵproperty("hcPop", _r8);
  }
}
function NavbarComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 25);
    ɵngcc0.ɵɵlistener(
      "click",
      function NavbarComponent_div_15_Template_div_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r12);
        const ctx_r11 = ɵngcc0.ɵɵnextContext();
        return ctx_r11._toggleMobileMenu();
      }
    );
    ɵngcc0.ɵɵelement(1, "hc-icon", 26);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("fontIcon", ctx_r7._mobileMenuIcon);
  }
}
function NavbarComponent_ng_container_21_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "a", 29);
    ɵngcc0.ɵɵlistener(
      "click",
      function NavbarComponent_ng_container_21_ng_container_1_Template_a_click_1_listener() {
        ɵngcc0.ɵɵrestoreView(_r19);
        const ctx_r18 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r18._moreClick();
      }
    );
    ɵngcc0.ɵɵelementStart(2, "span", 30);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("routerLink", item_r13.uri);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(item_r13.name);
  }
}
function NavbarComponent_ng_container_21_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 31);
    ɵngcc0.ɵɵelementStart(2, "span", 30);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("hcPop", item_r13.dropdown);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(item_r13.name);
  }
}
function NavbarComponent_ng_container_21_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 32);
  }
}
function NavbarComponent_ng_container_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(
      1,
      NavbarComponent_ng_container_21_ng_container_1_Template,
      4,
      2,
      "ng-container",
      27
    );
    ɵngcc0.ɵɵtemplate(
      2,
      NavbarComponent_ng_container_21_ng_container_2_Template,
      4,
      2,
      "ng-container",
      27
    );
    ɵngcc0.ɵɵtemplate(
      3,
      NavbarComponent_ng_container_21_div_3_Template,
      1,
      0,
      "div",
      28
    );
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r13 = ctx.$implicit;
    const i_r14 = ctx.index;
    const ctx_r9 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r13.dropdown);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r13.dropdown);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", i_r14 != ctx_r9._moreList.length - 1);
  }
}
const _c46 = [
  [["hc-navbar-link"], ["hc-navbar-dropdown"]],
  "*",
  [["hc-navbar-mobile-menu"]],
];
const _c47 = function (a0) {
  return { "fixed-top": a0 };
};
const _c48 = [
  "hc-navbar-link, hc-navbar-dropdown",
  "*",
  "hc-navbar-mobile-menu",
];
const _c49 = ["menuPop"];
const _c50 = function (a0, a1) {
  return { active: a0, inactive: a1 };
};
function NavbarDropdownComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelement(2, "hc-icon", 4);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵpropertyInterpolate("title", ctx_r0.linkText);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction2(
        4,
        _c50,
        ctx_r0.active === true,
        ctx_r0.active === false
      )
    )("hcPop", _r1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.linkText, " ");
  }
}
function PaginationComponent_div_1_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "option", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const pageSizeOption_r4 = ctx.$implicit;
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", pageSizeOption_r4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(
      " ",
      ctx_r3.isFocused
        ? pageSizeOption_r4
        : ctx_r3.pageSize === pageSizeOption_r4 &&
          pageSizeOption_r4 > ctx_r3.length
        ? "all"
        : pageSizeOption_r4,
      " "
    );
  }
}
function PaginationComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "label", 9);
    ɵngcc0.ɵɵtext(2, "Showing:");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "hc-select", 10);
    ɵngcc0.ɵɵlistener(
      "change",
      function PaginationComponent_div_1_Template_hc_select_change_3_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r6);
        const ctx_r5 = ɵngcc0.ɵɵnextContext();
        return ctx_r5._changePageSize($event.value);
      }
    )(
      "focus",
      function PaginationComponent_div_1_Template_hc_select_focus_3_listener() {
        ɵngcc0.ɵɵrestoreView(_r6);
        const ctx_r7 = ɵngcc0.ɵɵnextContext();
        return (ctx_r7.isFocused = true);
      }
    )(
      "blur",
      function PaginationComponent_div_1_Template_hc_select_blur_3_listener() {
        ɵngcc0.ɵɵrestoreView(_r6);
        const ctx_r8 = ɵngcc0.ɵɵnextContext();
        return (ctx_r8.isFocused = false);
      }
    );
    ɵngcc0.ɵɵtemplate(
      4,
      PaginationComponent_div_1_option_4_Template,
      2,
      2,
      "option",
      11
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "label", 12);
    ɵngcc0.ɵɵtext(6, "of ");
    ɵngcc0.ɵɵelementStart(7, "strong");
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(9, " entries");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("value", ctx_r0.pageSize);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0._displayedPageSizeOptions);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.length);
  }
}
function PaginationComponent_ng_container_7_button_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(page_r10);
  }
}
function PaginationComponent_ng_container_7_button_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 17);
  }
}
function PaginationComponent_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function PaginationComponent_ng_container_7_button_1_Template_button_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r15);
        const page_r10 = ctx.$implicit;
        const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r14._goToPage(page_r10);
      }
    );
    ɵngcc0.ɵɵtemplate(
      1,
      PaginationComponent_ng_container_7_button_1_span_1_Template,
      2,
      1,
      "span",
      5
    );
    ɵngcc0.ɵɵtemplate(
      2,
      PaginationComponent_ng_container_7_button_1_span_2_Template,
      1,
      0,
      "span",
      16
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r10 = ctx.$implicit;
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp(
      "hc-page-button-current",
      page_r10 === ctx_r9.pageNumber
    );
    ɵngcc0.ɵɵproperty("disabled", !page_r10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !!page_r10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !page_r10);
  }
}
function PaginationComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(
      1,
      PaginationComponent_ng_container_7_button_1_Template,
      3,
      5,
      "button",
      14
    );
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1._visiblePages);
  }
}
function PaginationComponent_ng_container_8_button_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r17 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(page_r17);
  }
}
function PaginationComponent_ng_container_8_button_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 17);
  }
}
function PaginationComponent_ng_container_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function PaginationComponent_ng_container_8_button_1_Template_button_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r22);
        const page_r17 = ctx.$implicit;
        const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r21._goToPage(page_r17);
      }
    );
    ɵngcc0.ɵɵtemplate(
      1,
      PaginationComponent_ng_container_8_button_1_span_1_Template,
      2,
      1,
      "span",
      5
    );
    ɵngcc0.ɵɵtemplate(
      2,
      PaginationComponent_ng_container_8_button_1_span_2_Template,
      1,
      0,
      "span",
      16
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r17 = ctx.$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp(
      "hc-page-button-current",
      page_r17 === ctx_r16.pageNumber
    );
    ɵngcc0.ɵɵproperty("disabled", !page_r17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !!page_r17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !page_r17);
  }
}
function PaginationComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(
      1,
      PaginationComponent_ng_container_8_button_1_Template,
      3,
      5,
      "button",
      14
    );
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r2._collapsedVisiblePages);
  }
}
const _c51 = ["availableList"];
const _c52 = ["confirmedList"];
function PicklistComponent_h2_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.settings.leftHeaderText);
  }
}
const _c53 = function (a0) {
  return { active: a0 };
};
function PicklistComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵelementStart(1, "a", 15);
    ɵngcc0.ɵɵlistener(
      "click",
      function PicklistComponent_div_4_Template_a_click_1_listener() {
        ɵngcc0.ɵɵrestoreView(_r6);
        const ctx_r5 = ɵngcc0.ɵɵnextContext();
        return ctx_r5.setActiveValueType("valueSets");
      }
    );
    ɵngcc0.ɵɵtext(2, "Value Sets");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "a", 16);
    ɵngcc0.ɵɵlistener(
      "click",
      function PicklistComponent_div_4_Template_a_click_3_listener() {
        ɵngcc0.ɵɵrestoreView(_r6);
        const ctx_r7 = ɵngcc0.ɵɵnextContext();
        return ctx_r7.setActiveValueType("values");
      }
    );
    ɵngcc0.ɵɵtext(4, "Values");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(
        2,
        _c53,
        ctx_r1._available == null
          ? null
          : ctx_r1._available.valueSetList.isActive
      )
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(
        4,
        _c53,
        ctx_r1._available == null ? null : ctx_r1._available.valueList.isActive
      )
    );
  }
}
function PicklistComponent_h2_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h2");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.settings.rightHeaderText);
  }
}
const _c54 = ["listContainer"];
const _c55 = ["search"];
function PicklistPaneComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵelement(1, "hc-progress-dots");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_18_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "th", 19);
    ɵngcc0.ɵɵtext(2, "Value Sets");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_18_tr_3_table_9_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 29);
    ɵngcc0.ɵɵelement(1, "hc-progress-dots");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_18_tr_3_table_9_tr_3_span_2_Template(
  rf,
  ctx
) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 32);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r15 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(subItem_r15.option.code);
  }
}
const _c56 = function (a0) {
  return { "hc-row-selected": a0 };
};
function PicklistPaneComponent_table_18_tr_3_table_9_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 30);
    ɵngcc0.ɵɵlistener(
      "mousedown",
      function PicklistPaneComponent_table_18_tr_3_table_9_tr_3_Template_tr_mousedown_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r20);
        const ctx_r19 = ɵngcc0.ɵɵnextContext(4);
        return ctx_r19.preventIEHighlightBug();
      }
    )(
      "click",
      function PicklistPaneComponent_table_18_tr_3_table_9_tr_3_Template_tr_click_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r20);
        const idx_r16 = ctx.index;
        const subItem_r15 = ctx.$implicit;
        const item_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
        const ctx_r21 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r21.onItemClicked(
          $event,
          idx_r16,
          item_r10.subValuesSelectList,
          subItem_r15
        );
      }
    )(
      "dblclick",
      function PicklistPaneComponent_table_18_tr_3_table_9_tr_3_Template_tr_dblclick_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r20);
        const subItem_r15 = ctx.$implicit;
        const item_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
        const ctx_r23 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r23.onItemDoubleClicked(
          $event,
          item_r10.subValuesSelectList,
          subItem_r15
        );
      }
    );
    ɵngcc0.ɵɵelementStart(1, "td");
    ɵngcc0.ɵɵtemplate(
      2,
      PicklistPaneComponent_table_18_tr_3_table_9_tr_3_span_2_Template,
      2,
      1,
      "span",
      31
    );
    ɵngcc0.ɵɵelementStart(3, "span");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r15 = ctx.$implicit;
    const ctx_r14 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(3, _c56, subItem_r15.selected)
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.codeIsSignificant);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(subItem_r15.option.title || "Untitled");
  }
}
function PicklistPaneComponent_table_18_tr_3_table_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table", 26);
    ɵngcc0.ɵɵelementStart(1, "tbody");
    ɵngcc0.ɵɵtemplate(
      2,
      PicklistPaneComponent_table_18_tr_3_table_9_tr_2_Template,
      2,
      0,
      "tr",
      27
    );
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_table_18_tr_3_table_9_tr_3_Template,
      5,
      5,
      "tr",
      28
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", item_r10.loadingValues);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", item_r10.subValuesSelectList.filteredOptions);
  }
}
const _c57 = function (a0) {
  return { "hc-row-selected selected": a0 };
};
const _c58 = function (a0) {
  return { "values-caret-showing-values": a0 };
};
function PicklistPaneComponent_table_18_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 20);
    ɵngcc0.ɵɵlistener(
      "mousedown",
      function PicklistPaneComponent_table_18_tr_3_Template_tr_mousedown_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r27);
        const ctx_r26 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r26.preventIEHighlightBug();
      }
    )(
      "click",
      function PicklistPaneComponent_table_18_tr_3_Template_tr_click_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r27);
        const idx_r11 = ctx.index;
        const item_r10 = ctx.$implicit;
        const ctx_r28 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r28.onItemClicked(
          $event,
          idx_r11,
          ctx_r28.valueSetList,
          item_r10
        );
      }
    )(
      "dblclick",
      function PicklistPaneComponent_table_18_tr_3_Template_tr_dblclick_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r27);
        const item_r10 = ctx.$implicit;
        const ctx_r29 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r29.onItemDoubleClicked(
          $event,
          ctx_r29.valueSetList,
          item_r10
        );
      }
    );
    ɵngcc0.ɵɵelementStart(1, "td");
    ɵngcc0.ɵɵelementStart(2, "div");
    ɵngcc0.ɵɵelementStart(3, "span", 21);
    ɵngcc0.ɵɵlistener(
      "click",
      function PicklistPaneComponent_table_18_tr_3_Template_span_click_3_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r27);
        const item_r10 = ctx.$implicit;
        const ctx_r30 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r30.onValuesetCaretClicked($event, item_r10);
      }
    );
    ɵngcc0.ɵɵelement(4, "hc-icon", 22);
    ɵngcc0.ɵɵelement(5, "hc-icon", 23);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span", 24);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "div");
    ɵngcc0.ɵɵtemplate(
      9,
      PicklistPaneComponent_table_18_tr_3_table_9_Template,
      4,
      2,
      "table",
      25
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(6, _c57, item_r10.selected)
    );
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(8, _c58, item_r10.showValues)
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "fontIcon",
      item_r10.showValues ? "fa-folder-open-o" : "fa-folder-o"
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate2(
      "",
      item_r10.option.title || "Untitled",
      " (",
      item_r10.option.subValueCount,
      ")"
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", item_r10.showValues);
  }
}
function PicklistPaneComponent_table_18_tr_4_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 35);
    ɵngcc0.ɵɵlistener(
      "click",
      function PicklistPaneComponent_table_18_tr_4_a_1_Template_a_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r34);
        const ctx_r33 = ɵngcc0.ɵɵnextContext(3);
        return ctx_r33.triggerLoadMore("valuesets");
      }
    );
    ɵngcc0.ɵɵtext(1, "Load More");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_18_tr_4_hc_progress_dots_3_Template(
  rf,
  ctx
) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "hc-progress-dots");
  }
}
function PicklistPaneComponent_table_18_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 33);
    ɵngcc0.ɵɵtemplate(
      1,
      PicklistPaneComponent_table_18_tr_4_a_1_Template,
      2,
      0,
      "a",
      34
    );
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_table_18_tr_4_hc_progress_dots_3_Template,
      1,
      0,
      "hc-progress-dots",
      16
    );
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      !ɵngcc0.ɵɵpipeBind1(2, 2, ctx_r9.valueSetList.appendingOptions)
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ɵngcc0.ɵɵpipeBind1(4, 4, ctx_r9.valueSetList.appendingOptions)
    );
  }
}
function PicklistPaneComponent_table_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table", 15);
    ɵngcc0.ɵɵelementStart(1, "tbody");
    ɵngcc0.ɵɵtemplate(
      2,
      PicklistPaneComponent_table_18_tr_2_Template,
      3,
      0,
      "tr",
      16
    );
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_table_18_tr_3_Template,
      10,
      10,
      "tr",
      17
    );
    ɵngcc0.ɵɵtemplate(
      4,
      PicklistPaneComponent_table_18_tr_4_Template,
      5,
      6,
      "tr",
      18
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r3.shouldShowList(ctx_r3.valueSetList) &&
        ctx_r3.shouldShowList(ctx_r3.valueList)
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.valueSetList.filteredOptions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r3.isPaged &&
        ctx_r3.optionsShowingCount < ctx_r3.optionsAvailableCount
    );
  }
}
function PicklistPaneComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵelement(1, "hc-progress-dots");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_22_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "th", 19);
    ɵngcc0.ɵɵtext(2, "Individual Values");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_22_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 39);
    ɵngcc0.ɵɵelementStart(1, "td", 19);
    ɵngcc0.ɵɵelementStart(2, "span", 40);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5, "Too many results to select all.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r36 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(
      "",
      ctx_r36.valueList.selectedOptions.size,
      " Selected."
    );
  }
}
function PicklistPaneComponent_table_22_tr_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 44);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r39 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(item_r39.option.code);
  }
}
function PicklistPaneComponent_table_22_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r44 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr", 41);
    ɵngcc0.ɵɵlistener(
      "mousedown",
      function PicklistPaneComponent_table_22_tr_4_Template_tr_mousedown_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r44);
        const ctx_r43 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r43.preventIEHighlightBug();
      }
    )(
      "click",
      function PicklistPaneComponent_table_22_tr_4_Template_tr_click_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r44);
        const idx_r40 = ctx.index;
        const item_r39 = ctx.$implicit;
        const ctx_r45 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r45.onItemClicked(
          $event,
          idx_r40,
          ctx_r45.valueList,
          item_r39
        );
      }
    )(
      "dblclick",
      function PicklistPaneComponent_table_22_tr_4_Template_tr_dblclick_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r44);
        const item_r39 = ctx.$implicit;
        const ctx_r46 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r46.onItemDoubleClicked($event, ctx_r46.valueList, item_r39);
      }
    );
    ɵngcc0.ɵɵtemplate(
      1,
      PicklistPaneComponent_table_22_tr_4_td_1_Template,
      2,
      1,
      "td",
      42
    );
    ɵngcc0.ɵɵelementStart(2, "td", 43);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r39 = ctx.$implicit;
    const ctx_r37 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(3, _c56, item_r39.selected)
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r37.codeIsSignificant);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(item_r39.option.title || "Untitled");
  }
}
function PicklistPaneComponent_table_22_tr_5_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r50 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 35);
    ɵngcc0.ɵɵlistener(
      "click",
      function PicklistPaneComponent_table_22_tr_5_a_1_Template_a_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r50);
        const ctx_r49 = ɵngcc0.ɵɵnextContext(3);
        return ctx_r49.triggerLoadMore("values");
      }
    );
    ɵngcc0.ɵɵtext(1, "Load More");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_table_22_tr_5_hc_progress_dots_3_Template(
  rf,
  ctx
) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "hc-progress-dots");
  }
}
function PicklistPaneComponent_table_22_tr_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr", 33);
    ɵngcc0.ɵɵtemplate(
      1,
      PicklistPaneComponent_table_22_tr_5_a_1_Template,
      2,
      0,
      "a",
      34
    );
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_table_22_tr_5_hc_progress_dots_3_Template,
      1,
      0,
      "hc-progress-dots",
      16
    );
    ɵngcc0.ɵɵpipe(4, "async");
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r38 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      !ɵngcc0.ɵɵpipeBind1(2, 2, ctx_r38.valueList.appendingOptions)
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ɵngcc0.ɵɵpipeBind1(4, 4, ctx_r38.valueList.appendingOptions)
    );
  }
}
const _c59 = function (a0) {
  return { "no-code-column": a0 };
};
function PicklistPaneComponent_table_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table", 36);
    ɵngcc0.ɵɵelementStart(1, "tbody");
    ɵngcc0.ɵɵtemplate(
      2,
      PicklistPaneComponent_table_22_tr_2_Template,
      3,
      0,
      "tr",
      16
    );
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_table_22_tr_3_Template,
      6,
      1,
      "tr",
      37
    );
    ɵngcc0.ɵɵtemplate(
      4,
      PicklistPaneComponent_table_22_tr_4_Template,
      4,
      5,
      "tr",
      38
    );
    ɵngcc0.ɵɵtemplate(
      5,
      PicklistPaneComponent_table_22_tr_5_Template,
      5,
      6,
      "tr",
      18
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(5, _c59, !ctx_r5.codeIsSignificant)
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r5.shouldShowList(ctx_r5.valueSetList) &&
        ctx_r5.shouldShowList(ctx_r5.valueList)
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5.showTooManyToSelectAllMsg);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.valueList.filteredOptions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r5.isPaged &&
        ctx_r5.optionsShowingCount < ctx_r5.optionsAvailableCount
    );
  }
}
function PicklistPaneComponent_div_24_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, "Nothing matches your search.");
    ɵngcc0.ɵɵelementEnd();
  }
}
function PicklistPaneComponent_div_24_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r53 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r53.emptyMsg);
  }
}
function PicklistPaneComponent_div_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 45);
    ɵngcc0.ɵɵtemplate(
      1,
      PicklistPaneComponent_div_24_span_1_Template,
      2,
      0,
      "span",
      46
    );
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtemplate(
      3,
      PicklistPaneComponent_div_24_ng_template_3_Template,
      1,
      1,
      "ng-template",
      null,
      47,
      ɵngcc0.ɵɵtemplateRefExtractor
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r52 = ɵngcc0.ɵɵreference(4);
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty(
      "ngIf",
      ctx_r6.listIsFilteredToEmpty(ctx_r6.valueList) ||
        ctx_r6.listIsFilteredToEmpty(ctx_r6.valueSetList)
    )("ngIfElse", _r52);
  }
}
const _c60 = ["scrollContainer"];
const _c61 = function (a0) {
  return { "hc-scroll-nav-smooth": a0 };
};
const _c62 = ["hc-sort-header", ""];
const _c63 = ["*", [["hc-cell-resizer"]]];
const _c64 = function (a0, a1, a2) {
  return {
    "hc-sort-header-asc": a0,
    "hc-sort-header-desc": a1,
    "hc-sort-header-off": a2,
  };
};
const _c65 = ["*", "hc-cell-resizer"];
function StepperComponent_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "hc-icon", 11);
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("fontSet", step_r2.iconSet)("fontIcon", step_r2.icon);
  }
}
function StepperComponent_div_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
  }
  if (rf & 2) {
    const i_r3 = ɵngcc0.ɵɵnextContext().index;
    ɵngcc0.ɵɵtextInterpolate(i_r3 + 1);
  }
}
function StepperComponent_div_3_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ɵngcc0.ɵɵnextContext().index;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(i_r3 + 1);
  }
}
const _c66 = function () {
  return { exact: true };
};
const _c67 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
  return {
    "hc-step-arrow-active": a0,
    "hc-step-arrow-incomplete": a1,
    "hc-step-arrow-complete": a2,
    "hc-step-arrow-completed": a3,
    "hc-step-isolated-active": a4,
    "hc-step-isolated-incomplete": a5,
    "hc-step-isolated-complete": a6,
    "hc-step-isolated-completed": a7,
    "hc-step-last": a8,
    "hc-step-first": a9,
    "hc-stepper-clickable": a10,
    "hc-stepper-disabled": a11,
  };
};
function StepperComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵlistener(
      "click",
      function StepperComponent_div_3_Template_div_click_0_listener() {
        ɵngcc0.ɵɵrestoreView(_r14);
        const i_r3 = ctx.index;
        const ctx_r13 = ɵngcc0.ɵɵnextContext();
        return ctx_r13._stepClick(i_r3);
      }
    );
    ɵngcc0.ɵɵelementStart(1, "span", 5);
    ɵngcc0.ɵɵtemplate(
      2,
      StepperComponent_div_3_ng_container_2_Template,
      2,
      2,
      "ng-container",
      6
    );
    ɵngcc0.ɵɵtemplate(
      3,
      StepperComponent_div_3_ng_template_3_Template,
      1,
      1,
      "ng-template",
      null,
      7,
      ɵngcc0.ɵɵtemplateRefExtractor
    );
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      5,
      StepperComponent_div_3_span_5_Template,
      2,
      1,
      "span",
      8
    );
    ɵngcc0.ɵɵelementStart(6, "span", 9);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(8, "span", 10);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const isLast_r4 = ctx.last;
    const isFirst_r5 = ctx.first;
    const _r7 = ɵngcc0.ɵɵreference(4);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("routerLink", step_r2.routerLink)(
      "routerLinkActiveOptions",
      ɵngcc0.ɵɵpureFunction0(8, _c66)
    )("queryParams", step_r2.queryParams)(
      "ngClass",
      ɵngcc0.ɵɵpureFunctionV(9, _c67, [
        ctx_r0.type === "arrow" && i_r3 === ctx_r0.activeIndex,
        ctx_r0.type === "arrow" &&
          (ctx_r0.activeIndex === undefined || i_r3 > ctx_r0.activeIndex),
        ctx_r0.type === "arrow" &&
          ctx_r0.activeIndex !== undefined &&
          i_r3 < ctx_r0.activeIndex - 1,
        ctx_r0.type === "arrow" &&
          ctx_r0.activeIndex !== undefined &&
          i_r3 === ctx_r0.activeIndex - 1,
        ctx_r0.type === "isolated" && i_r3 === ctx_r0.activeIndex,
        ctx_r0.type === "isolated" &&
          (ctx_r0.activeIndex === undefined || i_r3 > ctx_r0.activeIndex),
        ctx_r0.type === "isolated" &&
          ctx_r0.activeIndex !== undefined &&
          i_r3 < ctx_r0.activeIndex - 1,
        ctx_r0.type === "isolated" &&
          ctx_r0.activeIndex !== undefined &&
          i_r3 === ctx_r0.activeIndex - 1,
        isLast_r4,
        isFirst_r5,
        step_r2.disabled !== undefined ? !step_r2.disabled : true,
        step_r2.disabled !== undefined ? step_r2.disabled : false,
      ])
    );
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", step_r2.iconSet && step_r2.icon)("ngIfElse", _r7);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showStepCount);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(step_r2.label);
  }
}
function StepperComponent_div_5_router_outlet_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "router-outlet");
  }
}
function StepperComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(
      1,
      StepperComponent_div_5_router_outlet_1_Template,
      1,
      0,
      "router-outlet",
      14
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1._routerEnabled);
  }
}
const _c68 = [
  [["", 8, "before-steps-content"]],
  [["", 8, "after-steps-content"]],
];
const _c69 = [".before-steps-content", ".after-steps-content"];
const _c70 = [[["caption"]], [["colgroup"], ["col"]]];
const _c71 = ["caption", "colgroup, col"];
const _c72 = ["tabTitle"];
function HcTabTitleComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
  }
}
const _c73 = ["tabContent"];
function TabComponent_ng_container_0_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 6);
  }
  if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6._htmlTitle.tabTitle);
  }
}
const _c74 = function () {
  return {};
};
function TabComponent_ng_container_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵlistener(
      "click",
      function TabComponent_ng_container_0_a_1_Template_a_click_0_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r8);
        const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
        return ctx_r7.tabClickHandler($event);
      }
    );
    ɵngcc0.ɵɵtemplate(
      1,
      TabComponent_ng_container_0_a_1_ng_container_1_Template,
      1,
      1,
      "ng-container",
      5
    );
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassMapInterpolate1(
      "hc-tab-",
      ctx_r5._direction,
      " hc-text-ellipsis"
    );
    ɵngcc0.ɵɵclassProp("hc-tab-tight", ctx_r5._tight)("active", ctx_r5._active);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r5.routerLink)(
      "queryParams",
      ctx_r5.queryParams
    )(
      "routerLinkActiveOptions",
      ctx_r5.exactRouteMatch
        ? ɵngcc0.ɵɵpureFunction0(12, _c66)
        : ɵngcc0.ɵɵpureFunction0(13, _c74)
    );
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r5._htmlTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.tabTitle, " ");
  }
}
function TabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(
      1,
      TabComponent_ng_container_0_a_1_Template,
      3,
      14,
      "a",
      3
    );
    ɵngcc0.ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.routerLink)("ngIfElse", _r1);
  }
}
function TabComponent_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 6);
  }
  if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r9._htmlTitle.tabTitle);
  }
}
function TabComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 7);
    ɵngcc0.ɵɵlistener(
      "click",
      function TabComponent_ng_template_1_Template_a_click_0_listener($event) {
        ɵngcc0.ɵɵrestoreView(_r11);
        const ctx_r10 = ɵngcc0.ɵɵnextContext();
        return ctx_r10.tabClickHandler($event);
      }
    );
    ɵngcc0.ɵɵtemplate(
      1,
      TabComponent_ng_template_1_ng_container_1_Template,
      1,
      1,
      "ng-container",
      5
    );
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1(
      "hc-tab-",
      ctx_r2._direction,
      " hc-text-ellipsis"
    );
    ɵngcc0.ɵɵclassProp("hc-tab-tight", ctx_r2._tight)("active", ctx_r2._active);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2._htmlTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.tabTitle, " ");
  }
}
function TabComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
  }
}
function TabSetComponent_div_4_router_outlet_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "router-outlet");
  }
}
function TabSetComponent_div_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 3);
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r2.tabContent);
  }
}
function TabSetComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(
      1,
      TabSetComponent_div_4_router_outlet_1_Template,
      1,
      0,
      "router-outlet",
      1
    );
    ɵngcc0.ɵɵtemplate(
      2,
      TabSetComponent_div_4_ng_container_2_Template,
      1,
      1,
      "ng-container",
      2
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("hc-tab-content-", ctx_r0.direction, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0._routerEnabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0._routerEnabled);
  }
}
const _c75 = [[["hc-tab"]], "*"];
const _c76 = ["hc-tab", "*"];
function HcToastComponent_div_1_ng_template_1_Template(rf, ctx) {}
function HcToastComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(
      1,
      HcToastComponent_div_1_ng_template_1_Template,
      0,
      0,
      "ng-template",
      4
    );
    ɵngcc0.ɵɵlistener(
      "attached",
      function HcToastComponent_div_1_Template_ng_template_attached_1_listener(
        $event
      ) {
        ɵngcc0.ɵɵrestoreView(_r5);
        const ctx_r4 = ɵngcc0.ɵɵnextContext();
        return ctx_r4._customComponentAttached($event);
      }
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("cdkPortalOutlet", ctx_r0._toastPortal);
  }
}
function HcToastComponent_div_2_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵelement(1, "div", 12);
    ɵngcc0.ɵɵelementEnd();
  }
}
const _c77 = function (a0) {
  return { "hc-toast-progress-offset": a0 };
};
function HcToastComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵelementStart(1, "div", 6);
    ɵngcc0.ɵɵelement(2, "div", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div");
    ɵngcc0.ɵɵelementStart(4, "div", 8);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "div", 9);
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(
      8,
      HcToastComponent_div_2_div_8_Template,
      2,
      0,
      "div",
      10
    );
    ɵngcc0.ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(4, _c77, ctx_r1._hasProgressBar)
    );
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1._headerText);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1._bodyText);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1._canDismiss);
  }
}
const _c78 = function (a0) {
  return { "hc-toast-progress-indeterminate": a0 };
};
const _c79 = function (a0) {
  return { width: a0 };
};
function HcToastComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
  }
  if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty(
      "ngClass",
      ɵngcc0.ɵɵpureFunction1(2, _c78, !ctx_r2._progressVal)
    )("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c79, ctx_r2._progressWidth));
  }
}
const _c80 = function (a0) {
  return { "hc-toast-dismiss": a0 };
};
function parseBooleanAttribute(value) {
  if (typeof value === "boolean") {
    return value;
  }
  if (value.toLowerCase() === "false") {
    return false;
  }
  if (value.toLowerCase() === "true" || value === "") {
    return true;
  }
  throw Error(String(value) + " is not a boolean value");
}
/* Open Source `take-until-destroy` operator from: https://github.com/NetanelBasal/ngx-take-until-destroy */
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
  return typeof value === "function";
}
/** @type {?} */
const untilDestroyed =
  /**
   * @param {?} componentInstance
   * @param {?=} destroyMethodName
   * @return {?}
   */
  (
    componentInstance,
    destroyMethodName = "ngOnDestroy"
    /**
     * @template T
     * @param {?} source
     * @return {?}
     */
  ) => (source) => {
    /** @type {?} */
    const originalDestroy = componentInstance[destroyMethodName];
    if (isFunction(originalDestroy) === false) {
      throw new Error(
        `${componentInstance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`
      );
    }
    if (!componentInstance["__takeUntilDestroy"]) {
      componentInstance["__takeUntilDestroy"] = new Subject();
      componentInstance[destroyMethodName] =
        /**
         * @return {?}
         */
        function () {
          isFunction(originalDestroy) && originalDestroy.apply(this, arguments);
          componentInstance["__takeUntilDestroy"].next(true);
          componentInstance["__takeUntilDestroy"].complete();
        };
    }
    return source.pipe(takeUntil(componentInstance["__takeUntilDestroy"]));
  };

/**
 * @fileoverview added by tsickle
 * Generated from: lib/accordion/accordion.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedAligns = ["left", "right"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateAlignInput(inputStr) {
  if (supportedAligns.indexOf(inputStr) < 0) {
    throw Error("Unsupported accordion alignment value: " + inputStr);
  }
}
/**
 * Parent component that can have a `<hc-accordion-toolbar>` and content that is collapsable
 */
class AccordionComponent {
  constructor() {
    this._animationDisabled = false;
    this._currentlyAnimating = false;
    this._hideToolbar = false;
    this._toolbarTrigger = true;
    this._triggerAlign = "left";
    this.__isOpen = false;
    /**
     * Allows for two-way binding of the `open` property
     */
    this.openChange = new EventEmitter();
    /**
     * Event emitted when accordion is opened.
     */
    this.opened = new EventEmitter();
    /**
     * Event emitted when accordion has started to open.
     */
    this.openStart = new EventEmitter();
    /**
     * Event emitted when accordion is closed.
     */
    this.closed = new EventEmitter();
    /**
     * Event emitted when accordion has started to close.
     */
    this.closeStart = new EventEmitter();
    this._hostClass = true;
  }
  /**
   * Side the accordion trigger is attached to: `left` or `right`
   * @return {?}
   */
  get triggerAlign() {
    return this._triggerAlign;
  }
  /**
   * @param {?} alignType
   * @return {?}
   */
  set triggerAlign(alignType) {
    validateAlignInput(alignType);
    this._triggerAlign = alignType;
  }
  /**
   * Whether the entire width of the accordion bar is clickable, or only the down arrow button; default = true
   * @return {?}
   */
  get toolbarTrigger() {
    return this._toolbarTrigger;
  }
  /**
   * @param {?} doTrigger
   * @return {?}
   */
  set toolbarTrigger(doTrigger) {
    this._toolbarTrigger = parseBooleanAttribute(doTrigger);
  }
  /**
   * Hide toolbar.
   * @return {?}
   */
  get hideToolbar() {
    return this._hideToolbar;
  }
  /**
   * @param {?} hide
   * @return {?}
   */
  set hideToolbar(hide) {
    this._hideToolbar = parseBooleanAttribute(hide);
  }
  /**
   * Whether the accordion is opened.
   * @return {?}
   */
  get open() {
    return this.__isOpen;
  }
  /**
   * @param {?} opened
   * @return {?}
   */
  set open(opened) {
    this.toggle(parseBooleanAttribute(opened));
  }
  /**
   * @return {?}
   */
  get _alignment() {
    return this.triggerAlign === "right" ? "hc-align-right" : "";
  }
  /**
   * @return {?}
   */
  get _pointer() {
    return this.toolbarTrigger === true ? "hc-toolbar-pointer" : "";
  }
  /**
   * @return {?}
   */
  get _openState() {
    if (this.__isOpen) {
      return this._animationDisabled ? "open-instant" : "open";
    }
    return "void";
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _animationStart(event) {
    this._currentlyAnimating = true;
    const { fromState, toState } = event;
    if (fromState === "void" && toState === "open") {
      this.openStart.emit();
    } else if (fromState === "open" && toState === "void") {
      this.closeStart.emit();
    }
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _animationEnd(event) {
    this._currentlyAnimating = false;
    const { fromState, toState } = event;
    if (fromState === "void" && toState === "open") {
      this.opened.emit();
    } else if (fromState === "open" && toState === "void") {
      this.closed.emit();
    }
  }
  /**
   * @return {?}
   */
  get _isOpened() {
    return this.__isOpen && !this._currentlyAnimating;
  }
  /**
   * @return {?}
   */
  get _isOpening() {
    return this.__isOpen && this._currentlyAnimating;
  }
  /**
   * @return {?}
   */
  get _isClosed() {
    return !this.__isOpen && !this._currentlyAnimating;
  }
  /**
   * @return {?}
   */
  get _isClosing() {
    return !this.__isOpen && this._currentlyAnimating;
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._animationDisabled = false;
  }
  /**
   * @param {?} event
   * @param {?} toolbarClick
   * @return {?}
   */
  _triggerClick(event, toolbarClick) {
    if ((toolbarClick && this.toolbarTrigger) || !toolbarClick) {
      event.stopPropagation();
      this.toggle();
    }
  }
  /**
   * Opens accordion.
   * @return {?}
   */
  toggleOpen() {
    return this.toggle(true);
  }
  /**
   * Closes accordion.
   * @return {?}
   */
  toggleClose() {
    return this.toggle(false);
  }
  /**
   * Toggle this accordion.
   * @param {?=} isOpen
   * @return {?}
   */
  toggle(isOpen = !this.open) {
    if (!this._currentlyAnimating) {
      this.__isOpen = isOpen;
      this.openChange.emit(isOpen);
    }
  }
}
AccordionComponent.ɵfac = function AccordionComponent_Factory(t) {
  return new (t || AccordionComponent)();
};
AccordionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: AccordionComponent,
  selectors: [["hc-accordion"]],
  hostVars: 10,
  hostBindings: function AccordionComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-accordion", ctx._hostClass)(
        "hc-accordion-opened",
        ctx._isOpened
      )("hc-accordion-opening", ctx._isOpening)(
        "hc-accordion-closed",
        ctx._isClosed
      )("hc-accordion-closing", ctx._isClosing);
    }
  },
  inputs: {
    triggerAlign: "triggerAlign",
    toolbarTrigger: "toolbarTrigger",
    hideToolbar: "hideToolbar",
    open: "open",
  },
  outputs: {
    openChange: "openChange",
    opened: "opened",
    openStart: "openStart",
    closed: "closed",
    closeStart: "closeStart",
  },
  exportAs: ["hcAccordion"],
  ngContentSelectors: _c2,
  decls: 4,
  vars: 2,
  consts: [
    ["class", "hc-accordion-toolbar-wrapper", 3, "ngClass", "click", 4, "ngIf"],
    [1, "hc-accordion-collapse"],
    [1, "hc-accordion-content"],
    [1, "hc-accordion-toolbar-wrapper", 3, "ngClass", "click"],
    ["type", "button", 1, "hc-accordion-trigger", 3, "click"],
  ],
  template: function AccordionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c1);
      ɵngcc0.ɵɵtemplate(0, AccordionComponent_div_0_Template, 3, 4, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵlistener(
        "@openState.start",
        function AccordionComponent_Template_div_animation_openState_start_1_listener(
          $event
        ) {
          return ctx._animationStart($event);
        }
      )(
        "@openState.done",
        function AccordionComponent_Template_div_animation_openState_done_1_listener(
          $event
        ) {
          return ctx._animationEnd($event);
        }
      );
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵprojection(3);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", !ctx.hideToolbar);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("@openState", ctx._openState);
    }
  },
  directives: [ɵngcc1.NgIf, ɵngcc1.NgClass],
  styles: [
    ".hc-accordion{display:block;background:0 0;color:currentColor;box-sizing:border-box}.hc-accordion-toolbar-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:nowrap;-webkit-box-align:center;align-items:center}.hc-accordion-toolbar-wrapper.hc-toolbar-pointer{cursor:pointer}.hc-accordion-trigger{background:0 0;border:none;color:#00aeff;cursor:pointer;height:48px;outline:0;padding:0;position:relative;width:48px;margin:2px;border-radius:4px;-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center}.hc-accordion-trigger::after{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNi45NzgiIGhlaWdodD0iMTcuMzE5IiB2aWV3Qm94PSIwIDAgMjYuOTc4IDE3LjMxOSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNSIgZGF0YS1uYW1lPSJQYXRoIDUiIGNsYXNzPSJjbHMtMSIgZD0iTTI4LjE3NS0xMi4xODhhMS4wODEsMS4wODEsMCwwLDAsMC0xLjUyM0wyNS40LTE2LjQ3M2ExLjA2MSwxLjA2MSwwLDAsMC0xLjUwNywwTDE1LTcuNTg0bC04Ljg5LTguODlhMS4wNjEsMS4wNjEsMCwwLDAtMS41MDcsMEwxLjgyNS0xMy43MTFhMS4wODEsMS4wODEsMCwwLDAsMCwxLjUyM0wxNC4yNDcuMjE4YTEuMDYxLDEuMDYxLDAsMCwwLDEuNTA3LDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;box-sizing:border-box;content:'';display:block;height:8.5px;margin-top:2px;pointer-events:none;-webkit-transform:rotate(180deg);transform:rotate(180deg);-webkit-transition:-webkit-transform .5s cubic-bezier(.25,.8,.25,1);transition:transform .5s cubic-bezier(.25,.8,.25,1);transition:transform .5s cubic-bezier(.25,.8,.25,1),-webkit-transform .5s cubic-bezier(.25,.8,.25,1);width:13px}.hc-accordion-trigger:focus{box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-accordion-closed .hc-accordion-trigger::after,.hc-accordion-closing .hc-accordion-trigger::after{-webkit-transform:rotate(0);transform:rotate(0)}.hc-accordion-toolbar-wrapper.hc-align-right .hc-accordion-trigger{margin-left:auto;-webkit-box-ordinal-group:2;order:1}.hc-accordion-collapse{display:block;overflow:hidden}.hc-accordion-toolbar{-webkit-box-align:center;align-items:center;box-sizing:border-box;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.hc-accordion-toolbar-wrapper.hc-align-right .hc-accordion-toolbar{-webkit-box-ordinal-group:1;order:0}.hc-accordion-content{outline:0;padding:12px 0}",
  ],
  encapsulation: 2,
  data: {
    animation: [
      trigger("openState", [
        state(
          "open, open-instant",
          style({
            height: "*",
          })
        ),
        state(
          "void",
          style({
            height: "0px",
            visibility: "hidden",
          })
        ),
        transition("void => open-instant", animate("0ms")),
        transition("void <=> open", animate("400ms ease")),
      ]),
    ],
  },
});
AccordionComponent.propDecorators = {
  triggerAlign: [{ type: Input }],
  toolbarTrigger: [{ type: Input }],
  hideToolbar: [{ type: Input }],
  open: [{ type: Input }],
  openChange: [{ type: Output }],
  opened: [{ type: Output }],
  openStart: [{ type: Output }],
  closed: [{ type: Output }],
  closeStart: [{ type: Output }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-accordion"] }],
  _isOpened: [{ type: HostBinding, args: ["class.hc-accordion-opened"] }],
  _isOpening: [{ type: HostBinding, args: ["class.hc-accordion-opening"] }],
  _isClosed: [{ type: HostBinding, args: ["class.hc-accordion-closed"] }],
  _isClosing: [{ type: HostBinding, args: ["class.hc-accordion-closing"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype._animationDisabled;
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype._currentlyAnimating;
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype._hideToolbar;
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype._toolbarTrigger;
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype._triggerAlign;
  /**
   * @type {?}
   * @private
   */
  AccordionComponent.prototype.__isOpen;
  /**
   * Allows for two-way binding of the `open` property
   * @type {?}
   */
  AccordionComponent.prototype.openChange;
  /**
   * Event emitted when accordion is opened.
   * @type {?}
   */
  AccordionComponent.prototype.opened;
  /**
   * Event emitted when accordion has started to open.
   * @type {?}
   */
  AccordionComponent.prototype.openStart;
  /**
   * Event emitted when accordion is closed.
   * @type {?}
   */
  AccordionComponent.prototype.closed;
  /**
   * Event emitted when accordion has started to close.
   * @type {?}
   */
  AccordionComponent.prototype.closeStart;
  /** @type {?} */
  AccordionComponent.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/accordion/accordion-toolbar.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container for content that is to be shown in-line with the accordion trigger
 */
class AccordionToolbarComponent {
  constructor() {
    this._hostClass = true;
  }
}
AccordionToolbarComponent.ɵfac = function AccordionToolbarComponent_Factory(t) {
  return new (t || AccordionToolbarComponent)();
};
AccordionToolbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: AccordionToolbarComponent,
  selectors: [["hc-accordion-toolbar"]],
  hostVars: 2,
  hostBindings: function AccordionToolbarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-accordion-toolbar", ctx._hostClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function AccordionToolbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0,
});
AccordionToolbarComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-accordion-toolbar"] }],
};
if (false) {
  /** @type {?} */
  AccordionToolbarComponent.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/accordion/accordion.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionModule {}
AccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AccordionModule });
AccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function AccordionModule_Factory(t) {
    return new (t || AccordionModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/accordion/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/app-switcher-interfaces.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IDiscoveryApplication() {}
if (false) {
  /** @type {?} */
  IDiscoveryApplication.prototype.ServiceName;
  /** @type {?} */
  IDiscoveryApplication.prototype.FriendlyName;
  /** @type {?} */
  IDiscoveryApplication.prototype.Description;
  /** @type {?} */
  IDiscoveryApplication.prototype.BuildNumber;
  /** @type {?} */
  IDiscoveryApplication.prototype.Version;
  /** @type {?} */
  IDiscoveryApplication.prototype.DiscoveryServiceId;
  /** @type {?} */
  IDiscoveryApplication.prototype.ServiceUrl;
  /** @type {?|undefined} */
  IDiscoveryApplication.prototype.Heartbeat;
  /** @type {?|undefined} */
  IDiscoveryApplication.prototype.IsHidden;
  /** @type {?} */
  IDiscoveryApplication.prototype.DiscoveryType;
  /** @type {?} */
  IDiscoveryApplication.prototype.Icon;
}
/**
 * @record
 */
function IDiscoveryRequest() {}
if (false) {
  /** @type {?} */
  IDiscoveryRequest.prototype.value;
}
/**
 * @record
 */
function IAppSwitcherService() {}
if (false) {
  /** @type {?} */
  IAppSwitcherService.prototype.allApplicationsUri;
  /**
   * @return {?}
   */
  IAppSwitcherService.prototype.getApplications = function () {};
}
/** @type {?} */
const APP_SWITCHER_SERVICE = new InjectionToken("IAppSwitcherService");
/**
 * @record
 */
function IAppSwitcherConfig() {}
if (false) {
  /** @type {?} */
  IAppSwitcherConfig.prototype.discoveryServiceUri;
}
/** @type {?} */
const APP_SWITCHER_CONFIG = new InjectionToken("IAppSwitcherConfig");
class MockAppSwitcherService {
  /**
   * @return {?}
   */
  getApplications() {
    return of({
      value: [
        {
          ServiceName: "MyApp",
          FriendlyName: "My App",
          Description: "The currently showing app",
          BuildNumber: "123",
          Version: 1,
          DiscoveryServiceId: 1,
          ServiceUrl: "http://myapp.com",
          DiscoveryType: "Application",
          Icon: "",
        },
        {
          ServiceName: "AnotherApp",
          FriendlyName: "Another App",
          Description: "App we could switch to",
          BuildNumber: "123",
          Version: 1,
          DiscoveryServiceId: 2,
          ServiceUrl: "http://anotherapp.com",
          DiscoveryType: "Application",
          Icon: "",
        },
      ],
    });
  }
}
if (false) {
  /** @type {?} */
  MockAppSwitcherService.prototype.allApplicationsUri;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/shared/work-tracker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WorkTrackerService {
  /**
   * @param {?} task
   * @return {?}
   */
  start(task) {
    /** @type {?} */
    let working = new ReplaySubject();
    working.next(true);
    task()
      .then(
        /**
         * @return {?}
         */
        () => {
          working.next(false);
        }
      )
      .catch(
        /**
         * @return {?}
         */
        () => {
          working.next(false);
        }
      );
    return working.asObservable();
  }
  /**
   * @param {?} task
   * @return {?}
   */
  startObservable(task) {
    /** @type {?} */
    let working = new ReplaySubject();
    /** @type {?} */
    let taskSubscription = task();
    working.next(true);
    taskSubscription.add(
      /**
       * @return {?}
       */
      () => {
        working.next(false);
        taskSubscription.unsubscribe();
      }
    );
    return working.asObservable();
  }
}
WorkTrackerService.ɵfac = function WorkTrackerService_Factory(t) {
  return new (t || WorkTrackerService)();
};
WorkTrackerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: WorkTrackerService,
  factory: WorkTrackerService.ɵfac,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/app-switcher.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppSwitcherComponent {
  /**
   * @param {?} appSwitcherService
   * @param {?} workTracker
   */
  constructor(appSwitcherService, workTracker) {
    this.appSwitcherService = appSwitcherService;
    this.workTracker = workTracker;
    this.brandBg = "brand";
    this.loadFailed = false;
    this._iconHeight = 60;
    this._serviceName = "";
    this._version = "";
    this.ngUnsubscribe = new Subject();
  }
  /**
   * Sets the height of the app thumbnail icons, width is auto (defaults to 100px)
   * @return {?}
   */
  get iconHeight() {
    return this._iconHeight;
  }
  /**
   * @param {?} heightVal
   * @return {?}
   */
  set iconHeight(heightVal) {
    this._iconHeight = heightVal;
  }
  /**
   * @return {?}
   */
  get serviceName() {
    return this._serviceName;
  }
  /**
   * @param {?} serviceNameVal
   * @return {?}
   */
  set serviceName(serviceNameVal) {
    this._serviceName = serviceNameVal;
  }
  /**
   * @return {?}
   */
  get serviceVersion() {
    return this._version;
  }
  /**
   * @param {?} serviceVersionVal
   * @return {?}
   */
  set serviceVersion(serviceVersionVal) {
    this._version = `${serviceVersionVal}`;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this.loadApplications();
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.ngUnsubscribe.next();
    this.ngUnsubscribe.complete();
  }
  /**
   * @return {?}
   */
  loadApplications() {
    try {
      this.loadApplicationFromDiscoveryService();
    } catch (error) {
      this.handleError(error);
    }
  }
  /**
   * @private
   * @return {?}
   */
  loadApplicationFromDiscoveryService() {
    this.loading = this.workTracker.startObservable(
      /**
       * @return {?}
       */
      () =>
        this.appSwitcherService
          .getApplications()
          .pipe(takeUntil(this.ngUnsubscribe))
          .subscribe(
            /**
             * @param {?} response
             * @return {?}
             */
            (response) => {
              this.loadFailed = false;
              this.applications = response.value;
            },
            /**
             * @param {?} error
             * @return {?}
             */ (error) => {
              this.handleError(error);
            }
          )
    );
  }
  /**
   * @private
   * @param {?} error
   * @return {?}
   */
  handleError(error) {
    console.error(
      "Failed to load applications from the app switcher service.",
      error
    );
    this.loadFailed = true;
  }
  /**
   * @param {?} app
   * @return {?}
   */
  linkIfNotMe(app) {
    return this.appIsMe(app) ? null : app.ServiceUrl;
  }
  /**
   * @param {?} app
   * @return {?}
   */
  appIsMe(app) {
    return (
      app.ServiceName === this.serviceName &&
      `${app.Version}` === this.serviceVersion
    );
  }
}
AppSwitcherComponent.ɵfac = function AppSwitcherComponent_Factory(t) {
  return new (t || AppSwitcherComponent)(
    ɵngcc0.ɵɵdirectiveInject(APP_SWITCHER_SERVICE),
    ɵngcc0.ɵɵdirectiveInject(WorkTrackerService)
  );
};
AppSwitcherComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: AppSwitcherComponent,
  selectors: [["hc-app-switcher"]],
  hostAttrs: [1, "hc-app-switcher-container"],
  inputs: {
    iconHeight: "iconHeight",
    serviceName: "serviceName",
    serviceVersion: "serviceVersion",
  },
  decls: 11,
  vars: 11,
  consts: [
    [1, "hc-app-switcher"],
    [1, "hc-app-switcher-header"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link-inline",
      "class",
      "hc-app-switcher-all-apps-link",
      "target",
      "_blank",
      3,
      "href",
      4,
      "ngIf",
    ],
    [4, "ngIf"],
    [
      "class",
      "hc-app-switcher-empty hc-app-switcher-spinner-container",
      4,
      "ngIf",
    ],
    ["class", "hc-app-switcher-empty", 4, "ngIf"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link-inline",
      "target",
      "_blank",
      1,
      "hc-app-switcher-all-apps-link",
      3,
      "href",
    ],
    [1, "hc-app-switcher-apps"],
    ["class", "hc-app-switcher-app", 4, "ngFor", "ngForOf"],
    [1, "hc-app-switcher-app"],
    ["target", "_blank", 1, "hc-app-switcher-link", 3, "ngClass", "title"],
    [1, "hc-app-switcher-app-img", 3, "ngStyle"],
    [1, "hc-app-switcher-app-title"],
    [1, "hc-app-switcher-empty", "hc-app-switcher-spinner-container"],
    ["diameter", "60"],
    [1, "hc-app-switcher-empty"],
    [1, "hc-app-switcher-warning-icon"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      1,
      "hc-app-switcher-retry",
      3,
      "click",
    ],
    [1, "hc-app-switcher-empty-icon"],
  ],
  template: function AppSwitcherComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "h4", 1);
      ɵngcc0.ɵɵtext(2, " Applications ");
      ɵngcc0.ɵɵtemplate(3, AppSwitcherComponent_a_3_Template, 2, 1, "a", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(
        4,
        AppSwitcherComponent_ng_container_4_Template,
        3,
        1,
        "ng-container",
        3
      );
      ɵngcc0.ɵɵtemplate(5, AppSwitcherComponent_div_5_Template, 2, 0, "div", 4);
      ɵngcc0.ɵɵpipe(6, "async");
      ɵngcc0.ɵɵtemplate(7, AppSwitcherComponent_div_7_Template, 6, 0, "div", 5);
      ɵngcc0.ɵɵpipe(8, "async");
      ɵngcc0.ɵɵtemplate(9, AppSwitcherComponent_div_9_Template, 4, 0, "div", 5);
      ɵngcc0.ɵɵpipe(10, "async");
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngIf", ctx.appSwitcherService.allApplicationsUri);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        (ctx.applications == null ? null : ctx.applications.length) > 0
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(6, 5, ctx.loading));
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        !ɵngcc0.ɵɵpipeBind1(8, 7, ctx.loading) && ctx.loadFailed
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        !ɵngcc0.ɵɵpipeBind1(10, 9, ctx.loading) &&
          (ctx.applications == null ? null : ctx.applications.length) === 0
      );
    }
  },
  directives: function () {
    return [
      ɵngcc1.NgIf,
      ɵngcc1.NgForOf,
      ɵngcc1.NgClass,
      ɵngcc1.NgStyle,
      ProgressSpinnerComponent,
    ];
  },
  pipes: function () {
    return [ɵngcc1.AsyncPipe, EllipsisPipe];
  },
  styles: [
    ".hc-app-switcher-container{height:100%;width:100%}.hc-app-switcher{max-width:360px}.hc-app-switcher-header{-webkit-box-align:baseline;align-items:baseline;border-bottom:1px solid #ccc;display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:10px 0;padding-bottom:5px;padding-left:2px}.hc-app-switcher-all-apps-link{font-size:.92857rem}.hc-app-switcher-apps{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap;-webkit-box-pack:start;justify-content:flex-start}.hc-app-switcher-app{-webkit-box-flex:0;flex:0 0 auto}.hc-app-switcher-link{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:10px;text-decoration:none}.hc-app-switcher-link-highlighted{opacity:.5}.hc-app-switcher-app-title{color:#333;font-weight:600;padding-top:8px;text-align:center;width:100px}.hc-app-switcher-app-img{background-position:center;background-repeat:no-repeat;background-size:cover}.hc-app-switcher-empty{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:20px;text-align:center;width:360px}.hc-app-switcher-spinner-container{padding:65px 0}.hc-app-switcher-warning-icon{background-repeat:no-repeat;height:40px;opacity:.5;width:40px;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMC4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA3OS41IDcwLjEiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc5LjUgNzAuMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHRpdGxlPndhcm48L3RpdGxlPg0KPHBhdGggZD0iTTc4LjgsNjIuOEw0NCwyLjRjLTEuMy0yLjMtNC4zLTMuMS02LjctMS44Yy0wLjcsMC40LTEuNCwxLTEuOCwxLjhMMC43LDYyLjhjLTEuMywyLjMtMC41LDUuMywxLjgsNi43DQoJYzAuNywwLjQsMS42LDAuNywyLjQsMC43aDY5LjdjMi43LDAsNC45LTIuMiw0LjktNC45Qzc5LjUsNjQuNCw3OS4yLDYzLjUsNzguOCw2Mi44eiBNMzUuMiwyMC43aDkuMnYyNS43aC05LjJWMjAuN3ogTTM5LjcsNjAuOA0KCWMtMy4xLDAtNS42LTIuNS01LjYtNS42YzAtMy4xLDIuNS01LjYsNS42LTUuNmMzLjEsMCw1LjYsMi41LDUuNiw1LjZDNDUuNCw1OC4yLDQyLjgsNjAuOCwzOS43LDYwLjh6Ii8+DQo8L3N2Zz4NCg==)}.hc-app-switcher-empty-icon{background-repeat:no-repeat;height:40px;opacity:.5;width:40px;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA5Ni45OSA4NC4xNSI+PHRpdGxlPmVtcHR5PC90aXRsZT48cGF0aCBkPSJNODcuMTQsMTEuNjVhNS41NCw1LjU0LDAsMCwwLTUtMy41N0gxOGE1LjU0LDUuNTQsMCwwLDAtNSwzLjU3TDEuNTYsNTIuM1Y4OC42N2EzLjU3LDMuNTcsMCwwLDAsMy41NywzLjU3SDk1YTMuNTcsMy41NywwLDAsMCwzLjU3LTMuNTdWNTIuM1pNODUuNzIsNTMuNzJINjguNnMtMi4xNC4xOC0yLjE0LDMuNTdsMC0uMDhhMTYuMzgsMTYuMzgsMCwwLDEtMzIuNzQsMGwwLC4wOGMwLTMuMzktMi4xNC0zLjU2LTIuMTQtMy41NkgxNC40Yy01LjcxLDAtMy41Ny01LTMuNTctNWw4LjU2LTMxLjM4QTMuODEsMy44MSwwLDAsMSwyMywxNC41SDc3Ljg3YTMuNzcsMy43NywwLDAsMSwzLjU3LDIuNzlsNy44NSwzMS4zMlM5MS40Miw1My43Miw4NS43Miw1My43MloiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjU2IC04LjA4KSIvPjwvc3ZnPg==)}.hc-app-switcher-retry{cursor:pointer;font-weight:600;margin-top:10px}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
AppSwitcherComponent.ctorParameters = () => [
  {
    type: undefined,
    decorators: [{ type: Inject, args: [APP_SWITCHER_SERVICE] }],
  },
  { type: WorkTrackerService },
];
AppSwitcherComponent.propDecorators = {
  iconHeight: [{ type: Input }],
  serviceName: [{ type: Input }],
  serviceVersion: [{ type: Input }],
};
if (false) {
  /** @type {?} */
  AppSwitcherComponent.prototype.applications;
  /** @type {?} */
  AppSwitcherComponent.prototype.subscription;
  /** @type {?} */
  AppSwitcherComponent.prototype.brandBg;
  /** @type {?} */
  AppSwitcherComponent.prototype.loading;
  /** @type {?} */
  AppSwitcherComponent.prototype.loadFailed;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherComponent.prototype._iconHeight;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherComponent.prototype._serviceName;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherComponent.prototype._version;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherComponent.prototype.ngUnsubscribe;
  /** @type {?} */
  AppSwitcherComponent.prototype.appSwitcherService;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherComponent.prototype.workTracker;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/app-switcher-application-link/app-switcher-links.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppSwitcherLinksComponent {
  /**
   * @param {?} _appSwitcherService
   */
  constructor(_appSwitcherService) {
    this._appSwitcherService = _appSwitcherService;
  }
}
AppSwitcherLinksComponent.ɵfac = function AppSwitcherLinksComponent_Factory(t) {
  return new (t || AppSwitcherLinksComponent)(
    ɵngcc0.ɵɵdirectiveInject(APP_SWITCHER_SERVICE)
  );
};
AppSwitcherLinksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: AppSwitcherLinksComponent,
  selectors: [["hc-app-switcher-links"]],
  decls: 5,
  vars: 1,
  consts: [
    [1, "hc-app-switcher-links-bottom-spacer"],
    [1, "hc-app-switcher-links", 3, "href"],
    ["fontSet", "fa", "fontIcon", "fa-th", 1, "hc-app-switcher-links-icon"],
    [1, "hc-app-switcher-links-text"],
  ],
  template: function AppSwitcherLinksComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelement(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "a", 1);
      ɵngcc0.ɵɵelement(2, "hc-icon", 2);
      ɵngcc0.ɵɵelementStart(3, "span", 3);
      ɵngcc0.ɵɵtext(4, "View all my applications");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty(
        "href",
        ctx._appSwitcherService == null
          ? null
          : ctx._appSwitcherService.allApplicationsUri,
        ɵngcc0.ɵɵsanitizeUrl
      );
    }
  },
  directives: function () {
    return [IconComponent];
  },
  styles: [
    ".hc-app-switcher-links-bottom-spacer{padding-bottom:15px}.hc-app-switcher-links{-webkit-box-align:center;align-items:center;border-top:1px solid #51646f;color:#c0c5cc;display:-webkit-box;display:flex;height:55px;padding-left:2%;text-decoration:none;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-app-switcher-links:hover{background-color:#1b2225}.hc-app-switcher-links-icon{color:#708090;padding-left:28px}.hc-app-switcher-links-text{padding-left:33px}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
AppSwitcherLinksComponent.ctorParameters = () => [
  {
    type: undefined,
    decorators: [{ type: Inject, args: [APP_SWITCHER_SERVICE] }],
  },
];
if (false) {
  /** @type {?} */
  AppSwitcherLinksComponent.prototype._appSwitcherService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const transformPopover = trigger("transformPopover", [
  transition(":enter", [
    style({ opacity: 0 }),
    animate("{{openTransition}}", style({ opacity: 1 })),
  ]),
  transition(":leave", [animate("{{closeTransition}}", style({ opacity: 0 }))]),
]);

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/notification.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NotificationAction = {
  /** Popover should open. */
  OPEN: 0,
  /** Popover should close. */
  CLOSE: 1,
  /** Popover should toggle open or closed. */
  TOGGLE: 2,
  /** Popover has new target positions. */
  REPOSITION: 3,
  /** Popover needs new configuration. */
  UPDATE_CONFIG: 4,
  /** Popover should realign itself to the anchor.  */
  REALIGN: 5,
};
NotificationAction[NotificationAction.OPEN] = "OPEN";
NotificationAction[NotificationAction.CLOSE] = "CLOSE";
NotificationAction[NotificationAction.TOGGLE] = "TOGGLE";
NotificationAction[NotificationAction.REPOSITION] = "REPOSITION";
NotificationAction[NotificationAction.UPDATE_CONFIG] = "UPDATE_CONFIG";
NotificationAction[NotificationAction.REALIGN] = "REALIGN";
/**
 * Event object for dispatching to anchoring service.
 */
class PopoverNotification {
  /**
   * @param {?} action
   * @param {?=} value
   */
  constructor(action, value) {
    this.action = action;
    this.value = value;
  }
}
if (false) {
  /**
   * Action to perform.
   * @type {?}
   */
  PopoverNotification.prototype.action;
  /**
   * Optional payload.
   * @type {?}
   */
  PopoverNotification.prototype.value;
}
class PopoverNotificationService {
  constructor() {
    this.store = new Subject();
  }
  /**
   * Dispatch a notification to all subscribers.
   * @param {?} notification
   * @return {?}
   */
  dispatch(notification) {
    this.store.next(notification);
  }
  /**
   * Stream of notification events.
   * @return {?}
   */
  events() {
    return this.store.asObservable();
  }
  /**
   * Complete event stream.
   * @return {?}
   */
  dispose() {
    this.store.complete();
  }
}
PopoverNotificationService.ɵfac = function PopoverNotificationService_Factory(
  t
) {
  return new (t || PopoverNotificationService)();
};
PopoverNotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PopoverNotificationService,
  factory: PopoverNotificationService.ɵfac,
});
if (false) {
  /**
   * @type {?}
   * @private
   */
  PopoverNotificationService.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/types.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALID_SCROLL = ["noop", "block", "reposition", "close"];
/** @type {?} */
const VALID_TRIGGER = ["click", "mousedown", "rightclick", "hover", "none"];
/** @type {?} */
const VALID_HORIZ_ALIGN = [
  "before",
  "start",
  "center",
  "end",
  "after",
  "mouse",
];
/** @type {?} */
const VALID_VERT_ALIGN = ["above", "start", "center", "end", "below", "mouse"];
/**
 * @record
 */
function HcPopoverOpenOptions() {}
if (false) {
  /**
   * Whether the popover should return focus to the previously focused element after
   * closing. Defaults to true.
   * @type {?|undefined}
   */
  HcPopoverOpenOptions.prototype.restoreFocus;
  /**
   * Whether the first focusable element should be focused on open. Defaults to true.
   * @type {?|undefined}
   */
  HcPopoverOpenOptions.prototype.autoFocus;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getInvalidPopoverError() {
  return Error(
    "HcPopoverAnchorDirective must be provided an HcPopover component instance."
  );
}
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
  return Error("HcPopover is not anchored to any HcPopoverAnchorDirective.");
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
  return Error(
    generateGenericError("horizontalAlign/xAlign", alignment, VALID_HORIZ_ALIGN)
  );
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
  return Error(
    generateGenericError("verticalAlign/yAlign", alignment, VALID_VERT_ALIGN)
  );
}
/**
 * @param {?} trigger
 * @return {?}
 */
function getInvalidTriggerError(trigger) {
  return Error(generateGenericError("trigger", trigger, VALID_TRIGGER));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
  return Error(generateGenericError("scrollStrategy", strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
  return (
    `Invalid ${apiName}: '${invalid}'. Valid options are ` +
    `${valid
      .map(
        /**
         * @param {?} v
         * @return {?}
         */
        (v) => `'${v}'`
      )
      .join(", ")}.`
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/menu-item.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use `hcMenuItem` for a selectable item in an hcMenu.
 */
class MenuItemDirective {
  /**
   * @param {?} ref
   */
  constructor(ref) {
    this.ref = ref;
    this._hostClass = true;
  }
  // Menu Item uses focus for hover highlighting to sync with keyboard navigation of the menu
  /**
   * @return {?}
   */
  focus() {
    this.ref.nativeElement.focus();
  }
  /**
   * @return {?}
   */
  blur() {
    this.ref.nativeElement.blur();
  }
}
MenuItemDirective.ɵfac = function MenuItemDirective_Factory(t) {
  return new (t || MenuItemDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
MenuItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: MenuItemDirective,
  selectors: [
    ["", "hcMenuItem", ""],
    ["", "hcButtonItem", ""],
  ],
  hostVars: 2,
  hostBindings: function MenuItemDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "mouseenter",
        function MenuItemDirective_mouseenter_HostBindingHandler() {
          return ctx.focus();
        }
      )("touchend", function MenuItemDirective_touchend_HostBindingHandler() {
        return ctx.blur();
      })(
        "touchcancel",
        function MenuItemDirective_touchcancel_HostBindingHandler() {
          return ctx.blur();
        }
      )(
        "mouseleave",
        function MenuItemDirective_mouseleave_HostBindingHandler() {
          return ctx.blur();
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-item", ctx._hostClass);
    }
  },
});
/** @nocollapse */
MenuItemDirective.ctorParameters = () => [{ type: ElementRef }];
MenuItemDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-item"] }],
  focus: [{ type: HostListener, args: ["mouseenter"] }],
  blur: [
    { type: HostListener, args: ["touchend"] },
    { type: HostListener, args: ["touchcancel"] },
    { type: HostListener, args: ["mouseleave"] },
  ],
};
if (false) {
  /** @type {?} */
  MenuItemDirective.prototype._hostClass;
  /** @type {?} */
  MenuItemDirective.prototype.ref;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
/** @type {?} */
const DEFAULT_TRANSITION = "100ms linear";
/** @type {?} */
const EMPTY_TRANSITION = "0ms linear";
class HcPopComponent {
  /**
   * @param {?} _elementRef
   * @param {?} _focusTrapFactory
   * @param {?} _document
   */
  constructor(_elementRef, _focusTrapFactory, _document) {
    this._elementRef = _elementRef;
    this._focusTrapFactory = _focusTrapFactory;
    this._document = _document;
    /**
     * Whether or not to disable default popover container styles. *Defaults to `false`.*
     */
    this.disableStyle = false;
    /**
     * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
     */
    this.showArrow = true;
    this._horizontalAlign = "center";
    this._verticalAlign = "below";
    this._forceAlignment = false;
    this._lockAlignment = false;
    this._autoFocus = false;
    this._autoFocusOverride = false;
    this._restoreFocus = true;
    this._restoreFocusOverride = true;
    this._scrollStrategy = "reposition";
    this._hasBackdrop = true;
    this._interactiveClose = true;
    this._openTransition = DEFAULT_TRANSITION;
    this._closeTransition = DEFAULT_TRANSITION;
    /**
     * Should the popover animate? *Defaults to `true`.*
     */
    this.shouldAnimate = true;
    /**
     * Optional backdrop class. *Defaults to `''`.*
     */
    this.backdropClass = "";
    /**
     * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
     */
    this.autoCloseOnContentClick = false;
    /**
     * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
     */
    this.opened = new EventEmitter();
    /**
     * Emits when the popover is closed.
     */
    this.closed = new EventEmitter();
    /**
     * Emits when the popover has finished opening.
     */
    this.afterOpen = new EventEmitter();
    /**
     * Emits when the popover has finished closing.
     */
    this.afterClose = new EventEmitter();
    /**
     * Emits when the backdrop is clicked.
     */
    this.backdropClicked = new EventEmitter();
    /**
     * Emits when a keydown event is targeted to this popover's overlay.
     */
    this.overlayKeydown = new EventEmitter();
    /**
     * Stores the click coordinates for mouse-based positioning
     */
    this._offsetPos = [0, 0];
    /**
     * Classes to be added to the popover for setting the correct transform origin.
     */
    this._classList = {};
    this._yAlignClass = "";
    this._xAlignClass = "";
    /**
     * Whether the popover is presently open.
     */
    this._open = false;
    /**
     * If this menu has children, keep track of whether any of them are open
     */
    this._subMenuOpen = false;
    /**
     * Reference to subscription of parent popover close events
     */
    this._parentClose = new Subject();
    /**
     * Block this popover from closing its parent on close
     */
    this._parentCloseBlock = false;
  }
  /**
   * Alignment of the popover on the horizontal axis. Can be `before`, `start`, `center`, `end`, `after`, or `mouse`.
   * *Defaults to `center`.*
   * @return {?}
   */
  get horizontalAlign() {
    return this._horizontalAlign;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set horizontalAlign(val) {
    this._validateHorizontalAlign(val);
    if (this._horizontalAlign !== val) {
      this._horizontalAlign = val;
      this._dispatchConfigNotification(
        new PopoverNotification(NotificationAction.REPOSITION)
      );
    }
  }
  /**
   * Alignment of the popover on the x axis. Alias for `horizontalAlign`. *Defaults to `"center"`.*
   * @return {?}
   */
  get xAlign() {
    return this.horizontalAlign;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set xAlign(val) {
    this.horizontalAlign = val;
  }
  /**
   * Alignment of the popover on the vertical axis. Can be `above`, `start`, `center`, `end`, `below`, or `mouse`.
   * *Defaults to `"below"`.*
   * @return {?}
   */
  get verticalAlign() {
    return this._verticalAlign;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set verticalAlign(val) {
    this._validateVerticalAlign(val);
    if (this._verticalAlign !== val) {
      this._verticalAlign = val;
      this._dispatchConfigNotification(
        new PopoverNotification(NotificationAction.REPOSITION)
      );
    }
  }
  /**
   * Alignment of the popover on the y axis. Alias for `verticalAlign`. *Defaults to `"below"`.*
   * @return {?}
   */
  get yAlign() {
    return this.verticalAlign;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set yAlign(val) {
    this.verticalAlign = val;
  }
  /**
   * Whether the popover always opens with the specified alignment. *Defaults to `false`.*
   * @return {?}
   */
  get forceAlignment() {
    return this._forceAlignment;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set forceAlignment(val) {
    /** @type {?} */
    const coercedVal = coerceBooleanProperty$1(val);
    if (this._forceAlignment !== coercedVal) {
      this._forceAlignment = coercedVal;
      this._dispatchConfigNotification(
        new PopoverNotification(NotificationAction.REPOSITION)
      );
    }
  }
  /**
   * Whether the popover's alignment is locked after opening. This prevents the popover
   * from changing its alignement when scrolling or changing the size of the viewport.
   * *Defaults to `false`.*
   * @return {?}
   */
  get lockAlignment() {
    return this._lockAlignment;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set lockAlignment(val) {
    /** @type {?} */
    const coercedVal = coerceBooleanProperty$1(val);
    if (this._lockAlignment !== coercedVal) {
      this._lockAlignment = coerceBooleanProperty$1(val);
      this._dispatchConfigNotification(
        new PopoverNotification(NotificationAction.REPOSITION)
      );
    }
  }
  /**
   * Whether the first focusable element should be focused on open. *Defaults to `false`.*
   * @return {?}
   */
  get autoFocus() {
    return this._autoFocus && this._autoFocusOverride;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set autoFocus(val) {
    this._autoFocus = coerceBooleanProperty$1(val);
  }
  /**
   * Whether the popover should return focus to the previously focused element after closing. *Defaults to `true`.*
   * @return {?}
   */
  get restoreFocus() {
    return this._restoreFocus && this._restoreFocusOverride;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set restoreFocus(val) {
    this._restoreFocus = coerceBooleanProperty$1(val);
  }
  /**
   * How the popover should handle scrolling. *Defaults to `"reposition"`.*
   * @return {?}
   */
  get scrollStrategy() {
    return this._scrollStrategy;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set scrollStrategy(val) {
    this._validateScrollStrategy(val);
    if (this._scrollStrategy !== val) {
      this._scrollStrategy = val;
      this._dispatchConfigNotification(
        new PopoverNotification(NotificationAction.UPDATE_CONFIG)
      );
    }
  }
  /**
   * Whether the popover should have a backdrop (includes closing on click). *Defaults to `true`.*
   * @return {?}
   */
  get hasBackdrop() {
    return this._hasBackdrop;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set hasBackdrop(val) {
    this._hasBackdrop = coerceBooleanProperty$1(val);
    this._dispatchConfigNotification(
      new PopoverNotification(NotificationAction.UPDATE_CONFIG)
    );
  }
  /**
   * Whether the popover should close when the user clicks the backdrop or presses ESC. *Defaults to `true`.*
   * @return {?}
   */
  get interactiveClose() {
    return this._interactiveClose;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set interactiveClose(val) {
    this._interactiveClose = coerceBooleanProperty$1(val);
    this._dispatchConfigNotification(
      new PopoverNotification(NotificationAction.UPDATE_CONFIG)
    );
  }
  /**
   * Custom transition to use while opening. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
   * @return {?}
   */
  get openTransition() {
    return this._openTransition;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set openTransition(val) {
    if (val) {
      this._openTransition = val;
    }
  }
  /**
   * Custom transition to use while closing. *Defaults to `'200ms cubic-bezier(0.25, 0.8, 0.25, 1)'`.*
   * @return {?}
   */
  get closeTransition() {
    return this._closeTransition;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set closeTransition(val) {
    if (val) {
      this._closeTransition = val;
    }
  }
  /**
   * A link to an associated parent menu that will be closed when this menu closes.
   * @return {?}
   */
  get parent() {
    return this._parentMenu;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set parent(val) {
    if (this._parentMenu) {
      this._parentClose.unsubscribe();
    }
    this._parentMenu = val;
    if (this._parentMenu) {
      this._parentClose = this._parentMenu.closed.subscribe(
        /**
         * @param {?} value
         * @return {?}
         */
        (value) => {
          if (this.isOpen()) {
            this.close();
          }
        }
      );
    }
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this._setAlignmentClasses();
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    if (this._notifications) {
      this._notifications.dispose();
    }
    if (this._parentMenu) {
      this._parentClose.unsubscribe();
    }
  }
  /**
   * @return {?}
   */
  _popContainerClicked() {
    if (this.autoCloseOnContentClick) {
      this.close();
    }
  }
  /**
   * Open this popover.
   * @param {?=} options
   * @return {?}
   */
  open(options = {}) {
    /** @type {?} */
    const notification = new PopoverNotification(
      NotificationAction.OPEN,
      options
    );
    this._dispatchActionNotification(notification);
  }
  /**
   * Close this popover and its parent (if linked).
   * @param {?=} value
   * @return {?}
   */
  close(value) {
    /** @type {?} */
    const notification = new PopoverNotification(
      NotificationAction.CLOSE,
      value
    );
    this._dispatchActionNotification(notification);
    if (this.parent && !this._parentCloseBlock) {
      this.parent.close();
    }
  }
  /**
   * Toggle this popover open or closed.
   * @return {?}
   */
  toggle() {
    if (this.parent) {
      this.parent._subMenuOpen = !this.isOpen();
    }
    /** @type {?} */
    const notification = new PopoverNotification(NotificationAction.TOGGLE);
    this._dispatchActionNotification(notification);
  }
  /**
   * Realign the popover to the anchor.
   * @return {?}
   */
  realign() {
    /** @type {?} */
    const notification = new PopoverNotification(NotificationAction.REALIGN);
    this._dispatchActionNotification(notification);
  }
  /**
   * Gets whether the popover is presently open.
   * @return {?}
   */
  isOpen() {
    return this._open;
  }
  /**
   * Gets an animation config with customized (or default) transition values.
   * @return {?}
   */
  _getAnimation() {
    return {
      value: "visible",
      params: {
        openTransition: this.shouldAnimate
          ? this.openTransition
          : EMPTY_TRANSITION,
        closeTransition: this.shouldAnimate
          ? this.closeTransition
          : EMPTY_TRANSITION,
      },
    };
  }
  /**
   * Callback for when the popover is finished animating in or out.
   * @param {?} event
   * @return {?}
   */
  _onAnimationDone(event) {
    if (event.toState === "visible") {
      this._trapFocus();
      this.afterOpen.emit();
    } else if (event.toState === "void") {
      this._restoreFocusAndDestroyTrap();
      this.afterClose.emit();
    }
  }
  /**
   * Apply alignment classes based on alignment inputs.
   * @param {?=} horizAlign
   * @param {?=} vertAlign
   * @return {?}
   */
  _setAlignmentClasses(
    horizAlign = this.horizontalAlign,
    vertAlign = this.verticalAlign
  ) {
    this._setAlignmentClassesForAnimation(horizAlign, vertAlign);
    this._setAlignmentClassesForArrow();
  }
  /**
   * @param {?=} horizAlign
   * @param {?=} vertAlign
   * @return {?}
   */
  _setAlignmentClassesForAnimation(
    horizAlign = this.horizontalAlign,
    vertAlign = this.verticalAlign
  ) {
    this._classList["hc-pop-before"] =
      horizAlign === "before" || horizAlign === "end";
    this._classList["hc-pop-after"] =
      horizAlign === "after" || horizAlign === "start";
    this._classList["hc-pop-above"] =
      vertAlign === "above" || vertAlign === "end";
    this._classList["hc-pop-below"] =
      vertAlign === "below" || vertAlign === "start";
    this._classList["hc-pop-center"] =
      horizAlign === "center" || vertAlign === "center";
  }
  /**
   * @param {?=} xAlign
   * @param {?=} yAlign
   * @return {?}
   */
  _setAlignmentClassesForArrow(
    xAlign = this.horizontalAlign,
    yAlign = this.verticalAlign
  ) {
    this._classList["hc-pop-show-arrow"] =
      (this.showArrow &&
        (xAlign === "start" || xAlign === "center" || xAlign === "end") &&
        (yAlign === "above" || yAlign === "below")) ||
      ((yAlign === "start" || yAlign === "center" || yAlign === "end") &&
        (xAlign === "before" || xAlign === "after"));
    this._yAlignClass = this._classList["hc-pop-show-arrow"]
      ? `hc-pop-arrow-y-${yAlign}`
      : "";
    this._xAlignClass = this._classList["hc-pop-show-arrow"]
      ? `hc-pop-arrow-x-${xAlign}`
      : "";
  }
  /**
   * Set the focus of an hcMenu based on a keyboard arrow press
   * @param {?} downPress
   * @return {?}
   */
  _keyFocus(downPress) {
    /** @type {?} */
    let itemArray = this._menuItems.toArray();
    if (!downPress) {
      itemArray.reverse();
    }
    /** @type {?} */
    let selected = false;
    // Determine if any item in the menu is currently focused, and select the next (or previous)
    for (let i = 0; i < itemArray.length; i++) {
      if (
        selected &&
        !itemArray[i].ref.nativeElement.classList.contains("hc-divider") &&
        !itemArray[i].ref.nativeElement.disabled
      ) {
        itemArray[i].focus();
        return;
      }
      if (itemArray[i].ref.nativeElement === document.activeElement) {
        selected = true;
      }
    }
    // If no item is focused, selected the first (or last) item that isn't a divider or disabled
    for (let i = 0; i < itemArray.length; i++) {
      if (
        !itemArray[i].ref.nativeElement.classList.contains("hc-divider") &&
        !itemArray[i].ref.nativeElement.disabled
      ) {
        itemArray[i].focus();
        return;
      }
    }
  }
  /**
   * Restore focus to the element focused before the popover opened. Also destroy trap.
   * @return {?}
   */
  _restoreFocusAndDestroyTrap() {
    /** @type {?} */
    const toFocus = this._previouslyFocusedElement;
    // Must check active element is focusable for IE sake
    if (
      toFocus &&
      "focus" in toFocus &&
      this.restoreFocus &&
      this._previouslyFocusedElement
    ) {
      this._previouslyFocusedElement.focus();
    }
    this._previouslyFocusedElement = null;
    if (this._focusTrap) {
      this._focusTrap.destroy();
      this._focusTrap = undefined;
    }
  }
  /**
   * Save a reference to the element focused before the popover was opened.
   * @return {?}
   */
  _savePreviouslyFocusedElement() {
    if (this._document) {
      this._previouslyFocusedElement = /** @type {?} */ (this._document
        .activeElement);
    }
  }
  /**
   * Move the focus inside the focus trap and remember where to return later.
   * @private
   * @return {?}
   */
  _trapFocus() {
    // There won't be a focus trap element if the close animation starts before open finishes
    if (!this._focusTrapElement) {
      return;
    }
    if (!this._focusTrap && this._focusTrapElement) {
      this._focusTrap = this._focusTrapFactory.create(
        this._focusTrapElement.nativeElement
      );
    }
    if (this.autoFocus && this._focusTrap) {
      this._focusTrap.focusInitialElementWhenReady();
    }
  }
  /**
   * Dispatch a notification to the notification service, if possible.
   * @private
   * @param {?} notification
   * @return {?}
   */
  _dispatchConfigNotification(notification) {
    if (this._notifications) {
      this._notifications.dispatch(notification);
    }
  }
  /**
   * Dispatch a notification to the notification service and throw if unable to.
   * @private
   * @param {?} notification
   * @return {?}
   */
  _dispatchActionNotification(notification) {
    if (!this._notifications) {
      throw getUnanchoredPopoverError();
    }
    this._notifications.dispatch(notification);
  }
  /**
   * Throws an error if the alignment is not a valid horizontalAlign.
   * @private
   * @param {?} pos
   * @return {?}
   */
  _validateHorizontalAlign(pos) {
    if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
      throw getInvalidHorizontalAlignError(pos);
    }
  }
  /**
   * Throws an error if the alignment is not a valid verticalAlign.
   * @private
   * @param {?} pos
   * @return {?}
   */
  _validateVerticalAlign(pos) {
    if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
      throw getInvalidVerticalAlignError(pos);
    }
  }
  /**
   * Throws an error if the scroll strategy is not a valid strategy.
   * @private
   * @param {?} strategy
   * @return {?}
   */
  _validateScrollStrategy(strategy) {
    if (VALID_SCROLL.indexOf(strategy) === -1) {
      throw getInvalidScrollStrategyError(strategy);
    }
  }
}
HcPopComponent.ɵfac = function HcPopComponent_Factory(t) {
  return new (t || HcPopComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory),
    ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)
  );
};
HcPopComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcPopComponent,
  selectors: [["hc-pop"]],
  contentQueries: function HcPopComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._menuItems = _t);
    }
  },
  viewQuery: function HcPopComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(TemplateRef, true);
      ɵngcc0.ɵɵviewQuery(_c6, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._templateRef = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._focusTrapElement = _t.first);
    }
  },
  inputs: {
    disableStyle: "disableStyle",
    showArrow: "showArrow",
    shouldAnimate: "shouldAnimate",
    backdropClass: "backdropClass",
    autoCloseOnContentClick: "autoCloseOnContentClick",
    horizontalAlign: "horizontalAlign",
    xAlign: "xAlign",
    verticalAlign: "verticalAlign",
    yAlign: "yAlign",
    forceAlignment: "forceAlignment",
    lockAlignment: "lockAlignment",
    autoFocus: "autoFocus",
    restoreFocus: "restoreFocus",
    scrollStrategy: "scrollStrategy",
    hasBackdrop: "hasBackdrop",
    interactiveClose: "interactiveClose",
    openTransition: "openTransition",
    closeTransition: "closeTransition",
    parent: "parent",
  },
  outputs: {
    opened: "opened",
    closed: "closed",
    afterOpen: "afterOpen",
    afterClose: "afterClose",
    backdropClicked: "backdropClicked",
    overlayKeydown: "overlayKeydown",
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  consts: [
    [1, "hc-pop-container", 3, "ngClass", "click"],
    ["focusTrapElement", ""],
    [3, "class", 4, "ngIf"],
  ],
  template: function HcPopComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(
        0,
        HcPopComponent_ng_template_0_Template,
        4,
        9,
        "ng-template"
      );
    }
  },
  directives: [ɵngcc1.NgClass, ɵngcc1.NgIf],
  styles: [_c7],
  encapsulation: 2,
  data: { animation: [transformPopover] },
});
/** @nocollapse */
HcPopComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: FocusTrapFactory },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT] }],
  },
];
HcPopComponent.propDecorators = {
  disableStyle: [{ type: Input }],
  showArrow: [{ type: Input }],
  horizontalAlign: [{ type: Input }],
  xAlign: [{ type: Input }],
  verticalAlign: [{ type: Input }],
  yAlign: [{ type: Input }],
  forceAlignment: [{ type: Input }],
  lockAlignment: [{ type: Input }],
  autoFocus: [{ type: Input }],
  restoreFocus: [{ type: Input }],
  scrollStrategy: [{ type: Input }],
  hasBackdrop: [{ type: Input }],
  interactiveClose: [{ type: Input }],
  openTransition: [{ type: Input }],
  closeTransition: [{ type: Input }],
  parent: [{ type: Input }],
  shouldAnimate: [{ type: Input }],
  backdropClass: [{ type: Input }],
  autoCloseOnContentClick: [{ type: Input }],
  opened: [{ type: Output }],
  closed: [{ type: Output }],
  afterOpen: [{ type: Output }],
  afterClose: [{ type: Output }],
  backdropClicked: [{ type: Output }],
  overlayKeydown: [{ type: Output }],
  _templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false }] }],
  _focusTrapElement: [
    { type: ViewChild, args: ["focusTrapElement", { static: false }] },
  ],
  _menuItems: [
    { type: ContentChildren, args: [MenuItemDirective, { descendants: true }] },
  ],
};
if (false) {
  /**
   * Whether or not to disable default popover container styles. *Defaults to `false`.*
   * @type {?}
   */
  HcPopComponent.prototype.disableStyle;
  /**
   * Whether or not to show a connection arrow when possible. *Defaults to `true`.*
   * @type {?}
   */
  HcPopComponent.prototype.showArrow;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._horizontalAlign;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._verticalAlign;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._forceAlignment;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._lockAlignment;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._autoFocus;
  /** @type {?} */
  HcPopComponent.prototype._autoFocusOverride;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._restoreFocus;
  /** @type {?} */
  HcPopComponent.prototype._restoreFocusOverride;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._scrollStrategy;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._hasBackdrop;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._interactiveClose;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._openTransition;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._closeTransition;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._parentMenu;
  /**
   * Should the popover animate? *Defaults to `true`.*
   * @type {?}
   */
  HcPopComponent.prototype.shouldAnimate;
  /**
   * Optional backdrop class. *Defaults to `''`.*
   * @type {?}
   */
  HcPopComponent.prototype.backdropClass;
  /**
   * Set to true if clicking anywhere inside the popover should close it. *Defaults to `false`.*
   * @type {?}
   */
  HcPopComponent.prototype.autoCloseOnContentClick;
  /**
   * Emits when the popover is opened. If `context` was set on the anchor, it will be emitted with this event.
   * @type {?}
   */
  HcPopComponent.prototype.opened;
  /**
   * Emits when the popover is closed.
   * @type {?}
   */
  HcPopComponent.prototype.closed;
  /**
   * Emits when the popover has finished opening.
   * @type {?}
   */
  HcPopComponent.prototype.afterOpen;
  /**
   * Emits when the popover has finished closing.
   * @type {?}
   */
  HcPopComponent.prototype.afterClose;
  /**
   * Emits when the backdrop is clicked.
   * @type {?}
   */
  HcPopComponent.prototype.backdropClicked;
  /**
   * Emits when a keydown event is targeted to this popover's overlay.
   * @type {?}
   */
  HcPopComponent.prototype.overlayKeydown;
  /**
   * Reference to template so it can be placed within a portal.
   * @type {?}
   */
  HcPopComponent.prototype._templateRef;
  /**
   * Stores the click coordinates for mouse-based positioning
   * @type {?}
   */
  HcPopComponent.prototype._offsetPos;
  /**
   * Stores a reference to the associated overlay
   * @type {?}
   */
  HcPopComponent.prototype._componentOverlay;
  /**
   * Classes to be added to the popover for setting the correct transform origin.
   * @type {?}
   */
  HcPopComponent.prototype._classList;
  /** @type {?} */
  HcPopComponent.prototype._yAlignClass;
  /** @type {?} */
  HcPopComponent.prototype._xAlignClass;
  /**
   * Whether the popover is presently open.
   * @type {?}
   */
  HcPopComponent.prototype._open;
  /**
   * Instance of notification service. Will be undefined until attached to an anchor.
   * @type {?}
   */
  HcPopComponent.prototype._notifications;
  /**
   * Reference to the element to build a focus trap around.
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._focusTrapElement;
  /**
   * Reference to the element that was focused before opening.
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._previouslyFocusedElement;
  /**
   * Reference to a focus trap around the popover.
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._focusTrap;
  /**
   * If this menu has children, keep track of whether any of them are open
   * @type {?}
   */
  HcPopComponent.prototype._subMenuOpen;
  /**
   * Reference to subscription of parent popover close events
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._parentClose;
  /**
   * Block this popover from closing its parent on close
   * @type {?}
   */
  HcPopComponent.prototype._parentCloseBlock;
  /**
   * Reference to hcMenuItems (if the popover contains them)
   * @type {?}
   */
  HcPopComponent.prototype._menuItems;
  /** @type {?} */
  HcPopComponent.prototype._elementRef;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._focusTrapFactory;
  /**
   * @type {?}
   * @private
   */
  HcPopComponent.prototype._document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/tooltip/tooltip.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Displays additional information on hover above the element after a specified delay
 */
class HcTooltipComponent extends HcPopComponent {
  constructor() {
    super(...arguments);
    /**
     * The content to be display in the tooltip
     */
    this.tooltipContent = "";
  }
}
HcTooltipComponent.ɵfac = function HcTooltipComponent_Factory(t) {
  return ɵHcTooltipComponent_BaseFactory(t || HcTooltipComponent);
};
HcTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcTooltipComponent,
  selectors: [["hc-tooltip"]],
  inputs: { tooltipContent: "tooltipContent" },
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [
    ["_templateRef", ""],
    [1, "hc-pop-container", ",", "hc-tooltip-container", 3, "ngClass"],
    [1, "hc-tooltip"],
    [
      "class",
      "hc-pop-arrow hc-pop-arrow-y-above hc-pop-arrow-x-center",
      4,
      "ngIf",
    ],
    [1, "hc-pop-arrow", "hc-pop-arrow-y-above", "hc-pop-arrow-x-center"],
  ],
  template: function HcTooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵtemplate(
        0,
        HcTooltipComponent_ng_template_0_Template,
        4,
        10,
        "ng-template",
        null,
        0,
        ɵngcc0.ɵɵtemplateRefExtractor
      );
    }
  },
  directives: [ɵngcc1.NgClass, ɵngcc1.NgIf],
  styles: [
    _c7,
    ".hc-pop-container .hc-tooltip{background-color:#333;border-radius:4px;padding:7px;margin:-1px;color:#fff}.hc-pop-container .hc-tooltip+.hc-pop-arrow{background-color:#333!important;border-color:transparent!important}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-tooltip-container{top:-10px;line-height:14px}.hc-tooltip-container .hc-tooltip{margin-right:0;margin-left:0}.hc-tooltip-container .hc-pop-arrow{bottom:-14px}",
  ],
  encapsulation: 2,
  data: { animation: [transformPopover] },
});
HcTooltipComponent.propDecorators = {
  tooltipContent: [{ type: Input }],
};
if (false) {
  /**
   * The content to be display in the tooltip
   * @type {?}
   */
  HcTooltipComponent.prototype.tooltipContent;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover-anchoring.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration provided by the popover for the anchoring service
 * to build the correct overlay config.
 * @record
 */
function PopoverConfig() {}
if (false) {
  /** @type {?} */
  PopoverConfig.prototype.horizontalAlign;
  /** @type {?} */
  PopoverConfig.prototype.verticalAlign;
  /** @type {?} */
  PopoverConfig.prototype.hasBackdrop;
  /** @type {?} */
  PopoverConfig.prototype.backdropClass;
  /** @type {?} */
  PopoverConfig.prototype.scrollStrategy;
  /** @type {?} */
  PopoverConfig.prototype.forceAlignment;
  /** @type {?} */
  PopoverConfig.prototype.lockAlignment;
}
class HcPopoverAnchoringService {
  /**
   * @param {?} _overlay
   * @param {?} _ngZone
   * @param {?} _dir
   */
  constructor(_overlay, _ngZone, _dir) {
    this._overlay = _overlay;
    this._ngZone = _ngZone;
    this._dir = _dir;
    /**
     * Emits when the popover is opened.
     */
    this.popoverOpened = new Subject();
    /**
     * Emits when the popover is closed.
     */
    this.popoverClosed = new Subject();
    /**
     * Whether the popover is presently open.
     */
    this._popoverOpen = false;
    /**
     * Emits when the service is destroyed.
     */
    this._onDestroy = new Subject();
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    // Destroy popover before terminating subscriptions so that any resulting
    // detachments update 'closed state'
    this._destroyPopover();
    // Terminate subscriptions
    if (this._notificationsSubscription) {
      this._notificationsSubscription.unsubscribe();
    }
    if (this._positionChangeSubscription) {
      this._positionChangeSubscription.unsubscribe();
    }
    this._onDestroy.next();
    this._onDestroy.complete();
    this.popoverOpened.complete();
    this.popoverClosed.complete();
  }
  /**
   * Anchor a popover instance to a view and connection element.
   * @param {?} popover
   * @param {?} viewContainerRef
   * @param {?} anchor
   * @return {?}
   */
  anchor(popover, viewContainerRef, anchor) {
    // Destroy any previous popovers
    this._destroyPopover();
    // Assign local refs
    this._popover = popover;
    this._viewContainerRef = viewContainerRef;
    this._anchor = anchor;
    // Provide notification service as a communication channel between popover and anchor.
    // Then subscribe to notifications to take appropriate actions.
    this._popover._notifications = this._notifications = this._anchor._notifications = new PopoverNotificationService();
    this._subscribeToNotifications();
  }
  /**
   * Gets whether the popover is presently open.
   * @return {?}
   */
  isPopoverOpen() {
    return this._popoverOpen;
  }
  /**
   * Toggles the popover between the open and closed states.
   * @return {?}
   */
  togglePopover() {
    return this._popoverOpen ? this.closePopover() : this.openPopover();
  }
  /**
   * Opens the popover.
   * @param {?=} options
   * @return {?}
   */
  openPopover(options = {}) {
    if (!this._popoverOpen) {
      this._applyOpenOptions(options);
      this._popover._componentOverlay = this._createOverlay();
      this._subscribeToBackdrop();
      this._subscribeToEscape();
      this._subscribeToDetachments();
      this._saveOpenedState();
      this._popover._savePreviouslyFocusedElement();
    }
  }
  /**
   * Closes the popover.
   * @param {?=} value
   * @param {?=} neighborSubMenusAreOpen
   * @return {?}
   */
  closePopover(value, neighborSubMenusAreOpen = false) {
    if (this._popover._componentOverlay) {
      this._saveClosedState(value, neighborSubMenusAreOpen);
      this._popover._componentOverlay.detach();
      this._popover._restoreFocusAndDestroyTrap();
    }
  }
  /**
   * Realign the popover to the anchor.
   * @return {?}
   */
  realignPopoverToAnchor() {
    if (this._popover._componentOverlay) {
      /** @type {?} */
      const config = this._popover._componentOverlay.getConfig();
      /** @type {?} */
      const strategy = /** @type {?} */ (config.positionStrategy);
      strategy.reapplyLastPosition();
    }
  }
  /**
   * Get a reference to the anchor element.
   * @return {?}
   */
  getAnchorElement() {
    return this._anchor._elementRef;
  }
  /**
   * Apply behavior properties on the popover based on the open options.
   * @private
   * @param {?} options
   * @return {?}
   */
  _applyOpenOptions(options) {
    // Only override restoreFocus as `false` if the option is explicitly `false`
    /** @type {?} */
    const restoreFocus = options.restoreFocus !== false;
    this._popover._restoreFocusOverride = restoreFocus;
    // Only override autoFocus as `false` if the option is explicitly `false`
    /** @type {?} */
    const autoFocus = options.autoFocus !== false;
    this._popover._autoFocusOverride = autoFocus;
  }
  /**
   * Create an overlay to be attached to the portal.
   * @private
   * @return {?}
   */
  _createOverlay() {
    // Create overlay if it doesn't yet exist
    if (!this._overlayRef) {
      this._portal = new TemplatePortal(
        this._popover._templateRef,
        this._viewContainerRef
      );
      /** @type {?} */
      const popoverConfig = {
        horizontalAlign: this._popover.horizontalAlign,
        verticalAlign: this._popover.verticalAlign,
        hasBackdrop: this._popover.hasBackdrop,
        backdropClass: this._popover.backdropClass,
        scrollStrategy: this._popover.scrollStrategy,
        forceAlignment: this._popover.forceAlignment,
        lockAlignment: this._popover.lockAlignment,
      };
      /** @type {?} */
      const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
      this._subscribeToPositionChanges(
        /** @type {?} */ (overlayConfig.positionStrategy)
      );
      this._overlayRef = this._overlay.create(overlayConfig);
    } else if (
      this._popover.horizontalAlign === "mouse" ||
      this._popover.verticalAlign === "mouse"
    ) {
      /* If aligning to mouse clicks - adjust the strategy based on the most current click */
      this._overlayRef.updatePositionStrategy(
        this._getPositionStrategy(
          this._popover.horizontalAlign,
          this._popover.verticalAlign,
          this._popover.forceAlignment,
          this._popover.lockAlignment,
          this._anchor._elementRef
        )
      );
    }
    // Actually open the popover
    this._overlayRef.attach(this._portal);
    return this._overlayRef;
  }
  /**
   * Removes the popover from the DOM. Does NOT update open state.
   * @private
   * @return {?}
   */
  _destroyPopover() {
    if (this._overlayRef) {
      this._overlayRef.dispose();
      this._overlayRef = null;
    }
  }
  /**
   * Destroys the popover immediately if it is closed, or waits until it
   * has been closed to destroy it.
   * @private
   * @return {?}
   */
  _destroyPopoverOnceClosed() {
    if (this.isPopoverOpen() && this._overlayRef) {
      this._overlayRef
        .detachments()
        .pipe(take(1), takeUntil(this._onDestroy))
        .subscribe(
          /**
           * @return {?}
           */
          () => this._destroyPopover()
        );
    } else {
      this._destroyPopover();
    }
  }
  /**
   * Call appropriate anchor method when an event is dispatched through
   * the notification service.
   * @private
   * @return {?}
   */
  _subscribeToNotifications() {
    if (this._notificationsSubscription) {
      this._notificationsSubscription.unsubscribe();
    }
    this._notificationsSubscription = this._notifications.events().subscribe(
      /**
       * @param {?} event
       * @return {?}
       */
      (event) => {
        switch (event.action) {
          case NotificationAction.OPEN:
            this.openPopover(event.value);
            break;
          case NotificationAction.CLOSE:
            this.closePopover(event.value);
            break;
          case NotificationAction.TOGGLE:
            this.togglePopover();
            break;
          case NotificationAction.REPOSITION:
          // TODO: When the overlay's position can be dynamically changed, do not destroy
          case NotificationAction.UPDATE_CONFIG:
            this._destroyPopoverOnceClosed();
            break;
          case NotificationAction.REALIGN:
            this.realignPopoverToAnchor();
            break;
        }
      }
    );
  }
  /**
   * Close popover when backdrop is clicked.
   * @private
   * @return {?}
   */
  _subscribeToBackdrop() {
    if (!this._overlayRef) {
      return;
    }
    this._overlayRef
      .backdropClick()
      .pipe(
        tap(
          /**
           * @return {?}
           */
          () => this._popover.backdropClicked.emit()
        ),
        filter(
          /**
           * @return {?}
           */
          () => this._popover.interactiveClose
        ),
        takeUntil(this.popoverClosed),
        takeUntil(this._onDestroy)
      )
      .subscribe(
        /**
         * @return {?}
         */
        () => this.closePopover()
      );
  }
  /**
   * Close popover when escape keydown event occurs.
   * @private
   * @return {?}
   */
  _subscribeToEscape() {
    if (!this._overlayRef) {
      return;
    }
    this._overlayRef
      .keydownEvents()
      .pipe(
        tap(
          /**
           * @param {?} event
           * @return {?}
           */
          (event) => this._popover.overlayKeydown.emit(event)
        ),
        filter(
          /**
           * @param {?} event
           * @return {?}
           */
          (event) => event.keyCode === ESCAPE
        ),
        filter(
          /**
           * @return {?}
           */
          () => this._popover.interactiveClose
        ),
        takeUntil(this.popoverClosed),
        takeUntil(this._onDestroy)
      )
      .subscribe(
        /**
         * @return {?}
         */
        () => this.closePopover()
      );
  }
  /**
   * Set state back to closed when detached.
   * @private
   * @return {?}
   */
  _subscribeToDetachments() {
    if (!this._overlayRef) {
      return;
    }
    this._overlayRef
      .detachments()
      .pipe(takeUntil(this._onDestroy))
      .subscribe(
        /**
         * @return {?}
         */
        () => this._saveClosedState()
      );
  }
  /**
   * Save the opened state of the popover and emit.
   * @private
   * @return {?}
   */
  _saveOpenedState() {
    if (!this._popoverOpen) {
      this._popover._open = this._popoverOpen = true;
      if (this._popover.parent) {
        this._popover.parent._subMenuOpen = true;
      }
      this.popoverOpened.next();
      if (typeof this._context === "undefined") {
        this._popover.opened.emit();
      } else {
        this._popover.opened.emit(this._context);
      }
    }
  }
  /**
   * Save the closed state of the popover and emit.
   * @private
   * @param {?=} value
   * @param {?=} neighborSubMenusAreOpen
   * @return {?}
   */
  _saveClosedState(value, neighborSubMenusAreOpen = false) {
    if (this._popoverOpen) {
      this._popover._open = this._popoverOpen = false;
      if (this._popover.parent) {
        this._popover.parent._subMenuOpen = neighborSubMenusAreOpen;
      }
      this.popoverClosed.next(value);
      this._popover.closed.emit(value);
    }
  }
  /**
   * Gets the text direction of the containing app.
   * @private
   * @return {?}
   */
  _getDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /**
   * Create and return a config for creating the overlay.
   * @private
   * @param {?} config
   * @param {?} anchor
   * @return {?}
   */
  _getOverlayConfig(config, anchor) {
    return new OverlayConfig({
      positionStrategy: this._getPositionStrategy(
        config.horizontalAlign,
        config.verticalAlign,
        config.forceAlignment,
        config.lockAlignment,
        anchor._elementRef
      ),
      // make it hard for users to shoot themselves in the foot by disabling backdrop if hover is the trigger
      hasBackdrop: anchor.trigger !== "hover" ? config.hasBackdrop : false,
      backdropClass: config.backdropClass || "cdk-overlay-transparent-backdrop",
      scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
      direction: this._getDirection(),
      // disable pointer events for hover popovers to avoid potential flickering issues
      panelClass: anchor.trigger === "hover" ? "overlay-pointer-events" : "",
    });
  }
  /**
   * Listen to changes in the position of the overlay and set the correct alignment classes,
   * ensuring that the animation origin is correct, even with a fallback position.
   * @private
   * @param {?} position
   * @return {?}
   */
  _subscribeToPositionChanges(position) {
    if (this._positionChangeSubscription) {
      this._positionChangeSubscription.unsubscribe();
    }
    this._positionChangeSubscription = position.positionChanges
      .pipe(takeUntil(this._onDestroy))
      .subscribe(
        /**
         * @param {?} change
         * @return {?}
         */
        (change) => {
          // Position changes may occur outside the Angular zone
          this._ngZone.run(
            /**
             * @return {?}
             */
            () => {
              this._popover._setAlignmentClassesForAnimation(
                getHorizontalPopoverAlignment(change.connectionPair.overlayX),
                getVerticalPopoverAlignment(change.connectionPair.overlayY)
              );
              this._popover._setAlignmentClassesForArrow(
                getHPopAlignmentForArrow(
                  change.connectionPair.overlayX,
                  change.connectionPair.originX
                ),
                getVPopAlignmentForArrow(
                  change.connectionPair.overlayY,
                  change.connectionPair.originY
                )
              );
            }
          );
        }
      );
  }
  /**
   * Map a scroll strategy string type to an instance of a scroll strategy.
   * @private
   * @param {?} strategy
   * @return {?}
   */
  _getScrollStrategyInstance(strategy) {
    switch (strategy) {
      case "block":
        return this._overlay.scrollStrategies.block();
      case "reposition":
        return this._overlay.scrollStrategies.reposition();
      case "close":
        return this._overlay.scrollStrategies.close();
      case "noop":
      default:
        return this._overlay.scrollStrategies.noop();
    }
  }
  /**
   * Create and return a position strategy based on config provided to the component instance.
   * @private
   * @param {?} horizontalTarget
   * @param {?} verticalTarget
   * @param {?} forceAlignment
   * @param {?} lockAlignment
   * @param {?} anchor
   * @return {?}
   */
  _getPositionStrategy(
    horizontalTarget,
    verticalTarget,
    forceAlignment,
    lockAlignment,
    anchor
  ) {
    // Attach the overlay at the preferred position
    /** @type {?} */
    const targetPosition = getPosition(
      horizontalTarget,
      verticalTarget,
      this._popover._offsetPos
    );
    /** @type {?} */
    const positions = [targetPosition];
    /** @type {?} */
    const strategy = this._overlay
      .position()
      .flexibleConnectedTo(anchor)
      .withFlexibleDimensions(false)
      .withPush(false)
      .withViewportMargin(0)
      .withLockedPosition(lockAlignment);
    // Unless the alignment is forced, add fallbacks based on the preferred positions
    if (!forceAlignment) {
      /** @type {?} */
      const fallbacks = this._getFallbacks(horizontalTarget, verticalTarget);
      positions.push(...fallbacks);
    }
    return strategy.withPositions(positions);
  }
  /**
   * Get fallback positions based around target alignments.
   * @private
   * @param {?} hTarget
   * @param {?} vTarget
   * @return {?}
   */
  _getFallbacks(hTarget, vTarget) {
    // Determine if the target alignments overlap the anchor
    /** @type {?} */
    const horizontalOverlapAllowed =
      hTarget !== "before" && hTarget !== "after";
    /** @type {?} */
    const verticalOverlapAllowed = vTarget !== "above" && vTarget !== "below";
    // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
    // cover the anchor
    /** @type {?} */
    const possibleHorizontalAlignments = horizontalOverlapAllowed
      ? ["before", "start", "center", "end", "after", "mouse"]
      : ["before", "after"];
    /** @type {?} */
    const possibleVerticalAlignments = verticalOverlapAllowed
      ? ["above", "start", "center", "end", "below", "mouse"]
      : ["above", "below"];
    // Create fallbacks for each allowed prioritized fallback alignment combo
    /** @type {?} */
    const fallbacks = [];
    prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(
      /**
       * @param {?} h
       * @return {?}
       */
      (h) => {
        prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(
          /**
           * @param {?} v
           * @return {?}
           */
          (v) => {
            fallbacks.push(getPosition(h, v, this._popover._offsetPos));
          }
        );
      }
    );
    // Remove the first item since it will be the target alignment and isn't considered a fallback
    return fallbacks.slice(1, fallbacks.length);
  }
}
HcPopoverAnchoringService.ɵfac = function HcPopoverAnchoringService_Factory(t) {
  return new (t || HcPopoverAnchoringService)(
    ɵngcc0.ɵɵinject(ɵngcc3.Overlay),
    ɵngcc0.ɵɵinject(ɵngcc0.NgZone),
    ɵngcc0.ɵɵinject(ɵngcc4.Directionality, 8)
  );
};
HcPopoverAnchoringService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: HcPopoverAnchoringService,
  factory: HcPopoverAnchoringService.ɵfac,
});
/** @nocollapse */
HcPopoverAnchoringService.ctorParameters = () => [
  { type: Overlay },
  { type: NgZone },
  { type: Directionality, decorators: [{ type: Optional }] },
];
if (false) {
  /**
   * Emits when the popover is opened.
   * @type {?}
   */
  HcPopoverAnchoringService.prototype.popoverOpened;
  /**
   * Emits when the popover is closed.
   * @type {?}
   */
  HcPopoverAnchoringService.prototype.popoverClosed;
  /**
   * Reference to the overlay containing the popover component.
   * @type {?}
   */
  HcPopoverAnchoringService.prototype._overlayRef;
  /**
   * Reference to the target popover.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._popover;
  /**
   * Stores the context assigned to the popover
   * @type {?}
   */
  HcPopoverAnchoringService.prototype._context;
  /**
   * Reference to the view container for the popover template.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._viewContainerRef;
  /**
   * Reference to the anchor
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._anchor;
  /**
   * Reference to a template portal where the overlay will be attached.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._portal;
  /**
   * Communications channel with the popover.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._notifications;
  /**
   * Single subscription to notifications service events.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._notificationsSubscription;
  /**
   * Single subscription to position changes.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._positionChangeSubscription;
  /**
   * Whether the popover is presently open.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._popoverOpen;
  /**
   * Emits when the service is destroyed.
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._onDestroy;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._overlay;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._ngZone;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchoringService.prototype._dir;
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning
 * @param {?} hOverlay
 * @param {?} hOrigin
 * @return {?}
 */
function getHPopAlignmentForArrow(hOverlay, hOrigin) {
  if (hOverlay === hOrigin) {
    return hOverlay;
  }
  if (hOverlay === "start") {
    return "after";
  }
  if (hOverlay === "end") {
    return "before";
  }
  return "center";
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment for arrow positioning.
 * @param {?} vOverlay
 * @param {?} vOrigin
 * @return {?}
 */
function getVPopAlignmentForArrow(vOverlay, vOrigin) {
  if (vOverlay === vOrigin && (vOverlay === "top" || vOverlay === "bottom")) {
    return vOverlay === "top" ? "start" : "end";
  }
  if (vOverlay === "top") {
    return "below";
  }
  if (vOverlay === "bottom") {
    return "above";
  }
  return "center";
}
/**
 * Helper function to get a cdk position pair from HcPopover alignments.
 * @param {?} h
 * @param {?} v
 * @param {?} offset
 * @return {?}
 */
function getPosition(h, v, offset) {
  const { originX, overlayX } = getHorizontalConnectionPosPair(h);
  const { originY, overlayY } = getVerticalConnectionPosPair(v);
  return new ConnectionPositionPair(
    { originX, originY },
    { overlayX, overlayY },
    offset[0],
    offset[1]
  );
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
  if (h === "start") {
    return "after";
  }
  if (h === "end") {
    return "before";
  }
  return "center";
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
  if (v === "top") {
    return "below";
  }
  if (v === "bottom") {
    return "above";
  }
  return "center";
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
  switch (h) {
    case "before":
      return { originX: "start", overlayX: "end" };
    case "start":
    case "mouse":
      return { originX: "start", overlayX: "start" };
    case "end":
      return { originX: "end", overlayX: "end" };
    case "after":
      return { originX: "end", overlayX: "start" };
    default:
      return { originX: "center", overlayX: "center" };
  }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
  switch (v) {
    case "above":
      return { originY: "top", overlayY: "bottom" };
    case "start":
    case "mouse":
      return { originY: "top", overlayY: "top" };
    case "end":
      return { originY: "bottom", overlayY: "bottom" };
    case "below":
      return { originY: "bottom", overlayY: "top" };
    default:
      return { originY: "center", overlayY: "center" };
  }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
  /** @type {?} */
  const targetIndex = options.indexOf(target);
  // Set the first item to be the target
  /** @type {?} */
  const reordered = [target];
  // Make left and right stacks where the highest priority item is last
  /** @type {?} */
  const left = options.slice(0, targetIndex);
  /** @type {?} */
  const right = options.slice(targetIndex + 1, options.length).reverse();
  // Alternate between stacks until one is empty
  while (left.length && right.length) {
    /** @type {?} */
    const r = right.pop();
    if (r) {
      reordered.push(r);
    }
    /** @type {?} */
    const l = left.pop();
    if (l) {
      reordered.push(l);
    }
  }
  // Flush out right side
  while (right.length) {
    /** @type {?} */
    const r2 = right.pop();
    if (r2) {
      reordered.push(r2);
    }
  }
  // Flush out left side
  while (left.length) {
    /** @type {?} */
    const l2 = left.pop();
    if (l2) {
      reordered.push(l2);
    }
  }
  return reordered;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover-accessibility.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const KEY_CODE = {
  DOWN_ARROW: 40,
  RIGHT_ARROW: 39,
  UP_ARROW: 38,
  LEFT_ARROW: 37,
  TAB: 9,
  ENTER: 13,
  SPACEBAR: 32,
};
KEY_CODE[KEY_CODE.DOWN_ARROW] = "DOWN_ARROW";
KEY_CODE[KEY_CODE.RIGHT_ARROW] = "RIGHT_ARROW";
KEY_CODE[KEY_CODE.UP_ARROW] = "UP_ARROW";
KEY_CODE[KEY_CODE.LEFT_ARROW] = "LEFT_ARROW";
KEY_CODE[KEY_CODE.TAB] = "TAB";
KEY_CODE[KEY_CODE.ENTER] = "ENTER";
KEY_CODE[KEY_CODE.SPACEBAR] = "SPACEBAR";
/**
 * @record
 */
function HcPopKeyboardNotifier() {}
if (false) {
  /** @type {?} */
  HcPopKeyboardNotifier.prototype.isOpen;
  /** @type {?} */
  HcPopKeyboardNotifier.prototype.nativeElement;
  /** @type {?} */
  HcPopKeyboardNotifier.prototype.hasSubmenu;
  /** @type {?} */
  HcPopKeyboardNotifier.prototype.onKeyDown;
}
class HcPopoverAccessibilityService {
  constructor() {
    this.notifiers = [];
    this.handleKeydown =
      /**
       * @param {?} event
       * @return {?}
       */
      (event) => {
        this.notifiers
          .filter(
            /**
             * @param {?} n
             * @return {?}
             */
            (n) => n.isOpen
          )
          .forEach(
            /**
             * @param {?} n
             * @return {?}
             */
            (n) => n.onKeyDown(event)
          );
        if (event.keyCode === KEY_CODE.RIGHT_ARROW) {
          this.notifiers
            .filter(
              /**
               * @param {?} n
               * @return {?}
               */
              (n) =>
                document.activeElement === n.nativeElement && n.hasSubmenu()
            )
            .forEach(
              /**
               * @param {?} n
               * @return {?}
               */
              (n) => n.onKeyDown(event)
            );
        }
      };
    window.addEventListener("keydown", this.handleKeydown);
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    window.removeEventListener("keydown", this.handleKeydown);
  }
  /**
   * @param {?} notifier
   * @return {?}
   */
  registerNotifier(notifier) {
    this.notifiers.push(notifier);
  }
}
HcPopoverAccessibilityService.ɵfac = function HcPopoverAccessibilityService_Factory(
  t
) {
  return new (t || HcPopoverAccessibilityService)();
};
HcPopoverAccessibilityService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: HcPopoverAccessibilityService,
  factory: HcPopoverAccessibilityService.ɵfac,
});
/** @nocollapse */
HcPopoverAccessibilityService.ctorParameters = () => [];
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcPopoverAccessibilityService.prototype.notifiers;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAccessibilityService.prototype.handleKeydown;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/popover-anchor.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HcPopoverAnchorDirective {
  /**
   * @param {?} _elementRef
   * @param {?} _viewContainerRef
   * @param {?} _anchoring
   * @param {?} _accessibility
   * @param {?} _componentFactoryResolver
   */
  constructor(
    _elementRef,
    _viewContainerRef,
    _anchoring,
    _accessibility,
    _componentFactoryResolver
  ) {
    this._elementRef = _elementRef;
    this._viewContainerRef = _viewContainerRef;
    this._anchoring = _anchoring;
    this._accessibility = _accessibility;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._trigger = "click";
    this._popoverDelay = 0;
    this._hasSubmenu = false;
    /**
     * Emits when the popover is opened.
     */
    this.popoverOpened = new EventEmitter();
    /**
     * Emits when the popover is closed.
     */
    this.popoverClosed = new EventEmitter();
    /**
     * Emits when the directive is destroyed.
     */
    this._onDestroy = new Subject();
  }
  /**
   * Reference to the popover instance.
   * @return {?}
   */
  get attachedPopover() {
    return this._attachedPopover;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set attachedPopover(value) {
    this._validateAttachedPopover(value);
    this._attachedPopover = value;
    // Anchor the popover to the element ref
    this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this);
  }
  /**
   * A string of text to display as a tooltip above an element
   * @return {?}
   */
  get tooltipText() {
    return this._tooltipText;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tooltipText(value) {
    this._tooltipText = value;
    /** @type {?} */
    const factory = this._componentFactoryResolver.resolveComponentFactory(
      HcTooltipComponent
    );
    /** @type {?} */
    const popover = this._viewContainerRef.createComponent(factory).instance;
    popover.tooltipContent = value;
    popover.disableStyle = true;
    popover.verticalAlign = "above";
    popover.scrollStrategy = "close";
    this.attachedPopover = popover;
    this.trigger = "hover";
    this.popoverDelay = 300;
  }
  /**
   * Trigger event to toggle the popover. *Defaults to `"click"`.*
   * Accepts `click`, `mousedown`, `hover`, `rightclick`, or `none`.
   * Note: if "hover" is selected, the backdrop for the popover will be disabled.
   * @return {?}
   */
  get trigger() {
    return this._trigger;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set trigger(val) {
    this._validateTrigger(val);
    if (this._trigger !== val) {
      this._trigger = val;
    }
    this._dispatchConfigNotification(
      new PopoverNotification(NotificationAction.UPDATE_CONFIG)
    );
  }
  /**
   * Number that can be passed into the popover to change hover delay. Also used for tooltip.
   * Delay is measured in milliseconds.
   * @return {?}
   */
  get popoverDelay() {
    return this._popoverDelay;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set popoverDelay(val) {
    this._popoverDelay = Number(val);
  }
  /**
   * Object or value that can be passed into the popover to customize its content
   * @return {?}
   */
  get context() {
    return this._anchoring._context;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set context(val) {
    this._anchoring._context = val;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    // Re-emit open and close events
    /** @type {?} */
    const opened$ = this._anchoring.popoverOpened.pipe(
      tap(
        /**
         * @return {?}
         */
        () => this.popoverOpened.emit()
      )
    );
    /** @type {?} */
    const closed$ = this._anchoring.popoverClosed.pipe(
      tap(
        /**
         * @param {?} value
         * @return {?}
         */
        (value) => this.popoverClosed.emit(value)
      )
    );
    merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._setupKeyboardEvents();
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    clearTimeout(this.hoverInterval);
    this._onDestroy.next();
    this._onDestroy.complete();
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _showOrHideOnClick($event) {
    if (this._hasSubmenu && event) {
      // Prevent the popover component from auto closing on click if a submenu was selected
      event.stopPropagation();
      event.preventDefault();
    }
    if (this.trigger !== "click") {
      return;
    }
    this._attachedPopover._offsetPos[0] =
      this._attachedPopover.horizontalAlign === "mouse" ? $event.offsetX : 0;
    this._attachedPopover._offsetPos[1] =
      this._attachedPopover.verticalAlign === "mouse" ? $event.offsetY : 0;
    this.togglePopover();
  }
  /**
   * So popover anchors can be accessible via keyboard.
   * @param {?} event
   * @return {?}
   */
  _showOrHideOnEnter(event) {
    // buttons already trigger a click when you press enter, so executing this event handler would be redundant
    /** @type {?} */
    const targetElement = /** @type {?} */ (event.target);
    /** @type {?} */
    const triggerFromButton =
      targetElement && targetElement.tagName === "BUTTON";
    // not triggering popover on keypress unless the key pressed was enter or spacebar
    /** @type {?} */
    const keyPressedShouldTrigger =
      event.keyCode === KEY_CODE.ENTER || event.keyCode === KEY_CODE.SPACEBAR;
    // not triggering popover on keypress unless the trigger is 'click'
    /** @type {?} */
    const anchorHasClickTrigger = this.trigger === "click";
    if (
      triggerFromButton ||
      !keyPressedShouldTrigger ||
      !anchorHasClickTrigger
    ) {
      return;
    }
    this.togglePopover();
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _showOrHideOnMouseOver($event) {
    if (this.trigger !== "mousedown") {
      return;
    }
    this._attachedPopover._offsetPos[0] =
      this._attachedPopover.horizontalAlign === "mouse" ? $event.offsetX : 0;
    this._attachedPopover._offsetPos[1] =
      this._attachedPopover.verticalAlign === "mouse" ? $event.offsetY : 0;
    this.togglePopover();
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _showOrHideRightClick($event) {
    if (this.trigger !== "rightclick") {
      return true;
    } else {
      this._attachedPopover._offsetPos[0] =
        this._attachedPopover.horizontalAlign === "mouse" ? $event.offsetX : 0;
      this._attachedPopover._offsetPos[1] =
        this._attachedPopover.verticalAlign === "mouse" ? $event.offsetY : 0;
      this.togglePopover();
      return false;
    }
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _showOnHover($event) {
    if (this.trigger !== "hover") {
      return;
    }
    this._attachedPopover._offsetPos[0] =
      this._attachedPopover.horizontalAlign === "mouse" ? $event.offsetX : 0;
    this._attachedPopover._offsetPos[1] =
      this._attachedPopover.verticalAlign === "mouse" ? $event.offsetY : 0;
    this.hoverInterval = window.setTimeout(
      /**
       * @return {?}
       */
      () => {
        this.togglePopover();
      },
      this.popoverDelay
    );
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _hideOnLeave($event) {
    if (this.trigger !== "hover") {
      return;
    }
    this.closePopover();
  }
  /**
   * Handle keyboard navigation of a hcMenu using the arrow or tab keys
   * @param {?} event
   * @return {?}
   */
  _keyEvent(event) {
    if (
      this.attachedPopover.isOpen() &&
      this.attachedPopover._menuItems.length > 0 &&
      !this.attachedPopover._subMenuOpen
    ) {
      if (
        event.keyCode === KEY_CODE.UP_ARROW ||
        (event.keyCode === KEY_CODE.TAB && event.shiftKey)
      ) {
        event.stopPropagation();
        event.preventDefault();
        this.attachedPopover._keyFocus(false);
      } else if (
        event.keyCode === KEY_CODE.DOWN_ARROW ||
        (event.keyCode === KEY_CODE.TAB && !event.shiftKey)
      ) {
        event.stopPropagation();
        event.preventDefault();
        this.attachedPopover._keyFocus(true);
      } else if (
        this.attachedPopover.parent &&
        this.attachedPopover.parent.isOpen() &&
        event.keyCode === KEY_CODE.LEFT_ARROW
      ) {
        event.stopPropagation();
        event.preventDefault();
        this.closePopover();
      }
    }
    if (
      this._hasSubmenu &&
      this._elementRef.nativeElement === document.activeElement &&
      event.keyCode === KEY_CODE.RIGHT_ARROW
    ) {
      event.stopPropagation();
      event.preventDefault();
      this.openPopover();
      this.attachedPopover._keyFocus(true);
    }
  }
  /**
   * Gets whether the popover is presently open.
   * @return {?}
   */
  isPopoverOpen() {
    return this._anchoring.isPopoverOpen();
  }
  /**
   * Toggles the popover between the open and closed states.
   * @return {?}
   */
  togglePopover() {
    this._anchoring.togglePopover();
  }
  /**
   * Opens the popover.
   * @param {?=} options
   * @return {?}
   */
  openPopover(options = {}) {
    this._anchoring.openPopover(options);
  }
  /**
   * Closes the popover.
   * @param {?=} value
   * @param {?=} neighborSubMenusAreOpen
   * @return {?}
   */
  closePopover(value, neighborSubMenusAreOpen = false) {
    clearTimeout(this.hoverInterval);
    this._anchoring.closePopover(value, neighborSubMenusAreOpen);
  }
  /**
   * Realign the popover to the anchor.
   * @return {?}
   */
  realignPopover() {
    this._anchoring.realignPopoverToAnchor();
  }
  /**
   * Get a reference to the anchor element.
   * @return {?}
   */
  getElement() {
    return this._elementRef;
  }
  /**
   * Throws an error if the popover instance is not provided.
   * @private
   * @param {?} popover
   * @return {?}
   */
  _validateAttachedPopover(popover) {
    if (!popover || !(popover instanceof HcPopComponent)) {
      throw getInvalidPopoverError();
    }
  }
  /**
   * Throws an error if the trigger is not a valid HcPopoverTrigger.
   * @private
   * @param {?} trig
   * @return {?}
   */
  _validateTrigger(trig) {
    if (VALID_TRIGGER.indexOf(trig) === -1) {
      throw getInvalidTriggerError(trig);
    }
  }
  /**
   * Dispatch a notification to the notification service, if possible.
   * @private
   * @param {?} notification
   * @return {?}
   */
  _dispatchConfigNotification(notification) {
    if (this._notifications) {
      this._notifications.dispatch(notification);
    }
  }
  /**
   * @private
   * @return {?}
   */
  _setupKeyboardEvents() {
    /** @type {?} */
    const notifier = {
      isOpen: false,
      nativeElement: this._elementRef.nativeElement,
      /**
       * @return {?}
       */
      hasSubmenu: () => this._hasSubmenu,
      /**
       * @param {?} event
       * @return {?}
       */
      onKeyDown: (event) => this._keyEvent(event),
    };
    this.popoverClosed.asObservable().subscribe(
      /**
       * @return {?}
       */
      () => (notifier.isOpen = false)
    );
    this.popoverOpened.asObservable().subscribe(
      /**
       * @return {?}
       */
      () => (notifier.isOpen = true)
    );
    this._accessibility.registerNotifier(notifier);
  }
}
HcPopoverAnchorDirective.ɵfac = function HcPopoverAnchorDirective_Factory(t) {
  return new (t || HcPopoverAnchorDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef),
    ɵngcc0.ɵɵdirectiveInject(HcPopoverAnchoringService),
    ɵngcc0.ɵɵdirectiveInject(HcPopoverAccessibilityService),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)
  );
};
HcPopoverAnchorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcPopoverAnchorDirective,
  selectors: [
    ["", "hcPop", ""],
    ["", "hcTooltip", ""],
  ],
  hostVars: 2,
  hostBindings: function HcPopoverAnchorDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "click",
        function HcPopoverAnchorDirective_click_HostBindingHandler($event) {
          return ctx._showOrHideOnClick($event);
        }
      )("keydown", function HcPopoverAnchorDirective_keydown_HostBindingHandler(
        $event
      ) {
        return ctx._showOrHideOnEnter($event);
      })(
        "touchstart",
        function HcPopoverAnchorDirective_touchstart_HostBindingHandler(
          $event
        ) {
          return ctx._showOrHideOnMouseOver($event);
        }
      )(
        "mousedown",
        function HcPopoverAnchorDirective_mousedown_HostBindingHandler($event) {
          return ctx._showOrHideOnMouseOver($event);
        }
      )(
        "contextmenu",
        function HcPopoverAnchorDirective_contextmenu_HostBindingHandler(
          $event
        ) {
          return ctx._showOrHideRightClick($event);
        }
      )(
        "mouseenter",
        function HcPopoverAnchorDirective_mouseenter_HostBindingHandler(
          $event
        ) {
          return ctx._showOnHover($event);
        }
      )(
        "touchend",
        function HcPopoverAnchorDirective_touchend_HostBindingHandler($event) {
          return ctx._hideOnLeave($event);
        }
      )(
        "touchcancel",
        function HcPopoverAnchorDirective_touchcancel_HostBindingHandler(
          $event
        ) {
          return ctx._hideOnLeave($event);
        }
      )(
        "mouseleave",
        function HcPopoverAnchorDirective_mouseleave_HostBindingHandler(
          $event
        ) {
          return ctx._hideOnLeave($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-item-submenu", ctx._hasSubmenu);
    }
  },
  inputs: {
    attachedPopover: ["hcPop", "attachedPopover"],
    tooltipText: ["hcTooltip", "tooltipText"],
    trigger: "trigger",
    popoverDelay: "popoverDelay",
    context: "context",
  },
  outputs: { popoverOpened: "popoverOpened", popoverClosed: "popoverClosed" },
  exportAs: ["hcPopAnchor"],
  features: [ɵngcc0.ɵɵProvidersFeature([HcPopoverAnchoringService])],
});
/** @nocollapse */
HcPopoverAnchorDirective.ctorParameters = () => [
  { type: ElementRef },
  { type: ViewContainerRef },
  { type: HcPopoverAnchoringService },
  { type: HcPopoverAccessibilityService },
  { type: ComponentFactoryResolver },
];
HcPopoverAnchorDirective.propDecorators = {
  attachedPopover: [{ type: Input, args: ["hcPop"] }],
  tooltipText: [{ type: Input, args: ["hcTooltip"] }],
  trigger: [{ type: Input }],
  popoverDelay: [{ type: Input }],
  context: [{ type: Input }],
  _hasSubmenu: [{ type: HostBinding, args: ["class.hc-menu-item-submenu"] }],
  popoverOpened: [{ type: Output }],
  popoverClosed: [{ type: Output }],
  _showOrHideOnClick: [{ type: HostListener, args: ["click", ["$event"]] }],
  _showOrHideOnEnter: [{ type: HostListener, args: ["keydown", ["$event"]] }],
  _showOrHideOnMouseOver: [
    { type: HostListener, args: ["touchstart", ["$event"]] },
    { type: HostListener, args: ["mousedown", ["$event"]] },
  ],
  _showOrHideRightClick: [
    { type: HostListener, args: ["contextmenu", ["$event"]] },
  ],
  _showOnHover: [{ type: HostListener, args: ["mouseenter", ["$event"]] }],
  _hideOnLeave: [
    { type: HostListener, args: ["touchend", ["$event"]] },
    { type: HostListener, args: ["touchcancel", ["$event"]] },
    { type: HostListener, args: ["mouseleave", ["$event"]] },
  ],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._attachedPopover;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._tooltipText;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._trigger;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._popoverDelay;
  /**
   * Timer that delays togglePopover on hover.
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype.hoverInterval;
  /** @type {?} */
  HcPopoverAnchorDirective.prototype._hasSubmenu;
  /**
   * Emits when the popover is opened.
   * @type {?}
   */
  HcPopoverAnchorDirective.prototype.popoverOpened;
  /**
   * Emits when the popover is closed.
   * @type {?}
   */
  HcPopoverAnchorDirective.prototype.popoverClosed;
  /**
   * Instance of notification service. Will be undefined until attached to a popover.
   * @type {?}
   */
  HcPopoverAnchorDirective.prototype._notifications;
  /**
   * Emits when the directive is destroyed.
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._onDestroy;
  /** @type {?} */
  HcPopoverAnchorDirective.prototype._elementRef;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._viewContainerRef;
  /** @type {?} */
  HcPopoverAnchorDirective.prototype._anchoring;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._accessibility;
  /**
   * @type {?}
   * @private
   */
  HcPopoverAnchorDirective.prototype._componentFactoryResolver;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/menu.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `hcMenu` directive provides a standard way of displaying a series of selectable elements in a popover.
 */
class MenuDirective {
  constructor() {
    this._hostClass = true;
    this.unsubscribe$ = new Subject();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this.updateSubMenus();
    // Update submenus if they are added dynamically or after check
    this._subMenus.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(
      /**
       * @return {?}
       */
      () => this.updateSubMenus()
    );
  }
  /**
   * Rechecks the content for instances of `HcPopComponent` and inits them as submenus
   * @return {?}
   */
  updateSubMenus() {
    this._subMenus.forEach(
      /**
       * @param {?} anchor
       * @return {?}
       */
      (anchor) => {
        anchor._hasSubmenu = true;
        // Subscribe to submenu open events so we can close any other submenus currently open
        anchor.popoverOpened.pipe(takeUntil(this.unsubscribe$)).subscribe(
          /**
           * @return {?}
           */
          () => {
            this._subMenus.forEach(
              /**
               * @param {?} sub
               * @return {?}
               */
              (sub) => {
                if (sub !== anchor && sub.attachedPopover.isOpen()) {
                  sub.attachedPopover._parentCloseBlock = true;
                  sub.attachedPopover._restoreFocusOverride = false;
                  sub.closePopover({}, true);
                  sub.attachedPopover._restoreFocusOverride = true;
                  /** @type {?} */
                  let closeSub = sub.attachedPopover.afterClose.subscribe(
                    /**
                     * @return {?}
                     */
                    () => {
                      sub.attachedPopover._parentCloseBlock = false;
                      closeSub.unsubscribe();
                    }
                  );
                }
              }
            );
          }
        );
      }
    );
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}
MenuDirective.ɵfac = function MenuDirective_Factory(t) {
  return new (t || MenuDirective)();
};
MenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: MenuDirective,
  selectors: [["", "hcMenu", ""]],
  contentQueries: function MenuDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcPopoverAnchorDirective, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._subMenus = _t);
    }
  },
  hostVars: 2,
  hostBindings: function MenuDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-panel", ctx._hostClass);
    }
  },
});
MenuDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-panel"] }],
  _subMenus: [{ type: ContentChildren, args: [HcPopoverAnchorDirective] }],
};
if (false) {
  /** @type {?} */
  MenuDirective.prototype._hostClass;
  /** @type {?} */
  MenuDirective.prototype._subMenus;
  /**
   * @type {?}
   * @private
   */
  MenuDirective.prototype.unsubscribe$;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/menu-icon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use `hcMenuIcon` to prefix an icon to the beginning of a button inside of a menu.
 */
class MenuIconDirective {
  constructor() {
    this._hostClass = true;
  }
}
MenuIconDirective.ɵfac = function MenuIconDirective_Factory(t) {
  return new (t || MenuIconDirective)();
};
MenuIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: MenuIconDirective,
  selectors: [["", "hcMenuIcon", ""]],
  hostVars: 2,
  hostBindings: function MenuIconDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-icon", ctx._hostClass);
    }
  },
});
MenuIconDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-icon"] }],
};
if (false) {
  /** @type {?} */
  MenuIconDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/menu-text.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use `hcMenuText` for main button text inside of a menu.
 */
class MenuTextDirective {
  constructor() {
    this._hostClass = true;
  }
}
MenuTextDirective.ɵfac = function MenuTextDirective_Factory(t) {
  return new (t || MenuTextDirective)();
};
MenuTextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: MenuTextDirective,
  selectors: [["", "hcMenuText", ""]],
  hostVars: 2,
  hostBindings: function MenuTextDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-text", ctx._hostClass);
    }
  },
});
MenuTextDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-text"] }],
};
if (false) {
  /** @type {?} */
  MenuTextDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/menu-sub-text.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use `hcMenuSubText` for right-aligned subtext of a button inside of a menu. Often used for keyboard shortcuts.
 */
class MenuSubTextDirective {
  constructor() {
    this._hostClass = true;
  }
}
MenuSubTextDirective.ɵfac = function MenuSubTextDirective_Factory(t) {
  return new (t || MenuSubTextDirective)();
};
MenuSubTextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: MenuSubTextDirective,
  selectors: [["", "hcMenuSubText", ""]],
  hostVars: 2,
  hostBindings: function MenuSubTextDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-sub-text", ctx._hostClass);
    }
  },
});
MenuSubTextDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-sub-text"] }],
};
if (false) {
  /** @type {?} */
  MenuSubTextDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/directives/divider.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Use `hcDivider` for a horizontal divider in a menu.
 */
class DividerDirective {
  constructor() {
    this._hostClass = true;
  }
}
DividerDirective.ɵfac = function DividerDirective_Factory(t) {
  return new (t || DividerDirective)();
};
DividerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: DividerDirective,
  selectors: [["", "hcDivider", ""]],
  hostVars: 2,
  hostBindings: function DividerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-divider", ctx._hostClass);
    }
  },
});
DividerDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-divider"] }],
};
if (false) {
  /** @type {?} */
  DividerDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/popover.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopModule {}
PopModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PopModule });
PopModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function PopModule_Factory(t) {
    return new (t || PopModule)();
  },
  providers: [HcPopoverAccessibilityService],
  imports: [[CommonModule, OverlayModule, A11yModule, BidiModule], BidiModule],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/progress-spinner.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedColors = [
  "blue",
  "green",
  "purple",
  "orange",
  "red",
  "gray",
  "white",
];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateColorInput(inputStr) {
  if (supportedColors.indexOf(inputStr) < 0) {
    throw Error("Unsupported progress spinner color value: " + inputStr);
  }
}
class ProgressSpinnerComponent {
  constructor() {
    this._color = "blue";
    /**
     * If true, the spinner will center itself inside its container.
     */
    this.isCentered = true;
    /**
     * If true, include background "channel" circle.
     */
    this.hasChannel = true;
    /**
     * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
     */
    this.isDeterminate = false;
    this._rightCircleTransform = "";
    this._leftCircleTransform = "";
    this._rightCircleTransition = "";
    this._leftCircleTransition = "";
    this._progress = 0;
    this._diameter = 0;
    this._minDiameter = 20;
    this._maxDiameter = 250;
  }
  /**
   * Color of the spinner: `blue`, `green`, `purple`, `orange`, `red`, `gray`, `white`
   * @return {?}
   */
  get color() {
    return this._color;
  }
  /**
   * @param {?} colorVal
   * @return {?}
   */
  set color(colorVal) {
    validateColorInput(colorVal);
    this._color = colorVal;
  }
  /**
   * (0-100%) Only used if "isDeterminate" is set to true.
   * @param {?} progress
   * @return {?}
   */
  set progress(progress) {
    this.setProgress(progress);
  }
  /**
   * @return {?}
   */
  get progress() {
    return this._progress;
  }
  /**
   * Set the diameter of the circle, in pixels. Minimum is 20, maximum is 250.
   * @param {?} diameter
   * @return {?}
   */
  set diameter(diameter) {
    this._diameter = Math.min(
      Math.max(this._minDiameter, diameter),
      this._maxDiameter
    );
  }
  /**
   * @return {?}
   */
  get diameter() {
    return this._diameter;
  }
  /**
   * @private
   * @param {?} progress
   * @return {?}
   */
  setProgress(progress) {
    progress = Math.min(100, progress);
    progress = Math.max(0, progress);
    this.setProgressTransition(progress);
    this.setProgressTransform(progress);
    this._progress = progress;
  }
  /**
   * @private
   * @param {?} progress
   * @return {?}
   */
  setProgressTransition(progress) {
    /** @type {?} */
    const sizeBasedTime = this.diameter > 150 ? 0.6 : 0.4;
    /** @type {?} */
    const timing =
      Math.abs(progress - this._progress) > 40
        ? sizeBasedTime
        : sizeBasedTime / 2;
    /** @type {?} */
    const halfTime = timing / 2;
    if (
      (progress <= 50 && this._progress <= 50) ||
      (progress >= 51 && this._progress >= 51)
    ) {
      this._leftCircleTransition = `transform ${timing}s ease-in-out 0s`;
      this._rightCircleTransition = `transform ${timing}s ease-in-out 0s`;
    } else if (progress <= 50 && this._progress >= 51) {
      this._leftCircleTransition = `transform ${halfTime}s ease-in 0s`;
      this._rightCircleTransition = `transform ${halfTime}s ease-out ${
        halfTime - 0.001
      }s`;
    } else if (progress >= 51 && this._progress <= 50) {
      this._leftCircleTransition = `transform ${halfTime}s ease-out ${
        halfTime - 0.001
      }s`;
      this._rightCircleTransition = `transform ${halfTime}s ease-in 0s`;
    }
  }
  /**
   * Using a somewhat complicated set of transforms to achive the animation.
   * For 0% to 50% the right circle element rotates from -135deg to 45deg
   * For 51% to 100% the left circle element rotates from 135deg to 315deg
   * @private
   * @param {?} progress
   * @return {?}
   */
  setProgressTransform(progress) {
    if (progress <= 50) {
      /** @type {?} */
      const rightDegrees = (progress / 50) * 180 - 135;
      this._rightCircleTransform = `rotate(${rightDegrees}deg)`;
      this._leftCircleTransform = `rotate(135deg)`;
    } else if (progress >= 51) {
      /** @type {?} */
      const leftDegrees = ((progress - 50) / 50) * 180 + 135;
      this._leftCircleTransform = `rotate(${leftDegrees}deg)`;
      this._rightCircleTransform = "rotate(45deg)";
    }
  }
}
ProgressSpinnerComponent.ɵfac = function ProgressSpinnerComponent_Factory(t) {
  return new (t || ProgressSpinnerComponent)();
};
ProgressSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ProgressSpinnerComponent,
  selectors: [["hc-progress-spinner"]],
  inputs: {
    isCentered: "isCentered",
    hasChannel: "hasChannel",
    isDeterminate: "isDeterminate",
    color: "color",
    progress: "progress",
    diameter: "diameter",
  },
  decls: 10,
  vars: 29,
  consts: [
    [1, "hc-spinner-container", 3, "ngClass"],
    [1, "hc-spinner", 3, "ngClass"],
    [3, "ngClass"],
    [1, "circle", "base-circle"],
    [1, "circle-clipper", "left"],
    [1, "circle"],
    [1, "gap-patch"],
    [1, "circle-clipper", "right"],
  ],
  template: function ProgressSpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵelement(3, "div", 3);
      ɵngcc0.ɵɵelementStart(4, "div", 4);
      ɵngcc0.ɵɵelement(5, "div", 5);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(6, "div", 6);
      ɵngcc0.ɵɵelement(7, "div", 5);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(8, "div", 7);
      ɵngcc0.ɵɵelement(9, "div", 5);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(22, _c8, ctx.isCentered)
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵstyleProp("width", ctx.diameter, "px")(
        "height",
        ctx.diameter,
        "px"
      )("margin-top", ctx.isCentered ? ctx.diameter / -2 : 0, "px")(
        "margin-left",
        ctx.isCentered ? ctx.diameter / -2 : 0,
        "px"
      );
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction2(24, _c9, !ctx.isDeterminate, ctx.diameter >= 150)
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassMapInterpolate1("spinner-layer spinner-", ctx.color, "");
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(27, _c10, ctx.hasChannel)
      );
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵstyleProp("transform", ctx._leftCircleTransform)(
        "transition",
        ctx._leftCircleTransition
      );
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵstyleProp("transform", ctx._rightCircleTransform)(
        "transition",
        ctx._rightCircleTransition
      );
    }
  },
  directives: [ɵngcc1.NgClass],
  encapsulation: 2,
});
ProgressSpinnerComponent.propDecorators = {
  color: [{ type: Input }],
  isCentered: [{ type: Input }],
  hasChannel: [{ type: Input }],
  isDeterminate: [{ type: Input }],
  progress: [{ type: Input }],
  diameter: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  ProgressSpinnerComponent.prototype._color;
  /**
   * If true, the spinner will center itself inside its container.
   * @type {?}
   */
  ProgressSpinnerComponent.prototype.isCentered;
  /**
   * If true, include background "channel" circle.
   * @type {?}
   */
  ProgressSpinnerComponent.prototype.hasChannel;
  /**
   * If true, switches to determinate mode. Must pass in progress (0-100%), instead of having the loader spin freely.
   * @type {?}
   */
  ProgressSpinnerComponent.prototype.isDeterminate;
  /** @type {?} */
  ProgressSpinnerComponent.prototype._rightCircleTransform;
  /** @type {?} */
  ProgressSpinnerComponent.prototype._leftCircleTransform;
  /** @type {?} */
  ProgressSpinnerComponent.prototype._rightCircleTransition;
  /** @type {?} */
  ProgressSpinnerComponent.prototype._leftCircleTransition;
  /**
   * @type {?}
   * @private
   */
  ProgressSpinnerComponent.prototype._progress;
  /**
   * @type {?}
   * @private
   */
  ProgressSpinnerComponent.prototype._diameter;
  /**
   * @type {?}
   * @private
   */
  ProgressSpinnerComponent.prototype._minDiameter;
  /**
   * @type {?}
   * @private
   */
  ProgressSpinnerComponent.prototype._maxDiameter;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/progress-dots.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedColors$1 = ["light", "dark"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateColorInput$1(inputStr) {
  if (supportedColors$1.indexOf(inputStr) < 0) {
    throw Error("Unsupported progress dots color value: " + inputStr);
  }
}
class ProgressDotsComponent {
  constructor() {
    this._color = "dark";
    /**
     * If true, the loader will center itself within its container.
     */
    this.isCentered = true;
    /**
     * If true, you'll get a teeny tiny little loader.
     */
    this.isMini = false;
  }
  /**
   * Use `light` on darker backgrounds and `dark` for lighter backgrounds.
   * @return {?}
   */
  get color() {
    return this._color;
  }
  /**
   * @param {?} colorVal
   * @return {?}
   */
  set color(colorVal) {
    validateColorInput$1(colorVal);
    this._color = colorVal;
  }
}
ProgressDotsComponent.ɵfac = function ProgressDotsComponent_Factory(t) {
  return new (t || ProgressDotsComponent)();
};
ProgressDotsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ProgressDotsComponent,
  selectors: [["hc-progress-dots"]],
  inputs: { isCentered: "isCentered", isMini: "isMini", color: "color" },
  decls: 3,
  vars: 7,
  consts: [
    [1, "hc-dots-container", 3, "ngClass"],
    [1, "hc-dots-loader", 3, "ngClass"],
    [1, "loader-animate"],
  ],
  template: function ProgressDotsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵelement(2, "div", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(2, _c11, ctx.isCentered)
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction2(4, _c12, ctx.color === "light", ctx.isMini)
      );
    }
  },
  directives: [ɵngcc1.NgClass],
  encapsulation: 2,
});
ProgressDotsComponent.propDecorators = {
  color: [{ type: Input }],
  isCentered: [{ type: Input }],
  isMini: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  ProgressDotsComponent.prototype._color;
  /**
   * If true, the loader will center itself within its container.
   * @type {?}
   */
  ProgressDotsComponent.prototype.isCentered;
  /**
   * If true, you'll get a teeny tiny little loader.
   * @type {?}
   */
  ProgressDotsComponent.prototype.isMini;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/progress-indicators.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressIndicatorsModule {}
ProgressIndicatorsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
  type: ProgressIndicatorsModule,
});
ProgressIndicatorsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ProgressIndicatorsModule_Factory(t) {
    return new (t || ProgressIndicatorsModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/app-switcher.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * An app switcher service designed to work with the Health Catalyst DOS platform's DiscoveryService
 */
class AppSwitcherService {
  /**
   * @param {?} http
   * @param {?} config
   */
  constructor(http, config) {
    this.http = http;
    this.config = config;
    if (!config || !config.discoveryServiceUri) {
      throw new Error(
        [
          "Failed to initialize AppSwitcherService: invalid APP_SWITCHER_CONFIG.",
          "You must provide a config object with a `discoveryServiceUri`.",
          `(value provided: ${config ? config.discoveryServiceUri : config})`,
        ].join(" ")
      );
    }
    this.discoveryServiceUri = this.normalizeUri(
      this.config.discoveryServiceUri
    );
    this.allApplicationsUri = `${this.discoveryServiceUri}/apps`;
  }
  /**
   * @return {?}
   */
  getApplications() {
    /** @type {?} */
    const url = `${this.discoveryServiceUri}/v1/Services?$filter=DiscoveryType eq 'Application' and IsHidden eq false&$top=12`;
    return this.http.get(url, { withCredentials: true });
  }
  /**
   * @private
   * @param {?} uri
   * @return {?}
   */
  normalizeUri(uri) {
    return uri.replace(/\/(v\d+\/?)?$/, "");
  }
}
AppSwitcherService.ɵfac = function AppSwitcherService_Factory(t) {
  return new (t || AppSwitcherService)(
    ɵngcc0.ɵɵinject(ɵngcc5.HttpClient),
    ɵngcc0.ɵɵinject(APP_SWITCHER_CONFIG)
  );
};
AppSwitcherService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: AppSwitcherService,
  factory: AppSwitcherService.ɵfac,
});
/** @nocollapse */
AppSwitcherService.ctorParameters = () => [
  { type: HttpClient },
  {
    type: undefined,
    decorators: [{ type: Inject, args: [APP_SWITCHER_CONFIG] }],
  },
];
if (false) {
  /** @type {?} */
  AppSwitcherService.prototype.allApplicationsUri;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherService.prototype.discoveryServiceUri;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherService.prototype.http;
  /**
   * @type {?}
   * @private
   */
  AppSwitcherService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ellipsis/ellipsis.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EllipsisPipe {
  /**
   * @param {?} value
   * @param {?} length
   * @param {?=} mode
   * @return {?}
   */
  transform(value, length, mode = "characters") {
    if (
      typeof value !== "string" ||
      typeof length !== "number" ||
      length < 0 ||
      isNaN(length) ||
      Math.floor(length) !== length
    ) {
      return value;
    }
    /** @type {?} */
    const truncated =
      mode === "words"
        ? this.firstNWords(value, length)
        : this.firstNCharacters(value, length);
    if (truncated === value) {
      return value;
    }
    return truncated + EllipsisPipe.ELLIPSIS;
  }
  /**
   * @private
   * @param {?} value
   * @param {?} n
   * @return {?}
   */
  firstNWords(value, n) {
    /** @type {?} */
    const words = value.split(/\s+/g);
    if (words.length <= n) {
      return value;
    }
    /** @type {?} */
    const pattern = new RegExp("^" + words.slice(0, n).join("\\s+"));
    return /** @type {?} */ (pattern.exec(value))[0];
  }
  /**
   * @private
   * @param {?} value
   * @param {?} n
   * @return {?}
   */
  firstNCharacters(value, n) {
    return value.length > n ? value.substring(0, n) : value;
  }
}
EllipsisPipe.ɵfac = function EllipsisPipe_Factory(t) {
  return new (t || EllipsisPipe)();
};
EllipsisPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({
  name: "ellipsis",
  type: EllipsisPipe,
  pure: true,
});
EllipsisPipe.ELLIPSIS = "…";
if (false) {
  /** @type {?} */
  EllipsisPipe.ELLIPSIS;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ellipsis/ellipsis-pipe.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EllipsisPipeModule {}
EllipsisPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EllipsisPipeModule });
EllipsisPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function EllipsisPipeModule_Factory(t) {
    return new (t || EllipsisPipeModule)();
  },
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/null-or-empty-string/null-or-empty-string.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NullOrEmptyStringPipe {
  /**
   * @param {?} value
   * @param {?} altText
   * @return {?}
   */
  transform(value, altText) {
    if (typeof value === "string") {
      value = value.trim();
      return value ? value : altText;
    }
    if (value === undefined || value === null) {
      return altText;
    }
    // if given value is not null or undefined, and is not a string, return as is
    return value;
  }
}
NullOrEmptyStringPipe.ɵfac = function NullOrEmptyStringPipe_Factory(t) {
  return new (t || NullOrEmptyStringPipe)();
};
NullOrEmptyStringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({
  name: "ifNullOrEmpty",
  type: NullOrEmptyStringPipe,
  pure: true,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/null-or-empty-string/null-or-empty-string-pipe.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NullOrEmptyStringPipeModule {}
NullOrEmptyStringPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
  type: NullOrEmptyStringPipeModule,
});
NullOrEmptyStringPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function NullOrEmptyStringPipeModule_Factory(t) {
    return new (t || NullOrEmptyStringPipeModule)();
  },
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/file-size/file-size.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Convert bytes into largest possible unit.
// Credit to https://gist.github.com/JonCatmull/ecdf9441aaa37336d9ae2c7f9cb7289a
class FileSizePipe {
  constructor() {
    this.units = ["bytes", "KB", "MB", "GB", "TB", "PB"];
  }
  /**
   * @param {?} bytes
   * @param {?=} precision
   * @return {?}
   */
  transform(bytes, precision = 2) {
    /** @type {?} */
    const originalInput = bytes;
    if (typeof bytes === "string") {
      bytes = +bytes;
    }
    if (
      typeof bytes !== "number" ||
      isNaN(bytes) ||
      !isFinite(bytes) ||
      bytes < 0 ||
      Math.floor(bytes) !== bytes
    ) {
      return `${originalInput}`;
    }
    if (
      typeof precision !== "number" ||
      isNaN(precision) ||
      !isFinite(precision) ||
      precision < 0 ||
      Math.floor(precision) !== precision
    ) {
      precision = 2;
    }
    if (precision > 100) {
      precision = 100;
    }
    /** @type {?} */
    let unit = 0;
    while (bytes >= 1024) {
      bytes /= 1024;
      unit++;
      if (unit === 5) {
        // PB, largest size for pipe
        break;
      }
    }
    /** @type {?} */
    let rounded = bytes.toFixed(precision);
    // if the value after truncating is a whole number, don't display a decimal
    if (Math.floor(+rounded) === +rounded) {
      rounded = (+rounded).toString();
    }
    return rounded + " " + this.units[unit];
  }
}
FileSizePipe.ɵfac = function FileSizePipe_Factory(t) {
  return new (t || FileSizePipe)();
};
FileSizePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({
  name: "fileSize",
  type: FileSizePipe,
  pure: true,
});
if (false) {
  /**
   * @type {?}
   * @private
   */
  FileSizePipe.prototype.units;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/file-size/file-size-pipe.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileSizePipeModule {}
FileSizePipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FileSizePipeModule });
FileSizePipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function FileSizePipeModule_Factory(t) {
    return new (t || FileSizePipeModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/number-abbreviator/number-abbreviator.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates an abbreviated number for display. 1,234,234 => 1.23M
 */
class NumberAbbreviatorPipe {
  /**
   * @param {?} value the value to be abbreviated
   * @param {?=} decimalPoints how many decimal points to round to
   * @param {?=} threshold represents the number at which we should start abbreviating;
   * if the threshold is 1 million, we'll leave number less than 1 million as is (aside from adding commas or decimal points)
   * @return {?}
   */
  transform(value, decimalPoints = 2, threshold = 1000000) {
    if (value === null) {
      return value;
    }
    // use defaults if given funky parameters
    if (decimalPoints < 0 || !Number.isInteger(decimalPoints)) {
      decimalPoints = 2;
    }
    if (threshold < 1000 || !Number.isInteger(threshold)) {
      threshold = 1000;
    }
    /** @type {?} */
    const abs = Math.abs(value);
    /** @type {?} */
    let key = "";
    /** @type {?} */
    let roundedStringVal = "";
    /** @type {?} */
    const isNegative = value < 0;
    if (abs >= threshold) {
      // Abbreviate, adding unit if greater than specified limit
      for (const power of NumberAbbreviatorPipe.powers) {
        /** @type {?} */
        let reduced = abs / power.value;
        reduced = this.roundValue(reduced, decimalPoints);
        if (reduced >= 1) {
          roundedStringVal = reduced.toString();
          key = power.key;
          break;
        }
      }
    } else {
      // Just round decimals and add commas if less than specified limit
      roundedStringVal = this.roundValue(abs, decimalPoints).toLocaleString();
    }
    return (isNegative ? "-" : "") + roundedStringVal + key;
  }
  /**
   * @private
   * @param {?} value
   * @param {?=} decimalPoints
   * @return {?}
   */
  roundValue(value, decimalPoints = 2) {
    /** @type {?} */
    const rounder = Math.pow(10, decimalPoints);
    return Math.round(value * rounder) / rounder;
  }
}
NumberAbbreviatorPipe.ɵfac = function NumberAbbreviatorPipe_Factory(t) {
  return new (t || NumberAbbreviatorPipe)();
};
NumberAbbreviatorPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({
  name: "abbreviateNumber",
  type: NumberAbbreviatorPipe,
  pure: true,
});
NumberAbbreviatorPipe.powers = [
  { key: "Q", value: Math.pow(10, 15) },
  { key: "T", value: Math.pow(10, 12) },
  { key: "B", value: Math.pow(10, 9) },
  { key: "M", value: Math.pow(10, 6) },
  { key: "K", value: 1000 },
];
if (false) {
  /** @type {?} */
  NumberAbbreviatorPipe.powers;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/number-abbreviator/number-abbreviator-pipe.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NumberAbbreviatorPipeModule {}
NumberAbbreviatorPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
  type: NumberAbbreviatorPipeModule,
});
NumberAbbreviatorPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function NumberAbbreviatorPipeModule_Factory(t) {
    return new (t || NumberAbbreviatorPipeModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/highlight/highlight.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightPipe {
  /**
   * @param {?} text
   * @param {?} search
   * @return {?}
   */
  transform(text, search) {
    if (search && text) {
      /** @type {?} */
      let pattern = this.escapeTags(search).replace(
        /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
        "\\$&"
      );
      pattern = pattern
        .split(" ")
        .filter(
          /**
           * @param {?} t
           * @return {?}
           */
          (t) => {
            return t.length > 0;
          }
        )
        .join("|");
      /** @type {?} */
      const regex = new RegExp(pattern, "gi");
      return this.escapeTags(text).replace(
        regex,
        /**
         * @param {?} match
         * @return {?}
         */ (match) => `<span class="hc-text-highlight">${match}</span>`
      );
    } else {
      return this.escapeTags(text);
    }
  }
  /**
   * @param {?} input
   * @return {?}
   */
  escapeTags(input) {
    return (input || "").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
}
HighlightPipe.ɵfac = function HighlightPipe_Factory(t) {
  return new (t || HighlightPipe)();
};
HighlightPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({
  name: "highlight",
  type: HighlightPipe,
  pure: true,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/highlight/highlight-pipe.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightPipeModule {}
HighlightPipeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
  type: HighlightPipeModule,
});
HighlightPipeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function HighlightPipeModule_Factory(t) {
    return new (t || HighlightPipeModule)();
  },
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/pipes.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PipesModule {}
PipesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PipesModule });
PipesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function PipesModule_Factory(t) {
    return new (t || PipesModule)();
  },
  imports: [
    [
      EllipsisPipeModule,
      NullOrEmptyStringPipeModule,
      FileSizePipeModule,
      NumberAbbreviatorPipeModule,
      HighlightPipeModule,
    ],
    EllipsisPipeModule,
    NullOrEmptyStringPipeModule,
    FileSizePipeModule,
    NumberAbbreviatorPipeModule,
    HighlightPipeModule,
  ],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/icon.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object used to pass values that will be used in an IconComponent
 * @record
 */
function HcIcon() {}
if (false) {
  /**
   * Font set icon is a part of
   * @type {?}
   */
  HcIcon.prototype.fontSet;
  /**
   * Name of icon within a font set
   * @type {?}
   */
  HcIcon.prototype.fontIcon;
  /**
   * Optional height in pixels of the icon; defaults to 37
   * @type {?|undefined}
   */
  HcIcon.prototype.fontSize;
}
/**
 * Makes using a font icon easier.
 */
class IconComponent {
  /**
   * @param {?} elementRef
   * @param {?} ariaHidden
   */
  constructor(elementRef, ariaHidden) {
    this.elementRef = elementRef;
    this._fontIcon = "";
    this._fontSet = "";
    this._previousFontIcon = "";
    this._previousFontSet = "";
    this._hostClass = true;
    // icon should be hidden for accessibility
    if (!ariaHidden) {
      elementRef.nativeElement.setAttribute("aria-hidden", "true");
    }
  }
  /**
   * Name of icon within a font set.
   * @return {?}
   */
  get fontIcon() {
    return this._fontIcon;
  }
  /**
   * @param {?} icon
   * @return {?}
   */
  set fontIcon(icon) {
    this._fontIcon = this._cleanupFontValue(icon);
  }
  /**
   * Font set icon is a part of.
   * @return {?}
   */
  get fontSet() {
    return this._fontSet;
  }
  /**
   * @param {?} fontSet
   * @return {?}
   */
  set fontSet(fontSet) {
    this._fontSet = this._cleanupFontValue(fontSet);
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    this._updateFontIcon();
  }
  /**
   * @private
   * @return {?}
   */
  _updateFontIcon() {
    /** @type {?} */
    const element = this.elementRef.nativeElement;
    if (this._previousFontIcon !== this._fontIcon) {
      if (this._previousFontIcon) {
        element.classList.remove(this._previousFontIcon);
      }
      if (this._fontIcon) {
        element.classList.add(this._fontIcon);
        this._previousFontIcon = this._fontIcon;
      }
    }
    if (this._previousFontSet !== this._fontSet) {
      if (this._previousFontSet) {
        element.classList.remove(this._previousFontSet);
      }
      if (this._fontSet) {
        element.classList.add(this._fontSet);
        this._previousFontSet = this._fontSet;
      }
    }
  }
  // make sure that there are no spaces and that if they sent multiple space separated values grab the first
  /**
   * @private
   * @param {?} fontValue
   * @return {?}
   */
  _cleanupFontValue(fontValue) {
    return (fontValue || "").trim().split(" ")[0];
  }
}
IconComponent.ɵfac = function IconComponent_Factory(t) {
  return new (t || IconComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵinjectAttribute("aria-hidden")
  );
};
IconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: IconComponent,
  selectors: [["hc-icon"]],
  hostVars: 2,
  hostBindings: function IconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-icon", ctx._hostClass);
    }
  },
  inputs: { fontIcon: "fontIcon", fontSet: "fontSet" },
  features: [ɵngcc0.ɵɵNgOnChangesFeature],
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function IconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  styles: [
    ".hc-icon-sm,[icon-sm]{font-size:14px!important;height:14px!important;width:14px!important}.hc-icon-md,[icon-md]{font-size:20px!important;height:20px!important;width:20px!important}.hc-icon-lg,[icon-lg]{font-size:36px!important;height:36px!important;width:36px!important}.hc-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;font-size:20px;height:20px;text-align:center;width:20px}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
IconComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: String, decorators: [{ type: Attribute, args: ["aria-hidden"] }] },
];
IconComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-icon"] }],
  fontIcon: [{ type: Input }],
  fontSet: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  IconComponent.prototype._fontIcon;
  /**
   * @type {?}
   * @private
   */
  IconComponent.prototype._fontSet;
  /**
   * @type {?}
   * @private
   */
  IconComponent.prototype._previousFontIcon;
  /**
   * @type {?}
   * @private
   */
  IconComponent.prototype._previousFontSet;
  /** @type {?} */
  IconComponent.prototype._hostClass;
  /**
   * @type {?}
   * @private
   */
  IconComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/hc-icon-sm.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * `hcIconSm` - small size of hc-icon (14px)
 */
class HcIconSmallDirective {
  constructor() {
    this._hostHcIconSmallClass = true;
  }
}
HcIconSmallDirective.ɵfac = function HcIconSmallDirective_Factory(t) {
  return new (t || HcIconSmallDirective)();
};
HcIconSmallDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcIconSmallDirective,
  selectors: [["", "hcIconSm", ""]],
  hostVars: 2,
  hostBindings: function HcIconSmallDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-icon-sm", ctx._hostHcIconSmallClass);
    }
  },
});
HcIconSmallDirective.propDecorators = {
  _hostHcIconSmallClass: [{ type: HostBinding, args: ["class.hc-icon-sm"] }],
};
if (false) {
  /** @type {?} */
  HcIconSmallDirective.prototype._hostHcIconSmallClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/hc-icon-md.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * `hcIconMd` - medium size of hc-icon (20px) - default size
 */
class HcIconMediumDirective {
  constructor() {
    this._hostHcIconMediumClass = true;
  }
}
HcIconMediumDirective.ɵfac = function HcIconMediumDirective_Factory(t) {
  return new (t || HcIconMediumDirective)();
};
HcIconMediumDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcIconMediumDirective,
  selectors: [["", "hcIconMd", ""]],
  hostVars: 2,
  hostBindings: function HcIconMediumDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-icon-md", ctx._hostHcIconMediumClass);
    }
  },
});
HcIconMediumDirective.propDecorators = {
  _hostHcIconMediumClass: [{ type: HostBinding, args: ["class.hc-icon-md"] }],
};
if (false) {
  /** @type {?} */
  HcIconMediumDirective.prototype._hostHcIconMediumClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/hc-icon-lg.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * `hcIconLg` - large size of hc-icon (36px)
 */
class HcIconLargeDirective {
  constructor() {
    this._hostHcIconLargeClass = true;
  }
}
HcIconLargeDirective.ɵfac = function HcIconLargeDirective_Factory(t) {
  return new (t || HcIconLargeDirective)();
};
HcIconLargeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcIconLargeDirective,
  selectors: [["", "hcIconLg", ""]],
  hostVars: 2,
  hostBindings: function HcIconLargeDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-icon-lg", ctx._hostHcIconLargeClass);
    }
  },
});
HcIconLargeDirective.propDecorators = {
  _hostHcIconLargeClass: [{ type: HostBinding, args: ["class.hc-icon-lg"] }],
};
if (false) {
  /** @type {?} */
  HcIconLargeDirective.prototype._hostHcIconLargeClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/icon.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconModule {}
IconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IconModule });
IconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function IconModule_Factory(t) {
    return new (t || IconModule)();
  },
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/app-switcher.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppSwitcherModule {
  /**
   * @param {?} config
   * @return {?}
   */
  static forRoot(config) {
    return {
      ngModule: AppSwitcherModule,
      providers: [
        {
          provide: APP_SWITCHER_CONFIG,
          useValue: config,
        },
      ],
    };
  }
}
AppSwitcherModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AppSwitcherModule });
AppSwitcherModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function AppSwitcherModule_Factory(t) {
    return new (t || AppSwitcherModule)();
  },
  providers: [
    {
      provide: APP_SWITCHER_SERVICE,
      useClass: AppSwitcherService,
    },
    WorkTrackerService,
  ],
  imports: [
    [
      CommonModule,
      PopModule,
      HttpClientModule,
      PipesModule,
      IconModule,
      ProgressIndicatorsModule,
    ],
  ],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/app-switcher/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/banner/hc-banner.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Notification banners are used for general information about the state of the application or upcoming events. For instant
 * feedback responding to user actions, use a toaster message.
 */
class HcBannerComponent {
  constructor() {
    this._type = "info";
    this._clickDismiss = false;
    /**
     * If the banner can be dismissed, emits when the banner is clicked to close
     */
    this.bannerClose = new EventEmitter();
  }
  /**
   * Style of the notification banner; Defaults to info.
   * Options are: `success`, `info`, `warning`, `alert`
   * @return {?}
   */
  get type() {
    return this._type;
  }
  /**
   * @param {?} typeVal
   * @return {?}
   */
  set type(typeVal) {
    if (
      typeVal !== "success" &&
      typeVal !== "info" &&
      typeVal !== "warning" &&
      typeVal !== "alert"
    ) {
      throw new Error("Unsupported banner type: " + typeVal);
    }
    this._type = typeVal;
  }
  /**
   * When set to true, a close icon is added to the right side and `bannerClose`
   * emits on a click. Defaults to false.
   * @return {?}
   */
  get clickDismiss() {
    return this._clickDismiss;
  }
  /**
   * @param {?} dismissVal
   * @return {?}
   */
  set clickDismiss(dismissVal) {
    this._clickDismiss = parseBooleanAttribute(dismissVal);
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _bannerClick(event) {
    if (this._clickDismiss) {
      this.bannerClose.emit(event);
    }
  }
}
HcBannerComponent.ɵfac = function HcBannerComponent_Factory(t) {
  return new (t || HcBannerComponent)();
};
HcBannerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcBannerComponent,
  selectors: [["hc-banner"]],
  inputs: { type: "type", clickDismiss: "clickDismiss" },
  outputs: { bannerClose: "bannerClose" },
  ngContentSelectors: _c3,
  decls: 3,
  vars: 7,
  consts: [
    [3, "ngClass", "click"],
    ["class", "hc-banner-close", 4, "ngIf"],
    [1, "hc-banner-close"],
    [1, "hc-banner-close-icon"],
  ],
  template: function HcBannerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵlistener(
        "click",
        function HcBannerComponent_Template_div_click_0_listener($event) {
          return ctx._bannerClick($event);
        }
      );
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵtemplate(2, HcBannerComponent_span_2_Template, 2, 0, "span", 1);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassMapInterpolate1("hc-banner hc-banner-", ctx.type, "");
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(5, _c13, ctx.clickDismiss)
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("ngIf", ctx.clickDismiss);
    }
  },
  directives: [ɵngcc1.NgClass, ɵngcc1.NgIf],
  styles: [
    ".hc-banner{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:start;justify-content:flex-start;padding:10px;width:100%;z-index:950}.hc-banner-dismiss{cursor:pointer;pointer-events:all}.hc-banner-dismiss.hc-banner-success:hover{background-color:#008f4b}.hc-banner-dismiss.hc-banner-warning:hover{background-color:#f48a08}.hc-banner-dismiss.hc-banner-alert:hover{background-color:#ef242e}.hc-banner-dismiss.hc-banner-info:hover{background-color:#c6e0ec}.hc-banner-success{background-color:#00a859;color:#fff}.hc-banner-warning{background-color:#f8961d;color:#fff}.hc-banner-alert{background-color:#f13c45;color:#fff}.hc-banner-info{background-color:#d9eaf2;border:1px solid #b3d5e6;border-left:none;border-right:none;color:#333}.hc-banner-close{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;margin-left:auto;padding-left:20px;padding-right:10px}.hc-banner-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNmZmY7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;height:15px;opacity:.6;width:15px}.hc-banner-info .hc-banner-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICMwMDZlOWE7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=)}.hc-banner-stamp{font-size:.78571rem;border-radius:4px;font-weight:700;letter-spacing:1px;margin:0 10px;padding:5px 15px}.hc-banner-success .hc-banner-stamp{background-color:#fff;color:#00a859}.hc-banner-warning .hc-banner-stamp{background-color:#fff;color:#f8961d}.hc-banner-alert .hc-banner-stamp{background-color:#fff;color:#f13c45}.hc-banner-info .hc-banner-stamp{background-color:#008bcc;color:#fff}",
  ],
  encapsulation: 2,
});
HcBannerComponent.propDecorators = {
  bannerClose: [{ type: Output }],
  type: [{ type: Input }],
  clickDismiss: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcBannerComponent.prototype._type;
  /**
   * @type {?}
   * @private
   */
  HcBannerComponent.prototype._clickDismiss;
  /**
   * If the banner can be dismissed, emits when the banner is clicked to close
   * @type {?}
   */
  HcBannerComponent.prototype.bannerClose;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/banner/hc-banner-stamp.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Including `hcBannerStamp` wraps the enclosed text in a stamp to provide greater emphasis
 */
class BannerStampDirective {
  /**
   * @return {?}
   */
  get _hostClass() {
    return true;
  }
}
BannerStampDirective.ɵfac = function BannerStampDirective_Factory(t) {
  return new (t || BannerStampDirective)();
};
BannerStampDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: BannerStampDirective,
  selectors: [["", "hcBannerStamp", ""]],
  hostVars: 2,
  hostBindings: function BannerStampDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-banner-stamp", ctx._hostClass);
    }
  },
});
BannerStampDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-banner-stamp"] }],
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/banner/hc-banner.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BannerModule {}
BannerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BannerModule });
BannerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function BannerModule_Factory(t) {
    return new (t || BannerModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/banner/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/breadcrumbs/breadcrumbs.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * IBreadcrumb interface is used to store all required data for each breadcrumb element
 * \@docs-private
 * @record
 */
function IBreadcrumb() {}
if (false) {
  /** @type {?} */
  IBreadcrumb.prototype.label;
  /** @type {?|undefined} */
  IBreadcrumb.prototype.params;
  /** @type {?} */
  IBreadcrumb.prototype.url;
}
/**
 * A navigational aid that allows users to keep track of their location within the current application
 */
class BreadcrumbsComponent {
  /**
   * @param {?} activatedRoute
   * @param {?} router
   */
  constructor(activatedRoute, router) {
    this.activatedRoute = activatedRoute;
    this.router = router;
    this._breadcrumbs = [];
    this._backURL = "";
    this._backShow = "none";
    this._locationLabel = "";
    this._queryParamsHandling = "";
  }
  /**
   * Sets the handling of the query parameters for the breadcrumb. Choose from: `'preserve' | 'merge' | '' (default)`
   * @return {?}
   */
  get queryParamsHandling() {
    return this._queryParamsHandling;
  }
  /**
   * @param {?} queryParamsHandling
   * @return {?}
   */
  set queryParamsHandling(queryParamsHandling) {
    this._queryParamsHandling = queryParamsHandling;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    /** @type {?} */
    const ROUTE_DATA_BREADCRUMB = "breadcrumb";
    // Add the first breadcrumb for the base page
    /** @type {?} */
    let root = this.activatedRoute.root;
    this._breadcrumbs = this.getBreadcrumbs(root);
    // subscribe to the NavigationEnd event
    this._routerSubscription = this.router.events.subscribe(
      /**
       * @param {?} event
       * @return {?}
       */
      (event) => {
        if (event instanceof NavigationEnd) {
          this.setBreadcrumbs();
        }
      }
    );
    // set initial breadcrumb state
    this.setBreadcrumbs();
  }
  /**
   * @private
   * @return {?}
   */
  setBreadcrumbs() {
    /** @type {?} */
    const root = this.activatedRoute.root;
    this._breadcrumbs = this.getBreadcrumbs(root);
    if (this._breadcrumbs.length > 1) {
      this._backURL = this._breadcrumbs[this._breadcrumbs.length - 2].url;
      this._backShow = "inline";
      this._locationLabel = "";
    } else if (this._breadcrumbs.length === 1) {
      this._backShow = "none";
      this._locationLabel = this._breadcrumbs[
        this._breadcrumbs.length - 1
      ].label;
    } else {
      this._backShow = "none";
      this._locationLabel = "";
    }
  }
  /**
   * @private
   * @param {?} route
   * @param {?=} url
   * @param {?=} breadcrumbs
   * @return {?}
   */
  getBreadcrumbs(route, url = "", breadcrumbs = []) {
    /** @type {?} */
    const ROUTE_DATA_BREADCRUMB = "breadcrumb";
    // get the child routes
    /** @type {?} */
    let children = route.children;
    // return if there are no more children
    if (children.length === 0) {
      return breadcrumbs;
    }
    // iterate over each children
    for (let child of children) {
      // verify primary route
      if (child.outlet !== PRIMARY_OUTLET) {
        continue;
      }
      // verify the custom data property "breadcrumb" is specified on the route
      if (!child.snapshot.data.hasOwnProperty(ROUTE_DATA_BREADCRUMB)) {
        return this.getBreadcrumbs(child, url, breadcrumbs);
      }
      // get the route's URL segment
      /** @type {?} */
      let routeURL = child.snapshot.url
        .map(
          /**
           * @param {?} segment
           * @return {?}
           */
          (segment) => segment.path
        )
        .join("/");
      // append route URL to URL
      url += `/${routeURL}`;
      // add breadcrumb
      /** @type {?} */
      let parent = this.activatedRoute.parent;
      /** @type {?} */
      let fullURL = "";
      if (parent !== null) {
        fullURL +=
          "/" +
          parent.snapshot.url
            .map(
              /**
               * @param {?} segment
               * @return {?}
               */
              (segment) => segment.path
            )
            .join("/");
      }
      fullURL += `${url}`;
      /** @type {?} */
      let breadcrumb = {
        label: child.snapshot.data[ROUTE_DATA_BREADCRUMB],
        params: child.snapshot.params,
        url: fullURL,
      };
      breadcrumbs.push(breadcrumb);
      // recursive
      return this.getBreadcrumbs(child, url, breadcrumbs);
    }
    // we should never get here, but just in case
    return breadcrumbs;
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this._routerSubscription.unsubscribe();
  }
}
BreadcrumbsComponent.ɵfac = function BreadcrumbsComponent_Factory(t) {
  return new (t || BreadcrumbsComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.ActivatedRoute),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.Router)
  );
};
BreadcrumbsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: BreadcrumbsComponent,
  selectors: [["hc-breadcrumbs"]],
  inputs: { queryParamsHandling: "queryParamsHandling" },
  decls: 8,
  vars: 6,
  consts: [
    [1, "breadcrumb"],
    ["class", "breadcrumb-item", 4, "ngFor", "ngForOf"],
    [1, "breadcrumb-responsive-container"],
    [1, "breadcrumb-back-button", 3, "routerLink", "queryParamsHandling"],
    [1, "fa", "fa-chevron-left"],
    [3, "innerText"],
    [1, "breadcrumb-item"],
    [3, "routerLink", "queryParamsHandling", "innerText", 4, "ngIf"],
    [3, "innerText", 4, "ngIf"],
    [1, "fa", "fa-chevron-right", "breadcrumb-arrow"],
    [3, "routerLink", "queryParamsHandling", "innerText"],
  ],
  template: function BreadcrumbsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "ol", 0);
      ɵngcc0.ɵɵtemplate(1, BreadcrumbsComponent_li_1_Template, 4, 2, "li", 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵelementStart(3, "a", 3);
      ɵngcc0.ɵɵelement(4, "i", 4);
      ɵngcc0.ɵɵelementStart(5, "span");
      ɵngcc0.ɵɵtext(6, "\u00A0Back");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(7, "span", 5);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngForOf", ctx._breadcrumbs);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵstyleProp("display", ctx._backShow);
      ɵngcc0.ɵɵpropertyInterpolate(
        "queryParamsHandling",
        ctx.queryParamsHandling
      );
      ɵngcc0.ɵɵproperty("routerLink", ctx._backURL);
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("innerText", ctx._locationLabel);
    }
  },
  directives: [ɵngcc1.NgForOf, ɵngcc6.RouterLinkWithHref, ɵngcc1.NgIf],
  encapsulation: 2,
});
/** @nocollapse */
BreadcrumbsComponent.ctorParameters = () => [
  { type: ActivatedRoute },
  { type: Router },
];
BreadcrumbsComponent.propDecorators = {
  queryParamsHandling: [{ type: Input }],
};
if (false) {
  /** @type {?} */
  BreadcrumbsComponent.prototype._breadcrumbs;
  /** @type {?} */
  BreadcrumbsComponent.prototype._routerSubscription;
  /** @type {?} */
  BreadcrumbsComponent.prototype._backURL;
  /** @type {?} */
  BreadcrumbsComponent.prototype._backShow;
  /** @type {?} */
  BreadcrumbsComponent.prototype._locationLabel;
  /** @type {?} */
  BreadcrumbsComponent.prototype._queryParamsHandling;
  /**
   * @type {?}
   * @private
   */
  BreadcrumbsComponent.prototype.activatedRoute;
  /**
   * @type {?}
   * @private
   */
  BreadcrumbsComponent.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/breadcrumbs/breadcrumbs.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BreadcrumbsModule {}
BreadcrumbsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BreadcrumbsModule });
BreadcrumbsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function BreadcrumbsModule_Factory(t) {
    return new (t || BreadcrumbsModule)();
  },
  imports: [[CommonModule, RouterModule, IconModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/breadcrumbs/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/button/button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedStyles = [
  "primary",
  "primary-alt",
  "destructive",
  "neutral",
  "secondary",
  "minimal",
  "link",
  "link-inline",
];
/** @type {?} */
const supportedColors$2 = [
  "blue",
  "green",
  "purple",
  "red",
  "orange",
  "ruby-red",
  "deep-red",
  "red-orange",
  "magenta",
  "pink",
  "light-pink",
  "azure",
  "teal",
  "dark-green",
  "brown",
  "purple-gray",
  "yellow",
  "yellow-orange",
  "tan",
];
/** @type {?} */
const supportedSizes = ["sm", "md", "lg"];
/**
 * @param {?} style
 * @return {?}
 */
function validateStyleInput(style) {
  if (
    supportedStyles.indexOf(style) < 0 &&
    supportedColors$2.indexOf(style) < 0
  ) {
    throw Error(
      "Unsupported buttonStyle attribute value on ButtonComponent: " + style
    );
  }
}
/**
 * @param {?} size
 * @return {?}
 */
function validateSizeInput(size) {
  if (supportedSizes.indexOf(size) < 0) {
    throw Error("Unsupported size attribute value on ButtonComponent: " + size);
  }
}
/** @type {?} */
const buttonAttributes = ["hc-icon-button", "hc-button"];
/**
 * Cashmere styled button
 */
class ButtonComponent {
  /**
   * @param {?} elementRef
   * @param {?} renderer
   */
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
    this._disabled = false;
    this.buttonStyle = "primary";
    this.size = "md";
    for (const attr of buttonAttributes) {
      if (elementRef.nativeElement.hasAttribute(attr)) {
        renderer.addClass(elementRef.nativeElement, attr);
      }
    }
  }
  /**
   * @deprecated
   * \@description Use `buttonStyle` instead
   *
   * @return {?}
   */
  get color() {
    return this.buttonStyle;
  }
  /**
   * @param {?} btnStyle
   * @return {?}
   */
  set color(btnStyle) {
    this.buttonStyle = btnStyle;
  }
  /**
   * Sets style of button. Choose from: `'primary' | 'primary-alt' | 'destructive' |
   * 'neutral' | 'secondary' | 'minimal' | link' | 'link-inline'`. If needed, colors from
   * the primary or secondary palette may be used as well (e.g. 'pink', 'red-orange', etc)
   * @return {?}
   */
  get buttonStyle() {
    return this._style;
  }
  /**
   * @param {?} btnStyle
   * @return {?}
   */
  set buttonStyle(btnStyle) {
    validateStyleInput(btnStyle);
    if (supportedStyles.indexOf(btnStyle) < 0) {
      btnStyle = "button-" + btnStyle;
    }
    this.setHostClass(this._style, btnStyle);
    this._style = btnStyle;
  }
  /**
   * Sets size of button. Choose from: `'sm' | 'md' | 'lg' |`. *Defaults to `md`.*
   * @return {?}
   */
  get size() {
    return this._size;
  }
  /**
   * @param {?} size
   * @return {?}
   */
  set size(size) {
    validateSizeInput(size);
    this.setHostClass(this._size, size);
    this._size = size;
  }
  /**
   * Whether the control is disabled.
   * @return {?}
   */
  get disabled() {
    return this._disabled;
  }
  /**
   * @param {?} isDisabled
   * @return {?}
   */
  set disabled(isDisabled) {
    this._disabled = parseBooleanAttribute(isDisabled);
  }
  /**
   * Used to give focus to the button
   * @return {?}
   */
  focus() {
    this.elementRef.nativeElement.focus();
  }
  /**
   * @private
   * @param {?} previous
   * @param {?} current
   * @return {?}
   */
  setHostClass(previous, current) {
    if (previous !== current) {
      if (previous) {
        this.renderer.removeClass(
          this.elementRef.nativeElement,
          this._hcClassify(previous)
        );
      }
      this.renderer.addClass(
        this.elementRef.nativeElement,
        this._hcClassify(current)
      );
    }
  }
  /**
   * @private
   * @param {?} style
   * @return {?}
   */
  _hcClassify(style) {
    return `hc-${style}`;
  }
}
ButtonComponent.ɵfac = function ButtonComponent_Factory(t) {
  return new (t || ButtonComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)
  );
};
ButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ButtonComponent,
  selectors: [
    ["button", "hc-button", ""],
    ["button", "hc-icon-button", ""],
  ],
  hostVars: 1,
  hostBindings: function ButtonComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled || null);
    }
  },
  inputs: {
    buttonStyle: "buttonStyle",
    size: "size",
    color: "color",
    disabled: "disabled",
  },
  attrs: _c15,
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  styles: [_c16],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: Renderer2 },
];
ButtonComponent.propDecorators = {
  color: [{ type: Input }],
  buttonStyle: [{ type: Input }],
  size: [{ type: Input }],
  disabled: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  ButtonComponent.prototype._disabled;
  /**
   * @type {?}
   * @private
   */
  ButtonComponent.prototype._style;
  /**
   * @type {?}
   * @private
   */
  ButtonComponent.prototype._size;
  /** @type {?} */
  ButtonComponent.prototype.elementRef;
  /**
   * @type {?}
   * @private
   */
  ButtonComponent.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/button/anchor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* Cashmere button styled anchor */
class AnchorComponent extends ButtonComponent {
  /**
   * @param {?} elementRef
   * @param {?} renderer
   */
  constructor(elementRef, renderer) {
    super(elementRef, renderer);
  }
  /**
   * @return {?}
   */
  get _hostAriaDisabled() {
    return this.disabled ? this.disabled.toString() : "false";
  }
  /**
   * @return {?}
   */
  get _hostTabIndex() {
    return this.disabled ? -1 : 0;
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _handleClickEvents(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
}
AnchorComponent.ɵfac = function AnchorComponent_Factory(t) {
  return new (t || AnchorComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)
  );
};
AnchorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: AnchorComponent,
  selectors: [["a", "hc-button", ""]],
  hostVars: 2,
  hostBindings: function AnchorComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "click",
        function AnchorComponent_click_HostBindingHandler($event) {
          return ctx._handleClickEvents($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("aria-disabled", ctx._hostAriaDisabled)(
        "tabindex",
        ctx._hostTabIndex
      );
    }
  },
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  attrs: _c15,
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function AnchorComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  styles: [_c16],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
AnchorComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: Renderer2 },
];
AnchorComponent.propDecorators = {
  _hostAriaDisabled: [{ type: HostBinding, args: ["attr.aria-disabled"] }],
  _hostTabIndex: [{ type: HostBinding, args: ["attr.tabindex"] }],
  _handleClickEvents: [{ type: HostListener, args: ["click", ["$event"]] }],
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/button/split-button/split-button.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedStyles$1 = [
  "primary",
  "primary-alt",
  "destructive",
  "neutral",
  "secondary",
  "minimal",
  "link",
  "link-inline",
];
/**
 * SplitButton click event
 */
class SplitButtonClickEvent {
  /**
   * @param {?} source
   */
  constructor(source) {
    this.source = source;
  }
}
if (false) {
  /** @type {?} */
  SplitButtonClickEvent.prototype.source;
}
/**
 * Split button provides a primary action button along with a secondary menu of actions
 */
class SplitButtonComponent {
  /**
   * @param {?} elementRef
   */
  constructor(elementRef) {
    this.elementRef = elementRef;
    this._disabled = false;
    this._style = "primary";
    this._size = "md";
    /**
     * Primary button's click event
     */
    this.click = new EventEmitter();
    /**
     * Positioning for the menu. Possible values: 'start', 'end', 'center'
     */
    this.menuPosition = "end";
    /**
     * True if clicking anywhere in the menu should automatically close it.
     */
    this.autoCloseMenuOnClick = true;
    /**
     * Type of button. Possible values: 'submit', 'reset', 'button'
     */
    this.type = "button";
  }
  /**
   * Button tabindex
   * @return {?}
   */
  get tabIndex() {
    return this.disabled ? -1 : this._tabIndex;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tabIndex(value) {
    this._tabIndex = value == null ? 0 : value;
  }
  /**
   * @deprecated
   * \@description Use `buttonStyle` instead
   *
   * @return {?}
   */
  get color() {
    return this.buttonStyle;
  }
  /**
   * @param {?} btnStyle
   * @return {?}
   */
  set color(btnStyle) {
    this.buttonStyle = btnStyle;
  }
  /**
   * Sets style of button. Choose from: `'primary' | 'primary-alt' | 'destructive' |
   * 'neutral' | 'secondary' | 'minimal'`. If needed, colors from
   * the primary or secondary palette may be used as well (e.g. 'pink', 'red-orange', etc)
   * @return {?}
   */
  get buttonStyle() {
    return this._style;
  }
  /**
   * @param {?} btnStyle
   * @return {?}
   */
  set buttonStyle(btnStyle) {
    validateStyleInput(btnStyle);
    if (supportedStyles$1.indexOf(btnStyle) < 0) {
      btnStyle = "button-" + btnStyle;
    }
    this._style = btnStyle;
  }
  /**
   * Sets size of button. Choose from: `'sm' | 'md' | 'lg'`
   * @return {?}
   */
  get size() {
    return this._size;
  }
  /**
   * @param {?} size
   * @return {?}
   */
  set size(size) {
    validateSizeInput(size);
    this._size = size;
  }
  /**
   * Whether the control is disabled.
   * @return {?}
   */
  get disabled() {
    return this._disabled;
  }
  /**
   * @param {?} isDisabled
   * @return {?}
   */
  set disabled(isDisabled) {
    this._disabled = parseBooleanAttribute(isDisabled);
  }
  /**
   * @return {?}
   */
  get _hostClass() {
    return true;
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _stopClick($event) {
    $event.stopPropagation();
  }
  /**
   * Used to give focus to the button
   * @return {?}
   */
  focus() {
    this.elementRef.nativeElement.focus();
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _mainBtnClick(event) {
    event.stopPropagation();
    if (!this.disabled) {
      this.click.emit(new SplitButtonClickEvent(this));
    }
  }
  /**
   * Manually close the menu
   * @return {?}
   */
  closeMenu() {
    this._splitMenu.close();
  }
  /**
   * Manually open the menu
   * @return {?}
   */
  openMenu() {
    // pass menuItems on to the HcPop instance so that keyboard accessibility works
    if (this._splitMenu) {
      this._splitMenu._menuItems = this._menuItems;
    }
    this._splitMenu.open();
  }
}
SplitButtonComponent.ɵfac = function SplitButtonComponent_Factory(t) {
  return new (t || SplitButtonComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
SplitButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: SplitButtonComponent,
  selectors: [["hc-split-button"]],
  contentQueries: function SplitButtonComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._menuItems = _t);
    }
  },
  viewQuery: function SplitButtonComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c17, true);
      ɵngcc0.ɵɵviewQuery(_c18, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._splitBtnToggle = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._splitMenu = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function SplitButtonComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-split-button", ctx._hostClass);
    }
  },
  inputs: {
    menuPosition: "menuPosition",
    autoCloseMenuOnClick: "autoCloseMenuOnClick",
    type: "type",
    tabIndex: "tabIndex",
    color: "color",
    buttonStyle: "buttonStyle",
    size: "size",
    disabled: "disabled",
    title: "title",
    name: "name",
    value: "value",
  },
  outputs: { click: "click" },
  ngContentSelectors: _c20,
  decls: 9,
  vars: 15,
  consts: [
    ["trigger", "none", 1, "hc-split-button-wrap", 3, "hcPop"],
    [
      "hc-button",
      "",
      1,
      "hc-split-button-main",
      3,
      "buttonStyle",
      "size",
      "tabIndex",
      "disabled",
      "click",
    ],
    [
      "hc-button",
      "",
      "type",
      "button",
      "trigger",
      "none",
      1,
      "hc-split-button-toggle",
      3,
      "buttonStyle",
      "size",
      "disabled",
      "click",
    ],
    ["splitBtnToggle", ""],
    [3, "xAlign", "autoCloseOnContentClick", "showArrow"],
    ["splitMenu", ""],
    ["hcMenu", ""],
  ],
  template: function SplitButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c19);
      ɵngcc0.ɵɵelementStart(0, "span", 0);
      ɵngcc0.ɵɵelementStart(1, "button", 1);
      ɵngcc0.ɵɵlistener(
        "click",
        function SplitButtonComponent_Template_button_click_1_listener($event) {
          return ctx._mainBtnClick($event);
        }
      );
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(3, "button", 2, 3);
      ɵngcc0.ɵɵlistener(
        "click",
        function SplitButtonComponent_Template_button_click_3_listener($event) {
          ctx._stopClick($event);
          return ctx.openMenu();
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(5, "hc-pop", 4, 5);
      ɵngcc0.ɵɵelementStart(7, "div", 6);
      ɵngcc0.ɵɵprojection(8, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r1 = ɵngcc0.ɵɵreference(6);
      ɵngcc0.ɵɵproperty("hcPop", _r1);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("buttonStyle", ctx.buttonStyle)("size", ctx.size)(
        "tabIndex",
        ctx.tabIndex
      )("disabled", ctx.disabled);
      ɵngcc0.ɵɵattribute("type", ctx.type)("title", ctx.title)(
        "name",
        ctx.name
      )("value", ctx.value);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("buttonStyle", ctx.buttonStyle)("size", ctx.size)(
        "disabled",
        ctx.disabled
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("xAlign", ctx.menuPosition)(
        "autoCloseOnContentClick",
        ctx.autoCloseMenuOnClick
      )("showArrow", false);
    }
  },
  directives: [
    HcPopoverAnchorDirective,
    ButtonComponent,
    HcPopComponent,
    MenuDirective,
  ],
  styles: [
    _c16,
    ".hc-split-button,.hc-split-button .hc-split-button-wrap{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle{min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
SplitButtonComponent.ctorParameters = () => [{ type: ElementRef }];
SplitButtonComponent.propDecorators = {
  _splitBtnToggle: [
    { type: ViewChild, args: ["splitBtnToggle", { static: false }] },
  ],
  _splitMenu: [{ type: ViewChild, args: ["splitMenu", { static: false }] }],
  _menuItems: [
    { type: ContentChildren, args: [MenuItemDirective, { descendants: true }] },
  ],
  click: [{ type: Output }],
  title: [{ type: Input }],
  menuPosition: [{ type: Input }],
  autoCloseMenuOnClick: [{ type: Input }],
  type: [{ type: Input }],
  name: [{ type: Input }],
  value: [{ type: Input }],
  tabIndex: [{ type: Input }],
  color: [{ type: Input }],
  buttonStyle: [{ type: Input }],
  size: [{ type: Input }],
  disabled: [{ type: Input }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-split-button"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  SplitButtonComponent.prototype._tabIndex;
  /**
   * @type {?}
   * @private
   */
  SplitButtonComponent.prototype._disabled;
  /**
   * @type {?}
   * @private
   */
  SplitButtonComponent.prototype._style;
  /**
   * @type {?}
   * @private
   */
  SplitButtonComponent.prototype._size;
  /** @type {?} */
  SplitButtonComponent.prototype._splitBtnToggle;
  /** @type {?} */
  SplitButtonComponent.prototype._splitMenu;
  /** @type {?} */
  SplitButtonComponent.prototype._menuItems;
  /**
   * Primary button's click event
   * @type {?}
   */
  SplitButtonComponent.prototype.click;
  /**
   * Additional information shown as tooltip
   * @type {?}
   */
  SplitButtonComponent.prototype.title;
  /**
   * Positioning for the menu. Possible values: 'start', 'end', 'center'
   * @type {?}
   */
  SplitButtonComponent.prototype.menuPosition;
  /**
   * True if clicking anywhere in the menu should automatically close it.
   * @type {?}
   */
  SplitButtonComponent.prototype.autoCloseMenuOnClick;
  /**
   * Type of button. Possible values: 'submit', 'reset', 'button'
   * @type {?}
   */
  SplitButtonComponent.prototype.type;
  /**
   * Used as a reference in JavaScript, or to reference form data after a form is submitted
   * @type {?}
   */
  SplitButtonComponent.prototype.name;
  /**
   * Value of primary button when submitted within a form
   * @type {?}
   */
  SplitButtonComponent.prototype.value;
  /**
   * @type {?}
   * @private
   */
  SplitButtonComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/button/button.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonModule {}
ButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ButtonModule });
ButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ButtonModule_Factory(t) {
    return new (t || ButtonModule)();
  },
  imports: [[CommonModule, PopModule], PopModule],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/button/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-form-control.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Wrapper component that textual form controls extend to work with hc-form-field
 * @abstract
 */
class HcFormControlComponent {
  constructor() {
    /**
     * Whether the control should be displaying an associated error
     */
    this._errorState = false;
    /**
     * An error message to be shown in the UI when there is an error state present
     */
    this._errorMessage = "";
    /**
     * An object that represents the Angular validation errors that are present on the form
     */
    this._errors = {};
    /**
     * Whether the control is disabled
     */
    this._isDisabled = false;
    /**
     * Whether the control is required
     */
    this._isRequired = false;
    /**
     * Whether the control should apply tight styling
     */
    this.tight = false;
  }
}
HcFormControlComponent.ɵfac = function HcFormControlComponent_Factory(t) {
  return new (t || HcFormControlComponent)();
};
HcFormControlComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcFormControlComponent,
});
if (false) {
  /**
   * Whether the control should be displaying an associated error
   * @type {?}
   */
  HcFormControlComponent.prototype._errorState;
  /**
   * An error message to be shown in the UI when there is an error state present
   * @type {?}
   */
  HcFormControlComponent.prototype._errorMessage;
  /**
   * An object that represents the Angular validation errors that are present on the form
   * @type {?}
   */
  HcFormControlComponent.prototype._errors;
  /**
   * Whether the control is disabled
   * @type {?}
   */
  HcFormControlComponent.prototype._isDisabled;
  /**
   * ID identifier of the the control
   * @type {?}
   */
  HcFormControlComponent.prototype._componentId;
  /**
   * Whether the control is required
   * @type {?}
   */
  HcFormControlComponent.prototype._isRequired;
  /**
   * Whether the control should apply tight styling
   * @type {?}
   */
  HcFormControlComponent.prototype.tight;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/checkbox/checkbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextCheckboxId = 1;
class CheckboxChangeEvent {
  /**
   * @param {?} source
   * @param {?} checked
   */
  constructor(source, checked) {
    this.source = source;
    this.checked = checked;
  }
}
if (false) {
  /** @type {?} */
  CheckboxChangeEvent.prototype.source;
  /** @type {?} */
  CheckboxChangeEvent.prototype.checked;
}
class CheckboxGroup extends HcFormControlComponent {
  constructor() {
    super(...arguments);
    this._groupState = false;
    this._parentLabel = "Parent Checkbox";
    this._disableParent = false;
    this._isIndeterminate = true;
  }
  /**
   * gets all children and subscribes to their events
   * @return {?}
   */
  get checkboxes() {
    return this._checkboxes;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set checkboxes(value) {
    if (value) {
      this._checkboxes = value;
      /** @type {?} */
      const arr = value.toArray() || [];
      this._checkboxesArray = arr;
      arr.forEach(
        /**
         * @param {?} c
         * @return {?}
         */
        (c) =>
          c.change
            .pipe(
              filter(
                /**
                 * @return {?}
                 */
                () => this._checkboxesArray === arr
              )
            )
            .subscribe(
              /**
               * @return {?}
               */
              () => this.updateParentState()
            )
      );
    }
  }
  /**
   * Input to disable the Parent button *Defaults to `false`.*
   * @return {?}
   */
  get disableParent() {
    return this._disableParent;
  }
  /**
   * @param {?} disableParent
   * @return {?}
   */
  set disableParent(disableParent) {
    this._disableParent = disableParent;
  }
  /**
   * Input to change the label for the parent checkbox *Defaults to 'Parent Checkbox'*
   * @return {?}
   */
  get parentLabel() {
    return this._parentLabel;
  }
  /**
   * @param {?} parentLabel
   * @return {?}
   */
  set parentLabel(parentLabel) {
    this._parentLabel = parentLabel;
  }
  /**
   * Function to handle the indeterminate checkbox
   * @return {?}
   */
  updateParentState() {
    if (this.checkboxes) {
      /** @type {?} */
      const checkedCount = this.checkboxes.filter(
        /**
         * @param {?} c
         * @return {?}
         */
        (c) => c.checked
      ).length;
      if (checkedCount === this.checkboxes.length) {
        this._groupState = true;
        this._isIndeterminate = false;
      } else if (checkedCount === 0) {
        this._groupState = false;
        this._isIndeterminate = false;
      } else {
        this._groupState = false;
        this._isIndeterminate = true;
      }
    }
  }
  /**
   * Function to return all checkboxes
   * @return {?}
   */
  getSelected() {
    if (this.checkboxes) {
      return this.checkboxes.filter(
        /**
         * @param {?} c
         * @return {?}
         */
        (c) => c.checked
      );
    }
    return [];
  }
  /**
   * Function that handles the parent checkbox functionality
   * @return {?}
   */
  toggleCheckAll() {
    if (this._groupState === true) {
      this.checkboxes.filter(
        /**
         * @param {?} c
         * @return {?}
         */
        (c) => (c.checked = false)
      );
    } else {
      this.checkboxes.filter(
        /**
         * @param {?} c
         * @return {?}
         */
        (c) => (c.checked = true)
      );
    }
    this.updateParentState();
  }
}
CheckboxGroup.ɵfac = function CheckboxGroup_Factory(t) {
  return ɵCheckboxGroup_BaseFactory(t || CheckboxGroup);
};
CheckboxGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CheckboxGroup,
  selectors: [["hc-checkbox-group"]],
  contentQueries: function CheckboxGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, CheckboxComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.checkboxes = _t);
    }
  },
  inputs: { disableParent: "disableParent", parentLabel: "parentLabel" },
  exportAs: ["hcCheckboxGroup"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => CheckboxGroup
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  ngContentSelectors: _c3,
  decls: 3,
  vars: 3,
  consts: [
    [3, "checked", "indeterminate", "change", 4, "ngIf"],
    [3, "checked", "indeterminate", "change"],
  ],
  template: function CheckboxGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(
        0,
        CheckboxGroup_hc_checkbox_0_Template,
        2,
        3,
        "hc-checkbox",
        0
      );
      ɵngcc0.ɵɵelementStart(1, "div");
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", !ctx._disableParent);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassProp("hc-checkbox-children-group", !ctx._disableParent);
    }
  },
  directives: function () {
    return [ɵngcc1.NgIf, CheckboxComponent];
  },
  styles: [
    ".hc-checkbox-container[_ngcontent-%COMP%]{display:-webkit-box;display:flex}.hc-checkbox-container[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%]{display:none}.hc-checkbox-content[_ngcontent-%COMP%]{display:-webkit-inline-box;display:inline-flex;cursor:pointer}.hc-checkbox-content[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{cursor:pointer}.hc-checkbox-disabled[_ngcontent-%COMP%]   .hc-checkbox-content[_ngcontent-%COMP%]{color:#ccc;cursor:not-allowed}.hc-checkbox-disabled[_ngcontent-%COMP%]   .hc-checkbox-content[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{cursor:not-allowed}.hc-checkbox-children-group[_ngcontent-%COMP%]{margin-left:25px;margin-top:5px}.hc-checkbox-align-center[_ngcontent-%COMP%]{-webkit-box-align:center;align-items:center}.hc-checkbox-align-top[_ngcontent-%COMP%]{-webkit-box-align:start;align-items:flex-start}.hc-checkbox-align-bottom[_ngcontent-%COMP%]{-webkit-box-align:end;align-items:flex-end}.hc-checkbox-label[_ngcontent-%COMP%]{padding:4px 0 4px 34px;line-height:1.5;margin-left:-22px}.hc-checkbox-tight[_ngcontent-%COMP%]   .hc-checkbox-label[_ngcontent-%COMP%]{padding:2px 0 2px 26px;font-size:.92857rem;margin-left:-18px}.hc-checkbox-align-label-top[_ngcontent-%COMP%]{padding-top:0!important;margin-top:-3px}.hc-checkbox-align-label-bottom[_ngcontent-%COMP%]{padding-bottom:0!important;margin-bottom:-3px}.hc-checkbox-overlay[_ngcontent-%COMP%]{position:relative;width:22px;height:22px;min-width:22px;background-color:#fff;border:1px solid #c0c5cc;border-radius:3px}.hc-checkbox-overlay[_ngcontent-%COMP%]:after{content:'';position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5BcnRib2FyZCAxPC90aXRsZT48cGF0aCBpZD0iUGF0aF8xMjIyMSIgZGF0YS1uYW1lPSJQYXRoIDEyMjIxIiBjbGFzcz0iY2xzLTEiIGQ9Ik0yOCw5Ljc2YTEuNjYsMS42NiwwLDAsMC0uNDYtMS4xNEwyNS4yMyw2LjM1YTEuNjIsMS42MiwwLDAsMC0yLjI4LDBsLTExLDExTDcuMDUsMTIuNDFhMS42MiwxLjYyLDAsMCwwLTIuMjgsMEwyLjQ5LDE0LjY4QTEuNjcsMS42NywwLDAsMCwyLDE1LjgyLDEuNjYsMS42NiwwLDAsMCwyLjQ5LDE3TDguNTUsMjNsMi4yOCwyLjI4YTEuNjEsMS42MSwwLDAsMCwxLjE0LjQ3LDEuNjMsMS42MywwLDAsMCwxLjE0LS40N0wxNS4zOSwyMywyNy41MSwxMC45QTEuNiwxLjYsMCwwLDAsMjgsOS43NloiLz48L3N2Zz4=);top:1px;left:1px;width:15.5px;height:15.5px;opacity:0}.hc-checkbox-tight[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]{width:18px;height:18px;min-width:18px}.hc-checkbox-tight[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]:after{top:.5px;left:.5px;width:12.5px;height:12.5px}.hc-checkbox-content[_ngcontent-%COMP%]:hover   .hc-checkbox-overlay[_ngcontent-%COMP%]{border:1px solid #00aeff;background-color:#f2fbff}.hc-checkbox-indeterminate[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]:after{opacity:1;top:4px;left:4px;width:12px;height:7px;border-bottom:3px solid #ccc;background-image:none}.hc-checkbox-indeterminate[_ngcontent-%COMP%]   .hc-checkbox-tight[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]:after{top:1.5px;width:8px}input[type=checkbox][_ngcontent-%COMP%]:checked + .hc-checkbox-overlay[_ngcontent-%COMP%]{background-color:#00aeff;border:2px solid #00aeff}input[type=checkbox][_ngcontent-%COMP%]:checked + .hc-checkbox-overlay[_ngcontent-%COMP%]:after{opacity:1}.hc-checkbox-disabled[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%] + .hc-checkbox-overlay[_ngcontent-%COMP%]{background-color:#e0e0e0;border:1px solid #ccc}.hc-checkbox-disabled[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%] + .hc-checkbox-overlay[_ngcontent-%COMP%]:after{top:2px;left:2px}.hc-checkbox-disabled[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%] + .hc-checkbox-overlay[_ngcontent-%COMP%]:focus{box-shadow:none}.hc-checkbox-overlay[_ngcontent-%COMP%]:focus{outline:0;box-shadow:0 0 5px #00aeff}.hc-form-field-invalid[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]{border-color:#cc2027!important}.hc-form-field-invalid[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]:focus{box-shadow:0 0 5px #cc2027}.hc-form-field-invalid[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%]:checked + .hc-checkbox-overlay[_ngcontent-%COMP%]{background-color:#cc2027}.hc-checkbox-stub[_ngcontent-%COMP%]   .hc-checkbox-label[_ngcontent-%COMP%], .hc-checkbox-stub[_ngcontent-%COMP%]   .hc-checkbox-overlay[_ngcontent-%COMP%]{pointer-events:none}",
  ],
});
CheckboxGroup.propDecorators = {
  checkboxes: [
    {
      type: ContentChildren,
      args: [
        forwardRef(
          /**
           * @return {?}
           */
          () => CheckboxComponent
        ),
        { descendants: false },
      ],
    },
  ],
  disableParent: [{ type: Input }],
  parentLabel: [{ type: Input }],
};
if (false) {
  /**
   * A list of all the checkboxes included in the group
   * @type {?}
   * @private
   */
  CheckboxGroup.prototype._checkboxes;
  /**
   * @type {?}
   * @private
   */
  CheckboxGroup.prototype._checkboxesArray;
  /** @type {?} */
  CheckboxGroup.prototype._groupState;
  /** @type {?} */
  CheckboxGroup.prototype._parentLabel;
  /** @type {?} */
  CheckboxGroup.prototype._disableParent;
  /** @type {?} */
  CheckboxGroup.prototype._isIndeterminate;
}
class CheckboxComponent extends HcFormControlComponent {
  /**
   * @param {?} tabindex
   * @param {?} _renderer
   * @param {?} _elementRef
   * @param {?} _parentForm
   * @param {?} _parentFormGroup
   * @param {?} checkboxGroup
   * @param {?} _ngControl
   */
  constructor(
    tabindex,
    _renderer,
    _elementRef,
    _parentForm,
    _parentFormGroup,
    checkboxGroup,
    _ngControl
  ) {
    super();
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this._ngControl = _ngControl;
    this._uniqueId = `hc-checkbox-${nextCheckboxId++}`;
    this._checked = false;
    this._tight = false;
    this._parent = false;
    this._componentId = this._uniqueId;
    /**
     * If true, the checkbox is for display purposes (not user interaction). As such its checked/unchecked state
     * can only be controlled programatically. Useful for embedding in an ng-select typeahead
     */
    this.isStub = false;
    /**
     * Sets the position of the checkbox relative to its associated label. *Defaults to `center`.*
     */
    this.align = "center";
    /**
     * Sets unique name used in a form
     */
    this.name = null;
    /**
     * Event emitted whenever the state changes
     */
    this.change = new EventEmitter();
    this._onChangeFunc =
      /**
       * @return {?}
       */
      () => {};
    this._onTouchFunc =
      /**
       * @return {?}
       */
      () => {};
    this.checkboxGroup = checkboxGroup;
    this.tabIndex = parseInt(tabindex, 10) || 0;
    this._form = _parentForm || _parentFormGroup;
    if (this._ngControl != null) {
      this._ngControl.valueAccessor = this;
    }
  }
  /**
   * Unique id for the checkbox element. If none is supplied, one will be auto-generated.
   * @return {?}
   */
  get id() {
    return this._componentId || this._uniqueId;
  }
  /**
   * @param {?} idVal
   * @return {?}
   */
  set id(idVal) {
    this._componentId = idVal ? idVal : this._uniqueId;
  }
  /**
   * If true, condense the default margin and reduce the font size. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
  }
  /**
   * @return {?}
   */
  get _getHostId() {
    return this.id;
  }
  /**
   * @return {?}
   */
  get _getCheckboxCheckedClass() {
    return this.checked;
  }
  /**
   * @return {?}
   */
  get _getCheckboxDisabledClass() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @return {?}
   */
  get _getCheckboxIndeterminateClass() {
    return this.indeterminate;
  }
  /**
   * Whether the checkbox is required.
   * @return {?}
   */
  get required() {
    return this._isRequired;
  }
  /**
   * @param {?} requiredVal
   * @return {?}
   */
  set required(requiredVal) {
    this._isRequired = parseBooleanAttribute(requiredVal);
  }
  /**
   * Whether the checkbox is disabled.
   * @return {?}
   */
  get disabled() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @param {?} disabledVal
   * @return {?}
   */
  set disabled(disabledVal) {
    this._isDisabled = parseBooleanAttribute(disabledVal);
  }
  /**
   * Whether the checkbox is checked.
   * @return {?}
   */
  get checked() {
    return this._checked;
  }
  /**
   * @param {?} checked
   * @return {?}
   */
  set checked(checked) {
    if (this._checked === checked) {
      return;
    }
    this._checked = checked;
  }
  /**
   * Whether the checkbox is a parent.
   * @return {?}
   */
  get parent() {
    return this._parent;
  }
  /**
   * @param {?} parent
   * @return {?}
   */
  set parent(parent) {
    this._parent = parseBooleanAttribute(parent);
  }
  /**
   * TabIndex attribute of native checkbox
   * @return {?}
   */
  get tabIndex() {
    return this._isDisabled ? -1 : this._tabIndex;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tabIndex(value) {
    this._tabIndex = value == null ? 0 : value;
  }
  /**
   * @return {?}
   */
  get _inputId() {
    return `${this.id || this._uniqueId}-input`;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  writeValue(value) {
    this.checked = !!value;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnChange(fn) {
    this._onChangeFunc = fn;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnTouched(fn) {
    this._onTouchFunc = fn;
  }
  /**
   * @param {?} disabledVal
   * @return {?}
   */
  setDisabledState(disabledVal) {
    this.disabled = disabledVal;
    this._renderer.setProperty(
      this._checkboxInput.nativeElement,
      "disabled",
      disabledVal
    );
  }
  /**
   * Toggles the current checked state of the checkbox
   * @return {?}
   */
  toggle() {
    this.checked = !this.checked;
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _clickEvent(event) {
    event.stopPropagation(); // prevent native click event from being dispatched
    if (!this.disabled) {
      if (this.checkboxGroup && this._parent) {
        this.checkboxGroup.toggleCheckAll();
      }
      this.toggle();
      this._emitChangeEvent();
    }
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _stopChangeEvent(event) {
    event.stopPropagation(); // prevent native change event from emitting its own object through output 'change'
  }
  /**
   * @private
   * @return {?}
   */
  _emitChangeEvent() {
    this._onChangeFunc(this.checked);
    this.change.emit(new CheckboxChangeEvent(this, this.checked));
  }
  /**
   * @return {?}
   */
  _onBlur() {
    this._onTouchFunc();
  }
  /**
   * @return {?}
   */
  ngDoCheck() {
    // This needs to be checked every cycle because we can't subscribe to form submissions
    if (this._ngControl) {
      this._updateErrorState();
    }
  }
  /**
   * @private
   * @return {?}
   */
  _updateErrorState() {
    /** @type {?} */
    const oldState = this._errorState;
    // TODO: this could be abstracted out as an @Input() if we need this to be configurable
    /** @type {?} */
    const newState = !!(
      this._ngControl &&
      this._ngControl.invalid &&
      (this._ngControl.touched || (this._form && this._form.submitted))
    );
    if (oldState !== newState) {
      this._errorState = newState;
    }
  }
}
CheckboxComponent.ɵfac = function CheckboxComponent_Factory(t) {
  return new (t || CheckboxComponent)(
    ɵngcc0.ɵɵinjectAttribute("tabindex"),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgForm, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FormGroupDirective, 8),
    ɵngcc0.ɵɵdirectiveInject(CheckboxGroup, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgControl, 10)
  );
};
CheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CheckboxComponent,
  selectors: [["hc-checkbox"]],
  viewQuery: function CheckboxComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵstaticViewQuery(_c21, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._checkboxInput = _t.first);
    }
  },
  hostVars: 7,
  hostBindings: function CheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("id", ctx._getHostId);
      ɵngcc0.ɵɵclassProp("hc-checkbox-checked", ctx._getCheckboxCheckedClass)(
        "hc-checkbox-disabled",
        ctx._getCheckboxDisabledClass
      )("hc-checkbox-indeterminate", ctx._getCheckboxIndeterminateClass);
    }
  },
  inputs: {
    isStub: "isStub",
    align: "align",
    name: "name",
    id: "id",
    tight: "tight",
    required: "required",
    disabled: "disabled",
    checked: "checked",
    parent: "parent",
    value: "value",
    indeterminate: "indeterminate",
  },
  outputs: { change: "change" },
  exportAs: ["hcCheckbox"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => CheckboxComponent
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  ngContentSelectors: _c3,
  decls: 7,
  vars: 16,
  consts: [
    [1, "hc-checkbox-container"],
    [1, "hc-checkbox-content", 3, "ngClass"],
    [
      "type",
      "checkbox",
      3,
      "id",
      "indeterminate",
      "disabled",
      "required",
      "checked",
      "change",
      "click",
      "blur",
    ],
    ["checkboxInput", ""],
    [1, "hc-checkbox-overlay", 3, "tabIndex", "keydown.space"],
    [1, "hc-checkbox-label", 3, "ngClass"],
  ],
  template: function CheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵelementStart(2, "input", 2, 3);
      ɵngcc0.ɵɵlistener(
        "change",
        function CheckboxComponent_Template_input_change_2_listener($event) {
          return ctx._stopChangeEvent($event);
        }
      )("click", function CheckboxComponent_Template_input_click_2_listener(
        $event
      ) {
        return ctx._clickEvent($event);
      })("blur", function CheckboxComponent_Template_input_blur_2_listener() {
        return ctx._onBlur();
      });
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(4, "label", 4);
      ɵngcc0.ɵɵlistener(
        "keydown.space",
        function CheckboxComponent_Template_label_keydown_space_4_listener(
          $event
        ) {
          ctx._clickEvent($event);
          return $event.preventDefault();
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(5, "label", 5);
      ɵngcc0.ɵɵprojection(6);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-checkbox-stub", ctx.isStub);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassProp("hc-checkbox-tight", ctx.tight);
      ɵngcc0.ɵɵproperty("ngClass", "hc-checkbox-align-" + ctx.align);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("id", ctx._inputId)("indeterminate", ctx.indeterminate)(
        "disabled",
        ctx.disabled
      )("required", ctx.required)("checked", ctx.checked);
      ɵngcc0.ɵɵattribute("value", ctx.value)("name", ctx.name);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("tabIndex", ctx.tabIndex);
      ɵngcc0.ɵɵattribute("for", ctx._inputId);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngClass", "hc-checkbox-align-label-" + ctx.align);
      ɵngcc0.ɵɵattribute("for", ctx._inputId);
    }
  },
  directives: [ɵngcc1.NgClass],
  styles: [
    ".hc-checkbox-container{display:-webkit-box;display:flex}.hc-checkbox-container input[type=checkbox]{display:none}.hc-checkbox-content{display:-webkit-inline-box;display:inline-flex;cursor:pointer}.hc-checkbox-content label{cursor:pointer}.hc-checkbox-disabled .hc-checkbox-content{color:#ccc;cursor:not-allowed}.hc-checkbox-disabled .hc-checkbox-content label{cursor:not-allowed}.hc-checkbox-children-group{margin-left:25px;margin-top:5px}.hc-checkbox-align-center{-webkit-box-align:center;align-items:center}.hc-checkbox-align-top{-webkit-box-align:start;align-items:flex-start}.hc-checkbox-align-bottom{-webkit-box-align:end;align-items:flex-end}.hc-checkbox-label{padding:4px 0 4px 34px;line-height:1.5;margin-left:-22px}.hc-checkbox-tight .hc-checkbox-label{padding:2px 0 2px 26px;font-size:.92857rem;margin-left:-18px}.hc-checkbox-align-label-top{padding-top:0!important;margin-top:-3px}.hc-checkbox-align-label-bottom{padding-bottom:0!important;margin-bottom:-3px}.hc-checkbox-overlay{position:relative;width:22px;height:22px;min-width:22px;background-color:#fff;border:1px solid #c0c5cc;border-radius:3px}.hc-checkbox-overlay:after{content:'';position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5BcnRib2FyZCAxPC90aXRsZT48cGF0aCBpZD0iUGF0aF8xMjIyMSIgZGF0YS1uYW1lPSJQYXRoIDEyMjIxIiBjbGFzcz0iY2xzLTEiIGQ9Ik0yOCw5Ljc2YTEuNjYsMS42NiwwLDAsMC0uNDYtMS4xNEwyNS4yMyw2LjM1YTEuNjIsMS42MiwwLDAsMC0yLjI4LDBsLTExLDExTDcuMDUsMTIuNDFhMS42MiwxLjYyLDAsMCwwLTIuMjgsMEwyLjQ5LDE0LjY4QTEuNjcsMS42NywwLDAsMCwyLDE1LjgyLDEuNjYsMS42NiwwLDAsMCwyLjQ5LDE3TDguNTUsMjNsMi4yOCwyLjI4YTEuNjEsMS42MSwwLDAsMCwxLjE0LjQ3LDEuNjMsMS42MywwLDAsMCwxLjE0LS40N0wxNS4zOSwyMywyNy41MSwxMC45QTEuNiwxLjYsMCwwLDAsMjgsOS43NloiLz48L3N2Zz4=);top:1px;left:1px;width:15.5px;height:15.5px;opacity:0}.hc-checkbox-tight .hc-checkbox-overlay{width:18px;height:18px;min-width:18px}.hc-checkbox-tight .hc-checkbox-overlay:after{top:.5px;left:.5px;width:12.5px;height:12.5px}.hc-checkbox-content:hover .hc-checkbox-overlay{border:1px solid #00aeff;background-color:#f2fbff}.hc-checkbox-indeterminate .hc-checkbox-overlay:after{opacity:1;top:4px;left:4px;width:12px;height:7px;border-bottom:3px solid #ccc;background-image:none}.hc-checkbox-indeterminate .hc-checkbox-tight .hc-checkbox-overlay:after{top:1.5px;width:8px}input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#00aeff;border:2px solid #00aeff}input[type=checkbox]:checked+.hc-checkbox-overlay:after{opacity:1}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay{background-color:#e0e0e0;border:1px solid #ccc}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:after{top:2px;left:2px}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:focus{box-shadow:none}.hc-checkbox-overlay:focus{outline:0;box-shadow:0 0 5px #00aeff}.hc-form-field-invalid .hc-checkbox-overlay{border-color:#cc2027!important}.hc-form-field-invalid .hc-checkbox-overlay:focus{box-shadow:0 0 5px #cc2027}.hc-form-field-invalid input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#cc2027}.hc-checkbox-stub .hc-checkbox-label,.hc-checkbox-stub .hc-checkbox-overlay{pointer-events:none}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
  { type: String, decorators: [{ type: Attribute, args: ["tabindex"] }] },
  { type: Renderer2 },
  { type: ElementRef },
  { type: NgForm, decorators: [{ type: Optional }] },
  { type: FormGroupDirective, decorators: [{ type: Optional }] },
  { type: CheckboxGroup, decorators: [{ type: Optional }] },
  { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
];
CheckboxComponent.propDecorators = {
  value: [{ type: Input }],
  indeterminate: [{ type: Input }],
  isStub: [{ type: Input }],
  id: [{ type: Input }],
  tight: [{ type: Input }],
  align: [{ type: Input }],
  name: [{ type: Input }],
  change: [{ type: Output }],
  _checkboxInput: [
    { type: ViewChild, args: ["checkboxInput", { static: true }] },
  ],
  _getHostId: [{ type: HostBinding, args: ["attr.id"] }],
  _getCheckboxCheckedClass: [
    { type: HostBinding, args: ["class.hc-checkbox-checked"] },
  ],
  _getCheckboxDisabledClass: [
    { type: HostBinding, args: ["class.hc-checkbox-disabled"] },
  ],
  _getCheckboxIndeterminateClass: [
    { type: HostBinding, args: ["class.hc-checkbox-indeterminate"] },
  ],
  required: [{ type: Input }],
  disabled: [{ type: Input }],
  checked: [{ type: Input }],
  parent: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._uniqueId;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._form;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._checked;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._tabIndex;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._parent;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype.checkboxGroup;
  /** @type {?} */
  CheckboxComponent.prototype._componentId;
  /**
   * Value attribute of the native checkbox
   * @type {?}
   */
  CheckboxComponent.prototype.value;
  /**
   * Whether the checkbox is indeterminate. It can represent a checkbox with three states.
   * @type {?}
   */
  CheckboxComponent.prototype.indeterminate;
  /**
   * If true, the checkbox is for display purposes (not user interaction). As such its checked/unchecked state
   * can only be controlled programatically. Useful for embedding in an ng-select typeahead
   * @type {?}
   */
  CheckboxComponent.prototype.isStub;
  /**
   * Sets the position of the checkbox relative to its associated label. *Defaults to `center`.*
   * @type {?}
   */
  CheckboxComponent.prototype.align;
  /**
   * Sets unique name used in a form
   * @type {?}
   */
  CheckboxComponent.prototype.name;
  /**
   * Event emitted whenever the state changes
   * @type {?}
   */
  CheckboxComponent.prototype.change;
  /** @type {?} */
  CheckboxComponent.prototype._checkboxInput;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._onChangeFunc;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._onTouchFunc;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._renderer;
  /**
   * @type {?}
   * @private
   */
  CheckboxComponent.prototype._elementRef;
  /** @type {?} */
  CheckboxComponent.prototype._ngControl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/checkbox/checkbox-required.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const HC_CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(
    /**
     * @return {?}
     */
    () => HcCheckboxRequiredValidatorDirective
  ),
  multi: true,
};
/**
 * \@docs-private
 */
class HcCheckboxRequiredValidatorDirective extends CheckboxRequiredValidator {
  /**
   * @return {?}
   */
  get isRequired() {
    return this.required ? "" : null;
  }
}
HcCheckboxRequiredValidatorDirective.ɵfac = function HcCheckboxRequiredValidatorDirective_Factory(
  t
) {
  return ɵHcCheckboxRequiredValidatorDirective_BaseFactory(
    t || HcCheckboxRequiredValidatorDirective
  );
};
HcCheckboxRequiredValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcCheckboxRequiredValidatorDirective,
  selectors: [
    ["hc-checkbox", "required", "", "formControlName", ""],
    ["hc-checkbox", "required", "", "formControl", ""],
    ["hc-checkbox", "required", "", "ngModel", ""],
  ],
  hostVars: 1,
  hostBindings: function HcCheckboxRequiredValidatorDirective_HostBindings(
    rf,
    ctx
  ) {
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("required", ctx.isRequired);
    }
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([HC_CHECKBOX_REQUIRED_VALIDATOR]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
HcCheckboxRequiredValidatorDirective.propDecorators = {
  isRequired: [{ type: HostBinding, args: ["attr.required"] }],
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/checkbox/checkbox.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxModule {}
CheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CheckboxModule });
CheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function CheckboxModule_Factory(t) {
    return new (t || CheckboxModule)();
  },
  imports: [[CommonModule, FormsModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/checkbox/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip/chip.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedColors$3 = ["neutral", "yellow", "green", "red"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateColorInput$2(inputStr) {
  if (supportedColors$3.indexOf(inputStr) < 0) {
    throw Error("Unsupported chip color value: " + inputStr);
  }
}
/**
 * Chips represent complex entities in small blocks, such as filters, contacts, or system information
 */
class ChipComponent {
  constructor() {
    this._hasCloseButton = false;
    this._color = "neutral";
    /**
     * Emitted when the 'X' close button is clicked. `(click)` may be used for clicks on the entire chip
     */
    this.closeClick = new EventEmitter();
  }
  /**
   * Sets chip color to one of: `neutral`, `yellow`, `green`, or `red` (default=`neutral`)
   * @return {?}
   */
  get color() {
    return this._color;
  }
  /**
   * @param {?} colorType
   * @return {?}
   */
  set color(colorType) {
    validateColorInput$2(colorType);
    this._color = colorType;
  }
  /**
   * If true, displays an X button on the right side of the chip which emits a `closeClick` event
   * @return {?}
   */
  get hasCloseButton() {
    return this._hasCloseButton;
  }
  /**
   * @param {?} hasButton
   * @return {?}
   */
  set hasCloseButton(hasButton) {
    this._hasCloseButton = parseBooleanAttribute(hasButton);
  }
  /**
   * Called on a click of the X close button
   * @param {?} e
   * @return {?}
   */
  _closeClick(e) {
    this.closeClick.emit(e);
  }
  /**
   * @deprecated
   * \@description Use `hasCloseButton` instead
   *
   * @return {?}
   */
  get action() {
    return this._hasCloseButton;
  }
  /**
   * @param {?} isAction
   * @return {?}
   */
  set action(isAction) {
    this._hasCloseButton = parseBooleanAttribute(isAction);
  }
}
ChipComponent.ɵfac = function ChipComponent_Factory(t) {
  return new (t || ChipComponent)();
};
ChipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ChipComponent,
  selectors: [["hc-chip"]],
  inputs: {
    color: "color",
    hasCloseButton: "hasCloseButton",
    action: "action",
  },
  outputs: { closeClick: "closeClick" },
  ngContentSelectors: _c3,
  decls: 4,
  vars: 7,
  consts: [
    ["class", "hc-chip-close", 3, "click", 4, "ngIf"],
    [1, "hc-chip-close", 3, "click"],
    [1, "hc-chip-close-icon"],
  ],
  template: function ChipComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div");
      ɵngcc0.ɵɵelementStart(1, "span");
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(3, ChipComponent_span_3_Template, 2, 0, "span", 0);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassMapInterpolate1("hc-chip hc-chip-", ctx.color, "");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassMapInterpolate1("hc-chip-content-", ctx.color, "");
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("ngIf", ctx.hasCloseButton);
    }
  },
  directives: [ɵngcc1.NgIf],
  styles: [_c23],
  encapsulation: 2,
});
/** @nocollapse */
ChipComponent.ctorParameters = () => [];
ChipComponent.propDecorators = {
  closeClick: [{ type: Output }],
  color: [{ type: Input }],
  hasCloseButton: [{ type: Input }],
  action: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  ChipComponent.prototype._hasCloseButton;
  /**
   * @type {?}
   * @private
   */
  ChipComponent.prototype._color;
  /**
   * Emitted when the 'X' close button is clicked. `(click)` may be used for clicks on the entire chip
   * @type {?}
   */
  ChipComponent.prototype.closeClick;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip/chip-row/chip-row.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Supporting component to help with grouping chips into collections
 */
class ChipRowComponent {
  constructor() {
    this._wrap = true;
  }
  /**
   * If false, constrain the container to one line with overflow ellipses (default=true)
   * @return {?}
   */
  get wrap() {
    return this._wrap;
  }
  /**
   * @param {?} doWrap
   * @return {?}
   */
  set wrap(doWrap) {
    this._wrap = parseBooleanAttribute(doWrap);
  }
}
ChipRowComponent.ɵfac = function ChipRowComponent_Factory(t) {
  return new (t || ChipRowComponent)();
};
ChipRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ChipRowComponent,
  selectors: [["hc-chip-row"]],
  inputs: { wrap: "wrap" },
  ngContentSelectors: _c3,
  decls: 4,
  vars: 3,
  consts: [
    [1, "hc-chip-row-contents", 3, "ngClass"],
    [1, "hc-chip-row-buffer"],
  ],
  template: function ChipRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div");
      ɵngcc0.ɵɵelementStart(2, "div", 1);
      ɵngcc0.ɵɵprojection(3);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c22, !ctx.wrap));
    }
  },
  directives: [ɵngcc1.NgClass],
  styles: [_c23],
  encapsulation: 2,
});
/** @nocollapse */
ChipRowComponent.ctorParameters = () => [];
ChipRowComponent.propDecorators = {
  wrap: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  ChipRowComponent.prototype._wrap;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip/chip.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChipModule {}
ChipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChipModule });
ChipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ChipModule_Factory(t) {
    return new (t || ChipModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/chip/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker-intl.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Datepicker data that requires internationalization.
 */
class HcDatepickerIntl {
  constructor() {
    /**
     * Stream that emits whenever the labels here are changed. Use this to notify
     * components if the labels have changed after initialization.
     */
    this.changes = new Subject();
    /**
     * A label for the calendar popup (used by screen readers).
     */
    this.calendarLabel = "Calendar";
    /**
     * A label for the button used to open the calendar popup (used by screen readers).
     */
    this.openCalendarLabel = "Open calendar";
    /**
     * A label for the current month button (used by screen readers).
     */
    this.currentMonthLabel = "Current month";
    /**
     * A label for the previous month button (used by screen readers).
     */
    this.prevMonthLabel = "Previous month";
    /**
     * A label for the next month button (used by screen readers).
     */
    this.nextMonthLabel = "Next month";
    /**
     * A label for the previous year button (used by screen readers).
     */
    this.prevYearLabel = "Previous year";
    /**
     * A label for the next year button (used by screen readers).
     */
    this.nextYearLabel = "Next year";
    /**
     * A label for the previous multi-year button (used by screen readers).
     */
    this.prevMultiYearLabel = "Previous 20 years";
    /**
     * A label for the next multi-year button (used by screen readers).
     */
    this.nextMultiYearLabel = "Next 20 years";
    /**
     * A label for the 'switch to month view' button (used by screen readers).
     */
    this.switchToMonthViewLabel = "Choose date";
    /**
     * A label for the 'switch to year view' button (used by screen readers).
     */
    this.switchToMultiYearViewLabel = "Choose month and year";
    /**
     * A label for the 'jump to the current date' button (used by screen readers).
     */
    this.switchToTodayLabel = "Jump to the current date";
  }
}
HcDatepickerIntl.ɵfac = function HcDatepickerIntl_Factory(t) {
  return new (t || HcDatepickerIntl)();
};
HcDatepickerIntl.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: HcDatepickerIntl,
  factory: HcDatepickerIntl.ɵfac,
  providedIn: "root",
});
/** @nocollapse */ HcDatepickerIntl.ngInjectableDef = ɵɵdefineInjectable({
  factory: function HcDatepickerIntl_Factory() {
    return new HcDatepickerIntl();
  },
  token: HcDatepickerIntl,
  providedIn: "root",
});
if (false) {
  /**
   * Stream that emits whenever the labels here are changed. Use this to notify
   * components if the labels have changed after initialization.
   * @type {?}
   */
  HcDatepickerIntl.prototype.changes;
  /**
   * A label for the calendar popup (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.calendarLabel;
  /**
   * A label for the button used to open the calendar popup (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.openCalendarLabel;
  /**
   * A label for the current month button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.currentMonthLabel;
  /**
   * A label for the previous month button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.prevMonthLabel;
  /**
   * A label for the next month button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.nextMonthLabel;
  /**
   * A label for the previous year button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.prevYearLabel;
  /**
   * A label for the next year button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.nextYearLabel;
  /**
   * A label for the previous multi-year button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.prevMultiYearLabel;
  /**
   * A label for the next multi-year button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.nextMultiYearLabel;
  /**
   * A label for the 'switch to month view' button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.switchToMonthViewLabel;
  /**
   * A label for the 'switch to year view' button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.switchToMultiYearViewLabel;
  /**
   * A label for the 'jump to the current date' button (used by screen readers).
   * @type {?}
   */
  HcDatepickerIntl.prototype.switchToTodayLabel;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/datepicker-errors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Health Catalyst All Rights Reserved.
 *
 * Use of this source code is governed by an Apache-2.0 license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/HealthCatalyst/Fabric.Cashmere/dev/LICENSE
 */
/**
 * \@docs-private
 * @param {?} provider
 * @return {?}
 */
function createMissingDateImplError(provider) {
  return Error(
    `Datepicker: No provider found for ${provider}. You must import one of the following ` +
      `modules at your application root: HcNativeDateModule, MatMomentDateModule, or provide a ` +
      `custom implementation.`
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/date-formats.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const HC_DATE_FORMATS = new InjectionToken("hc-date-formats");

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/date-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * InjectionToken for datepicker that can be used to override default locale code.
 * @type {?}
 */
const HC_DATE_LOCALE = new InjectionToken("HC_DATE_LOCALE", {
  providedIn: "root",
  factory: HC_DATE_LOCALE_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function HC_DATE_LOCALE_FACTORY() {
  return inject(LOCALE_ID);
}
/**
 * No longer needed since HC_DATE_LOCALE has been changed to a scoped injectable.
 * If you are importing and providing this in your code you can simply remove it.
 * @deprecated
 * \@breaking-change 8.0.0
 * @type {?}
 */
const HC_DATE_LOCALE_PROVIDER = {
  provide: HC_DATE_LOCALE,
  useExisting: LOCALE_ID,
};
/**
 * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
class DateAdapter {
  constructor() {
    this._localeChanges = new Subject();
  }
  /**
   * A stream that emits when the locale changes.
   * @return {?}
   */
  get localeChanges() {
    return this._localeChanges;
  }
  /**
   * Attempts to deserialize a value to a valid date object. This is different from parsing in that
   * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
   * string). The default implementation does not allow any deserialization, it simply checks that
   * the given value is already a valid date object or null. The `<sat-datepicker>` will call this
   * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
   * support passing values from your backend directly to these properties by overriding this method
   * to also deserialize the format used by your backend.
   * @param {?} value The value to be deserialized into a date object.
   * @return {?} The deserialized date object, either a valid date, null if the value can be
   *     deserialized into a null date (e.g. the empty string), or an invalid date.
   */
  deserialize(value) {
    if (value == null || (this.isDateInstance(value) && this.isValid(value))) {
      return value;
    }
    return this.invalid();
  }
  /**
   * Sets the locale used for all dates.
   * @param {?} locale The new locale.
   * @return {?}
   */
  setLocale(locale) {
    this.locale = locale;
    this._localeChanges.next();
  }
  /**
   * Compares two dates.
   * @param {?} first The first date to compare.
   * @param {?} second The second date to compare.
   * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
   *     a number greater than 0 if the first date is later.
   */
  compareDate(first, second) {
    return (
      this.getYear(first) - this.getYear(second) ||
      this.getMonth(first) - this.getMonth(second) ||
      this.getDate(first) - this.getDate(second) ||
      this.getHours(first) - this.getHours(second) ||
      this.getMinutes(first) - this.getMinutes(second)
    );
  }
  /**
   * Checks if two dates are equal.
   * @param {?} first The first date to check.
   * @param {?} second The second date to check.
   * @return {?} Whether the two dates are equal.
   *     Null dates are considered equal to other null dates.
   */
  sameDate(first, second) {
    if (first && second) {
      /** @type {?} */
      const firstValid = this.isValid(first);
      /** @type {?} */
      const secondValid = this.isValid(second);
      if (firstValid && secondValid) {
        return !this.compareDate(first, second);
      }
      return firstValid === secondValid;
    }
    return first === second;
  }
  /**
   * Clamp the given date between min and max dates.
   * @param {?} date The date to clamp.
   * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
   * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
   * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
   *     otherwise `date`.
   */
  clampDate(date, min, max) {
    if (min && this.compareDate(date, min) < 0) {
      return min;
    }
    if (max && this.compareDate(date, max) > 0) {
      return max;
    }
    return date;
  }
}
if (false) {
  /**
   * The locale to use for all dates.
   * @type {?}
   * @protected
   */
  DateAdapter.prototype.locale;
  /**
   * @type {?}
   * @protected
   */
  DateAdapter.prototype._localeChanges;
  /**
   * Gets the year component of the given date.
   * @abstract
   * @param {?} date The date to extract the year from.
   * @return {?} The year component.
   */
  DateAdapter.prototype.getYear = function (date) {};
  /**
   * Gets the month component of the given date.
   * @abstract
   * @param {?} date The date to extract the month from.
   * @return {?} The month component (0-indexed, 0 = January).
   */
  DateAdapter.prototype.getMonth = function (date) {};
  /**
   * Gets the date of the month component of the given date.
   * @abstract
   * @param {?} date The date to extract the date of the month from.
   * @return {?} The month component (1-indexed, 1 = first of month).
   */
  DateAdapter.prototype.getDate = function (date) {};
  /**
   * @abstract
   * @param {?} date
   * @return {?}
   */
  DateAdapter.prototype.getHours = function (date) {};
  /**
   * @abstract
   * @param {?} date
   * @return {?}
   */
  DateAdapter.prototype.getMinutes = function (date) {};
  /**
   * Gets the day of the week component of the given date.
   * @abstract
   * @param {?} date The date to extract the day of the week from.
   * @return {?} The month component (0-indexed, 0 = Sunday).
   */
  DateAdapter.prototype.getDayOfWeek = function (date) {};
  /**
   * Gets a list of names for the months.
   * @abstract
   * @param {?} style The naming style (e.g. long = 'January', short = 'Jan', narrow = 'J').
   * @return {?} An ordered list of all month names, starting with January.
   */
  DateAdapter.prototype.getMonthNames = function (style) {};
  /**
   * Gets a list of names for the dates of the month.
   * @abstract
   * @return {?} An ordered list of all date of the month names, starting with '1'.
   */
  DateAdapter.prototype.getDateNames = function () {};
  /**
   * Gets a list of names for the days of the week.
   * @abstract
   * @param {?} style The naming style (e.g. long = 'Sunday', short = 'Sun', narrow = 'S').
   * @return {?} An ordered list of all weekday names, starting with Sunday.
   */
  DateAdapter.prototype.getDayOfWeekNames = function (style) {};
  /**
   * Gets the name for the year of the given date.
   * @abstract
   * @param {?} date The date to get the year name for.
   * @return {?} The name of the given year (e.g. '2017').
   */
  DateAdapter.prototype.getYearName = function (date) {};
  /**
   * Gets the first day of the week.
   * @abstract
   * @return {?} The first day of the week (0-indexed, 0 = Sunday).
   */
  DateAdapter.prototype.getFirstDayOfWeek = function () {};
  /**
   * Gets the number of days in the month of the given date.
   * @abstract
   * @param {?} date The date whose month should be checked.
   * @return {?} The number of days in the month of the given date.
   */
  DateAdapter.prototype.getNumDaysInMonth = function (date) {};
  /**
   * Clones the given date.
   * @abstract
   * @param {?} date The date to clone
   * @return {?} A new date equal to the given date.
   */
  DateAdapter.prototype.clone = function (date) {};
  /**
   * Creates a date with the given year, month, and date. Does not allow over/under-flow of the
   * month and date.
   * @abstract
   * @param {?} year The full year of the date. (e.g. 89 means the year 89, not the year 1989).
   * @param {?} month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.
   * @param {?} date The date of month of the date. Must be an integer 1 - length of the given month.
   * @return {?} The new date, or null if invalid.
   */
  DateAdapter.prototype.createDate = function (year, month, date) {};
  /**
   * Gets today's date.
   * @abstract
   * @return {?} Today's date.
   */
  DateAdapter.prototype.today = function () {};
  /**
   * Parses a date from a user-provided value.
   * @abstract
   * @param {?} value The value to parse.
   * @param {?} parseFormat The expected format of the value being parsed
   *     (type is implementation-dependent).
   * @return {?} The parsed date.
   */
  DateAdapter.prototype.parse = function (value, parseFormat) {};
  /**
   * Formats a date as a string according to the given format.
   * @abstract
   * @param {?} date The value to format.
   * @param {?} displayFormat The format to use to display the date as a string.
   * @return {?} The formatted date string.
   */
  DateAdapter.prototype.format = function (date, displayFormat) {};
  /**
   * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the
   * calendar for each year and then finding the closest date in the new month. For example when
   * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.
   * @abstract
   * @param {?} date The date to add years to.
   * @param {?} years The number of years to add (may be negative).
   * @return {?} A new date equal to the given one with the specified number of years added.
   */
  DateAdapter.prototype.addCalendarYears = function (date, years) {};
  /**
   * Adds the given number of months to the date. Months are counted as if flipping a page on the
   * calendar for each month and then finding the closest date in the new month. For example when
   * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.
   * @abstract
   * @param {?} date The date to add months to.
   * @param {?} months The number of months to add (may be negative).
   * @return {?} A new date equal to the given one with the specified number of months added.
   */
  DateAdapter.prototype.addCalendarMonths = function (date, months) {};
  /**
   * Adds the given number of days to the date. Days are counted as if moving one cell on the
   * calendar for each day.
   * @abstract
   * @param {?} date The date to add days to.
   * @param {?} days The number of days to add (may be negative).
   * @return {?} A new date equal to the given one with the specified number of days added.
   */
  DateAdapter.prototype.addCalendarDays = function (date, days) {};
  /**
   * Gets the RFC 3339 compatible string (https://tools.ietf.org/html/rfc3339) for the given date.
   * This method is used to generate date strings that are compatible with native HTML attributes
   * such as the `min` or `max` attribute of an `<input>`.
   * @abstract
   * @param {?} date The date to get the ISO date string for.
   * @return {?} The ISO date string date string.
   */
  DateAdapter.prototype.toIso8601 = function (date) {};
  /**
   * Checks whether the given object is considered a date instance by this DateAdapter.
   * @abstract
   * @param {?} obj The object to check
   * @return {?} Whether the object is a date instance.
   */
  DateAdapter.prototype.isDateInstance = function (obj) {};
  /**
   * Checks whether the given date is valid.
   * @abstract
   * @param {?} date The date to check.
   * @return {?} Whether the date is valid.
   */
  DateAdapter.prototype.isValid = function (date) {};
  /**
   * Gets date instance that is not valid.
   * @abstract
   * @return {?} An invalid date.
   */
  DateAdapter.prototype.invalid = function () {};
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/calendar-body/calendar-body.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
class HcCalendarCell {
  /**
   * @param {?} value
   * @param {?} displayValue
   * @param {?} ariaLabel
   * @param {?} enabled
   * @param {?=} cssClasses
   */
  constructor(value, displayValue, ariaLabel, enabled, cssClasses) {
    this.value = value;
    this.displayValue = displayValue;
    this.ariaLabel = ariaLabel;
    this.enabled = enabled;
    this.cssClasses = cssClasses;
  }
}
if (false) {
  /** @type {?} */
  HcCalendarCell.prototype.value;
  /** @type {?} */
  HcCalendarCell.prototype.displayValue;
  /** @type {?} */
  HcCalendarCell.prototype.ariaLabel;
  /** @type {?} */
  HcCalendarCell.prototype.enabled;
  /** @type {?} */
  HcCalendarCell.prototype.cssClasses;
}
/**
 * An internal component used to display calendar data in a table.
 * \@docs-private
 */
class CalendarBodyComponent {
  /**
   * @param {?} _elementRef
   * @param {?} _ngZone
   */
  constructor(_elementRef, _ngZone) {
    this._elementRef = _elementRef;
    this._ngZone = _ngZone;
    /**
     * The number of columns in the table.
     */
    this.numCols = 7;
    /**
     * The cell number of the active cell in the table.
     */
    this.activeCell = 0;
    /**
     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
     * maintained even as the table resizes.
     */
    this.cellAspectRatio = 1;
    /**
     * Emits when a new value is selected.
     */
    this.selectedValueChange = new EventEmitter();
  }
  /**
   * @param {?} cell
   * @return {?}
   */
  _cellClicked(cell) {
    if (cell.enabled) {
      this.selectedValueChange.emit(cell.value);
    }
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    /** @type {?} */
    const columnChanges = changes.numCols;
    const { rows, numCols } = this;
    if (changes.rows || columnChanges) {
      this._firstRowOffset =
        rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
    }
    if (changes.cellAspectRatio || columnChanges || !this._cellPadding) {
      this._cellPadding = `${(50 * this.cellAspectRatio) / numCols}%`;
    }
    if (columnChanges || !this._cellWidth) {
      this._cellWidth = `${100 / numCols}%`;
    }
  }
  /**
   * @param {?} rowIndex
   * @param {?} colIndex
   * @return {?}
   */
  _isActiveCell(rowIndex, colIndex) {
    /** @type {?} */
    let cellNumber = rowIndex * this.numCols + colIndex;
    // Account for the fact that the first row may not have as many cells.
    if (rowIndex) {
      cellNumber -= this._firstRowOffset;
    }
    return cellNumber === this.activeCell;
  }
  /**
   * Focuses the active cell after the microtask queue is empty.
   * @return {?}
   */
  _focusActiveCell() {
    this._ngZone.runOutsideAngular(
      /**
       * @return {?}
       */
      () => {
        this._ngZone.onStable
          .asObservable()
          .pipe(take(1))
          .subscribe(
            /**
             * @return {?}
             */
            () => {
              /** @type {?} */
              const activeCell = this._elementRef.nativeElement.querySelector(
                ".hc-calendar-body-active"
              );
              if (activeCell) {
                activeCell.focus();
              }
            }
          );
      }
    );
  }
}
CalendarBodyComponent.ɵfac = function CalendarBodyComponent_Factory(t) {
  return new (t || CalendarBodyComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)
  );
};
CalendarBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CalendarBodyComponent,
  selectors: [["", "hc-calendar-body", ""]],
  hostAttrs: ["role", "grid", "aria-readonly", "true", 1, "hc-calendar-body"],
  inputs: {
    numCols: "numCols",
    activeCell: "activeCell",
    cellAspectRatio: "cellAspectRatio",
    label: "label",
    rows: "rows",
    todayValue: "todayValue",
    selectedValue: "selectedValue",
    labelMinRequiredCells: "labelMinRequiredCells",
  },
  outputs: { selectedValueChange: "selectedValueChange" },
  exportAs: ["hcCalendarBody"],
  features: [ɵngcc0.ɵɵNgOnChangesFeature],
  attrs: _c24,
  decls: 1,
  vars: 1,
  consts: [
    ["role", "row", 4, "ngFor", "ngForOf"],
    ["role", "row"],
    ["aria-hidden", "true", "class", "hc-calendar-body-label", 4, "ngIf"],
    [
      "role",
      "gridcell",
      "class",
      "hc-calendar-body-cell",
      3,
      "ngClass",
      "tabindex",
      "hc-calendar-body-available",
      "hc-calendar-body-disabled",
      "hc-calendar-body-active",
      "width",
      "paddingTop",
      "paddingBottom",
      "click",
      4,
      "ngFor",
      "ngForOf",
    ],
    ["aria-hidden", "true", 1, "hc-calendar-body-label"],
    [
      "role",
      "gridcell",
      1,
      "hc-calendar-body-cell",
      3,
      "ngClass",
      "tabindex",
      "click",
    ],
    [1, "hc-calendar-body-cell-content"],
  ],
  template: function CalendarBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵtemplate(0, CalendarBodyComponent_tr_0_Template, 3, 2, "tr", 0);
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngForOf", ctx.rows);
    }
  },
  directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgClass],
  styles: [
    "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-body{font-size:14px;min-width:224px}.hc-calendar-body-label{color:#00aeff;font-size:14px;height:0;line-height:0;padding-left:4.71429%;padding-right:4.71429%;text-align:left}[dir=rtl] .hc-calendar-body-label{text-align:right}.hc-calendar-body-cell{cursor:pointer;height:0;line-height:0;outline:0;position:relative;text-align:center}.hc-calendar-body-disabled{color:#c0c5cc}.hc-calendar-body-cell-content{-webkit-box-align:center;align-items:center;border-radius:999px;box-sizing:border-box;color:#333;display:-webkit-box;display:flex;height:90%;-webkit-box-pack:center;justify-content:center;left:5%;line-height:1;position:absolute;top:5%;width:90%;border:1px solid transparent}.hc-calendar-body-disabled .hc-calendar-body-cell-content:not(.hc-calendar-body-selected):not(.hc-calendar-body-today){color:#c0c5cc}.cdk-keyboard-focused .hc-calendar-body-active .hc-calendar-body-cell-content:not(.hc-calendar-body-selected),.cdk-program-focused .hc-calendar-body-active .hc-calendar-body-cell-content:not(.hc-calendar-body-selected),.hc-calendar-body-available:hover .hc-calendar-body-cell-content{border:2px solid #008bcc}.hc-calendar-body-selected{background-color:#008bcc;color:#fff;font-weight:700}.hc-calendar-body-disabled .hc-calendar-body-selected{background-color:#c0c5cc}.hc-calendar-body-selected.hc-calendar-body-today{box-shadow:inset 0 0 0 1px #c0c5cc}.hc-calendar-body-disabled .hc-calendar-body-today:not(.hc-calendar-body-selected),.hc-calendar-body-today:not(.hc-calendar-body-selected){background-color:#c0c5cc;border-color:transparent}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
CalendarBodyComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: NgZone },
];
CalendarBodyComponent.propDecorators = {
  label: [{ type: Input }],
  rows: [{ type: Input }],
  todayValue: [{ type: Input }],
  selectedValue: [{ type: Input }],
  labelMinRequiredCells: [{ type: Input }],
  numCols: [{ type: Input }],
  activeCell: [{ type: Input }],
  cellAspectRatio: [{ type: Input }],
  selectedValueChange: [{ type: Output }],
};
if (false) {
  /**
   * The label for the table. (e.g. "Jan 2017").
   * @type {?}
   */
  CalendarBodyComponent.prototype.label;
  /**
   * The cells to display in the table.
   * @type {?}
   */
  CalendarBodyComponent.prototype.rows;
  /**
   * The value in the table that corresponds to today.
   * @type {?}
   */
  CalendarBodyComponent.prototype.todayValue;
  /**
   * The value in the table that is currently selected.
   * @type {?}
   */
  CalendarBodyComponent.prototype.selectedValue;
  /**
   * The minimum number of free cells needed to fit the label in the first row.
   * @type {?}
   */
  CalendarBodyComponent.prototype.labelMinRequiredCells;
  /**
   * The number of columns in the table.
   * @type {?}
   */
  CalendarBodyComponent.prototype.numCols;
  /**
   * The cell number of the active cell in the table.
   * @type {?}
   */
  CalendarBodyComponent.prototype.activeCell;
  /**
   * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
   * maintained even as the table resizes.
   * @type {?}
   */
  CalendarBodyComponent.prototype.cellAspectRatio;
  /**
   * Emits when a new value is selected.
   * @type {?}
   */
  CalendarBodyComponent.prototype.selectedValueChange;
  /**
   * The number of blank cells to put at the beginning for the first row.
   * @type {?}
   */
  CalendarBodyComponent.prototype._firstRowOffset;
  /**
   * Padding for the individual date cells.
   * @type {?}
   */
  CalendarBodyComponent.prototype._cellPadding;
  /**
   * Width of an individual cell.
   * @type {?}
   */
  CalendarBodyComponent.prototype._cellWidth;
  /**
   * @type {?}
   * @private
   */
  CalendarBodyComponent.prototype._elementRef;
  /**
   * @type {?}
   * @private
   */
  CalendarBodyComponent.prototype._ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/multi-year-view/multi-year-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const yearsPerPage = 24;
/** @type {?} */
const yearsPerRow = 4;
class MultiYearViewComponent {
  /**
   * @param {?} _changeDetectorRef
   * @param {?} _dateAdapter
   * @param {?=} _dir
   */
  constructor(_changeDetectorRef, _dateAdapter, _dir) {
    this._changeDetectorRef = _changeDetectorRef;
    this._dateAdapter = _dateAdapter;
    this._dir = _dir;
    /**
     * Emits when a new year is selected.
     */
    this.selectedChange = new EventEmitter();
    /**
     * Emits the selected year. This doesn't imply a change on the selected date
     */
    this.yearSelected = new EventEmitter();
    /**
     * Emits when any date is activated.
     */
    this.activeDateChange = new EventEmitter();
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    this._activeDate = this._dateAdapter.today();
  }
  /**
   * The date to display in this multi-year view (everything other than the year is ignored).
   * @return {?}
   */
  get activeDate() {
    return this._activeDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set activeDate(value) {
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const validDate =
      this._getValidDateOrNull(this._dateAdapter.deserialize(value)) ||
      this._dateAdapter.today();
    this._activeDate = this._dateAdapter.clampDate(
      validDate,
      this.minDate,
      this.maxDate
    );
    if (
      Math.floor(this._dateAdapter.getYear(oldActiveDate) / yearsPerPage) !==
      Math.floor(this._dateAdapter.getYear(this._activeDate) / yearsPerPage)
    ) {
      this._init();
    }
  }
  /**
   * The currently selected date.
   * @return {?}
   */
  get selected() {
    return this._selected;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set selected(value) {
    this._selected = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
    this._selectedYear =
      this._selected && this._dateAdapter.getYear(this._selected);
  }
  /**
   * The minimum selectable date.
   * @return {?}
   */
  get minDate() {
    return this._minDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set minDate(value) {
    this._minDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * The maximum selectable date.
   * @return {?}
   */
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set maxDate(value) {
    this._maxDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._init();
  }
  /**
   * Initializes this multi-year view.
   * @return {?}
   */
  _init() {
    this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
    /** @type {?} */
    const activeYear = this._dateAdapter.getYear(this._activeDate);
    /** @type {?} */
    const activeOffset = activeYear % yearsPerPage;
    this._years = [];
    for (let i = 0, row = []; i < yearsPerPage; i++) {
      row.push(activeYear - activeOffset + i);
      if (row.length === yearsPerRow) {
        this._years.push(
          row.map(
            /**
             * @param {?} year
             * @return {?}
             */
            (year) => this._createCellForYear(year)
          )
        );
        row = [];
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Handles when a new year is selected.
   * @param {?} year
   * @return {?}
   */
  _yearSelected(year) {
    this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
    /** @type {?} */
    const month = this._dateAdapter.getMonth(this.activeDate);
    /** @type {?} */
    const daysInMonth = this._dateAdapter.getNumDaysInMonth(
      this._dateAdapter.createDate(year, month, 1)
    );
    this.selectedChange.emit(
      this._dateAdapter.createDate(
        year,
        month,
        Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)
      )
    );
  }
  /**
   * Handles keydown events on the calendar body when calendar is in multi-year view.
   * @param {?} event
   * @return {?}
   */
  _handleCalendarBodyKeydown(event) {
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const isRtl = this._isRtl();
    switch (event.keyCode) {
      case LEFT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          isRtl ? 1 : -1
        );
        break;
      case RIGHT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          isRtl ? -1 : 1
        );
        break;
      case UP_ARROW:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          -yearsPerRow
        );
        break;
      case DOWN_ARROW:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          yearsPerRow
        );
        break;
      case HOME:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          -this._dateAdapter.getYear(this._activeDate) % yearsPerPage
        );
        break;
      case END:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          yearsPerPage -
            (this._dateAdapter.getYear(this._activeDate) % yearsPerPage) -
            1
        );
        break;
      case PAGE_UP:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          event.altKey ? -yearsPerPage * 10 : -yearsPerPage
        );
        break;
      case PAGE_DOWN:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          event.altKey ? yearsPerPage * 10 : yearsPerPage
        );
        break;
      case ENTER:
      case SPACE:
        this._yearSelected(this._dateAdapter.getYear(this._activeDate));
        break;
      default:
        // Don't prevent default or focus active cell on keys that we don't explicitly handle.
        return;
    }
    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
      this.activeDateChange.emit(this.activeDate);
    }
    this._focusActiveCell();
    // Prevent unexpected default actions such as form submission.
    event.preventDefault();
  }
  /**
   * @return {?}
   */
  _getActiveCell() {
    return this._dateAdapter.getYear(this.activeDate) % yearsPerPage;
  }
  /**
   * Focuses the active cell after the microtask queue is empty.
   * @return {?}
   */
  _focusActiveCell() {
    this._hcCalendarBody._focusActiveCell();
  }
  /**
   * Creates an hcCalendarCell for the given year.
   * @private
   * @param {?} year
   * @return {?}
   */
  _createCellForYear(year) {
    /** @type {?} */
    const yearName = this._dateAdapter.getYearName(
      this._dateAdapter.createDate(year, 0, 1)
    );
    return new HcCalendarCell(
      year,
      yearName,
      yearName,
      this._shouldEnableYear(year)
    );
  }
  /**
   * Whether the given year is enabled.
   * @private
   * @param {?} year
   * @return {?}
   */
  _shouldEnableYear(year) {
    // disable if the year is greater than maxDate lower than minDate
    if (
      year === undefined ||
      year === null ||
      (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
      (this.minDate && year < this._dateAdapter.getYear(this.minDate))
    ) {
      return false;
    }
    // enable if it reaches here and there's no filter defined
    if (!this.dateFilter) {
      return true;
    }
    /** @type {?} */
    const firstOfYear = this._dateAdapter.createDate(year, 0, 1);
    // If any date in the year is enabled count the year as enabled.
    for (
      let date = firstOfYear;
      this._dateAdapter.getYear(date) === year;
      date = this._dateAdapter.addCalendarDays(date, 1)
    ) {
      if (this.dateFilter(date)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
  /**
   * Determines whether the user has the RTL layout direction.
   * @private
   * @return {?}
   */
  _isRtl() {
    return this._dir && this._dir.value === "rtl";
  }
}
MultiYearViewComponent.ɵfac = function MultiYearViewComponent_Factory(t) {
  return new (t || MultiYearViewComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8)
  );
};
MultiYearViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: MultiYearViewComponent,
  selectors: [["hc-multi-year-view"]],
  viewQuery: function MultiYearViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(CalendarBodyComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._hcCalendarBody = _t.first);
    }
  },
  inputs: {
    activeDate: "activeDate",
    selected: "selected",
    minDate: "minDate",
    maxDate: "maxDate",
    dateFilter: "dateFilter",
  },
  outputs: {
    selectedChange: "selectedChange",
    yearSelected: "yearSelected",
    activeDateChange: "activeDateChange",
  },
  exportAs: ["hcMultiYearView"],
  decls: 5,
  vars: 6,
  consts: [
    [1, "hc-calendar-table"],
    [1, "hc-calendar-table-header"],
    ["colspan", "4", 1, "hc-calendar-table-header-divider"],
    [
      "hc-calendar-body",
      "",
      3,
      "rows",
      "todayValue",
      "selectedValue",
      "numCols",
      "cellAspectRatio",
      "activeCell",
      "selectedValueChange",
      "keydown",
    ],
  ],
  template: function MultiYearViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "table", 0);
      ɵngcc0.ɵɵelementStart(1, "thead", 1);
      ɵngcc0.ɵɵelementStart(2, "tr");
      ɵngcc0.ɵɵelement(3, "th", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(4, "tbody", 3);
      ɵngcc0.ɵɵlistener(
        "selectedValueChange",
        function MultiYearViewComponent_Template_tbody_selectedValueChange_4_listener(
          $event
        ) {
          return ctx._yearSelected($event);
        }
      )(
        "keydown",
        function MultiYearViewComponent_Template_tbody_keydown_4_listener(
          $event
        ) {
          return ctx._handleCalendarBodyKeydown($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("rows", ctx._years)("todayValue", ctx._todayYear)(
        "selectedValue",
        ctx._selectedYear
      )("numCols", 4)("cellAspectRatio", 4 / 7)(
        "activeCell",
        ctx._getActiveCell()
      );
    }
  },
  directives: [CalendarBodyComponent],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
MultiYearViewComponent.ctorParameters = () => [
  { type: ChangeDetectorRef },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  { type: Directionality, decorators: [{ type: Optional }] },
];
MultiYearViewComponent.propDecorators = {
  activeDate: [{ type: Input }],
  selected: [{ type: Input }],
  minDate: [{ type: Input }],
  maxDate: [{ type: Input }],
  dateFilter: [{ type: Input }],
  selectedChange: [{ type: Output }],
  yearSelected: [{ type: Output }],
  activeDateChange: [{ type: Output }],
  _hcCalendarBody: [
    { type: ViewChild, args: [CalendarBodyComponent, { static: false }] },
  ],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._activeDate;
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._selected;
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._minDate;
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._maxDate;
  /**
   * A function used to filter which dates are selectable.
   * @type {?}
   */
  MultiYearViewComponent.prototype.dateFilter;
  /**
   * Emits when a new year is selected.
   * @type {?}
   */
  MultiYearViewComponent.prototype.selectedChange;
  /**
   * Emits the selected year. This doesn't imply a change on the selected date
   * @type {?}
   */
  MultiYearViewComponent.prototype.yearSelected;
  /**
   * Emits when any date is activated.
   * @type {?}
   */
  MultiYearViewComponent.prototype.activeDateChange;
  /**
   * The body of calendar table
   * @type {?}
   */
  MultiYearViewComponent.prototype._hcCalendarBody;
  /**
   * Grid of calendar cells representing the currently displayed years.
   * @type {?}
   */
  MultiYearViewComponent.prototype._years;
  /**
   * The year that today falls on.
   * @type {?}
   */
  MultiYearViewComponent.prototype._todayYear;
  /**
   * The year of the selected date. Null if the selected date is null.
   * @type {?}
   */
  MultiYearViewComponent.prototype._selectedYear;
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._changeDetectorRef;
  /** @type {?} */
  MultiYearViewComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  MultiYearViewComponent.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/month-view/month-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DAYS_PER_WEEK = 7;
/**
 * An internal component used to display a single month in the datepicker.
 * \@docs-private
 */
class MonthViewComponent {
  /**
   * @param {?} _changeDetectorRef
   * @param {?} _dateFormats
   * @param {?} _dateAdapter
   * @param {?=} _dir
   */
  constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
    this._changeDetectorRef = _changeDetectorRef;
    this._dateFormats = _dateFormats;
    this._dateAdapter = _dateAdapter;
    this._dir = _dir;
    /**
     * Emits when a new date is selected.
     */
    this.selectedChange = new EventEmitter();
    /**
     * Emits when any date is selected.
     */
    this._userSelection = new EventEmitter();
    /**
     * Emits when any date is activated.
     */
    this.activeDateChange = new EventEmitter();
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    if (!this._dateFormats) {
      throw createMissingDateImplError("HC_DATE_FORMATS");
    }
    /** @type {?} */
    const firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
    /** @type {?} */
    const narrowWeekdays = this._dateAdapter.getDayOfWeekNames("short");
    /** @type {?} */
    const longWeekdays = this._dateAdapter.getDayOfWeekNames("long");
    // Rotate the labels for days of the week based on the configured first day of the week.
    /** @type {?} */
    const weekdays = longWeekdays.map(
      /**
       * @param {?} long
       * @param {?} i
       * @return {?}
       */
      (long, i) => {
        return { long, narrow: narrowWeekdays[i] };
      }
    );
    this._weekdays = weekdays
      .slice(firstDayOfWeek)
      .concat(weekdays.slice(0, firstDayOfWeek));
    this._activeDate = this._dateAdapter.today();
  }
  /**
   * The date to display in this month view (everything other than the month and year is ignored).
   * @return {?}
   */
  get activeDate() {
    return this._activeDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set activeDate(value) {
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const validDate =
      this._getValidDateOrNull(this._dateAdapter.deserialize(value)) ||
      this._dateAdapter.today();
    this._activeDate = this._dateAdapter.clampDate(
      validDate,
      this.minDate,
      this.maxDate
    );
    if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
      this._init();
    }
  }
  /**
   * The currently selected date.
   * @return {?}
   */
  get selected() {
    return this._selected;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set selected(value) {
    this._selected = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
    this._selectedDate = this._getDateInCurrentMonth(this._selected);
  }
  /**
   * The minimum selectable date.
   * @return {?}
   */
  get minDate() {
    return this._minDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set minDate(value) {
    this._minDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * The maximum selectable date.
   * @return {?}
   */
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set maxDate(value) {
    this._maxDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._init();
  }
  /**
   * Handles when a new date is selected.
   * @param {?} date
   * @return {?}
   */
  _dateSelected(date) {
    if (this._selectedDate !== date) {
      /** @type {?} */
      const selectedYear = this._dateAdapter.getYear(this.activeDate);
      /** @type {?} */
      const selectedMonth = this._dateAdapter.getMonth(this.activeDate);
      /** @type {?} */
      let selectedDate = this._dateAdapter.createDate(
        selectedYear,
        selectedMonth,
        date
      );
      if (this._selected) {
        selectedDate.setHours(this._selected.getHours());
        selectedDate.setMinutes(this._selected.getMinutes());
      }
      this.selectedChange.emit(selectedDate);
    }
    this._userSelection.emit();
  }
  /**
   * Handles keydown events on the calendar body when calendar is in month view.
   * @param {?} event
   * @return {?}
   */
  _handleCalendarBodyKeydown(event) {
    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const isRtl = this._isRtl();
    switch (event.keyCode) {
      case LEFT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          isRtl ? 1 : -1
        );
        break;
      case RIGHT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          isRtl ? -1 : 1
        );
        break;
      case UP_ARROW:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          -7
        );
        break;
      case DOWN_ARROW:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          7
        );
        break;
      case HOME:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          1 - this._dateAdapter.getDate(this._activeDate)
        );
        break;
      case END:
        this.activeDate = this._dateAdapter.addCalendarDays(
          this._activeDate,
          this._dateAdapter.getNumDaysInMonth(this._activeDate) -
            this._dateAdapter.getDate(this._activeDate)
        );
        break;
      case PAGE_UP:
        this.activeDate = event.altKey
          ? this._dateAdapter.addCalendarYears(this._activeDate, -1)
          : this._dateAdapter.addCalendarMonths(this._activeDate, -1);
        break;
      case PAGE_DOWN:
        this.activeDate = event.altKey
          ? this._dateAdapter.addCalendarYears(this._activeDate, 1)
          : this._dateAdapter.addCalendarMonths(this._activeDate, 1);
        break;
      case ENTER:
      case SPACE:
        if (!this.dateFilter || this.dateFilter(this._activeDate)) {
          this._dateSelected(this._dateAdapter.getDate(this._activeDate));
          this._userSelection.emit();
          // Prevent unexpected default actions such as form submission.
          event.preventDefault();
        }
        return;
      default:
        // Don't prevent default or focus active cell on keys that we don't explicitly handle.
        return;
    }
    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
      this.activeDateChange.emit(this.activeDate);
    }
    this._focusActiveCell();
    // Prevent unexpected default actions such as form submission.
    event.preventDefault();
  }
  /**
   * Initializes this month view.
   * @return {?}
   */
  _init() {
    this._selectedDate = this._getDateInCurrentMonth(this.selected);
    this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
    this._monthLabel = this._dateAdapter
      .getMonthNames("short")
      [this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();
    /** @type {?} */
    const firstOfMonth = this._dateAdapter.createDate(
      this._dateAdapter.getYear(this.activeDate),
      this._dateAdapter.getMonth(this.activeDate),
      1
    );
    this._firstWeekOffset =
      (DAYS_PER_WEEK +
        this._dateAdapter.getDayOfWeek(firstOfMonth) -
        this._dateAdapter.getFirstDayOfWeek()) %
      DAYS_PER_WEEK;
    this._createWeekCells();
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Focuses the active cell after the microtask queue is empty.
   * @return {?}
   */
  _focusActiveCell() {
    this._hcCalendarBody._focusActiveCell();
  }
  /**
   * Creates hcCalendarCells for the dates in this month.
   * @private
   * @return {?}
   */
  _createWeekCells() {
    /** @type {?} */
    const daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
    /** @type {?} */
    const dateNames = this._dateAdapter.getDateNames();
    this._weeks = [[]];
    for (
      let i = 0, cell = this._firstWeekOffset;
      i < daysInMonth;
      i++, cell++
    ) {
      if (cell === DAYS_PER_WEEK) {
        this._weeks.push([]);
        cell = 0;
      }
      /** @type {?} */
      const date = this._dateAdapter.createDate(
        this._dateAdapter.getYear(this.activeDate),
        this._dateAdapter.getMonth(this.activeDate),
        i + 1
      );
      /** @type {?} */
      const enabled = this._shouldEnableDate(date);
      /** @type {?} */
      const ariaLabel = this._dateAdapter.format(
        date,
        this._dateFormats.display.dateA11yLabel
      );
      /** @type {?} */
      const cellClasses = this.dateClass ? this.dateClass(date) : undefined;
      this._weeks[this._weeks.length - 1].push(
        new HcCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses)
      );
    }
  }
  /**
   * Date filter for the month
   * @private
   * @param {?} date
   * @return {?}
   */
  _shouldEnableDate(date) {
    return (
      !!date &&
      (!this.dateFilter || this.dateFilter(date)) &&
      (!this.minDate ||
        this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
      (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0)
    );
  }
  /**
   * Gets the date in this month that the given Date falls on.
   * Returns null if the given Date is in another month.
   * @private
   * @param {?} date
   * @return {?}
   */
  _getDateInCurrentMonth(date) {
    return date && this._hasSameMonthAndYear(date, this.activeDate)
      ? this._dateAdapter.getDate(date)
      : null;
  }
  /**
   * Checks whether the 2 dates are non-null and fall within the same month of the same year.
   * @private
   * @param {?} d1
   * @param {?} d2
   * @return {?}
   */
  _hasSameMonthAndYear(d1, d2) {
    return !!(
      d1 &&
      d2 &&
      this._dateAdapter.getMonth(d1) === this._dateAdapter.getMonth(d2) &&
      this._dateAdapter.getYear(d1) === this._dateAdapter.getYear(d2)
    );
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
  /**
   * Determines whether the user has the RTL layout direction.
   * @private
   * @return {?}
   */
  _isRtl() {
    return this._dir && this._dir.value === "rtl";
  }
}
MonthViewComponent.ɵfac = function MonthViewComponent_Factory(t) {
  return new (t || MonthViewComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(HC_DATE_FORMATS, 8),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8)
  );
};
MonthViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: MonthViewComponent,
  selectors: [["hc-month-view"]],
  viewQuery: function MonthViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(CalendarBodyComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._hcCalendarBody = _t.first);
    }
  },
  inputs: {
    activeDate: "activeDate",
    selected: "selected",
    minDate: "minDate",
    maxDate: "maxDate",
    dateFilter: "dateFilter",
    dateClass: "dateClass",
  },
  outputs: {
    selectedChange: "selectedChange",
    _userSelection: "_userSelection",
    activeDateChange: "activeDateChange",
  },
  exportAs: ["hcMonthView"],
  decls: 7,
  vars: 7,
  consts: [
    [1, "hc-calendar-table"],
    [1, "hc-calendar-table-header"],
    [4, "ngFor", "ngForOf"],
    [
      "colspan",
      "7",
      "aria-hidden",
      "true",
      1,
      "hc-calendar-table-header-divider",
    ],
    [
      "hc-calendar-body",
      "",
      3,
      "label",
      "rows",
      "todayValue",
      "selectedValue",
      "labelMinRequiredCells",
      "activeCell",
      "selectedValueChange",
      "keydown",
    ],
  ],
  template: function MonthViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "table", 0);
      ɵngcc0.ɵɵelementStart(1, "thead", 1);
      ɵngcc0.ɵɵelementStart(2, "tr");
      ɵngcc0.ɵɵtemplate(3, MonthViewComponent_th_3_Template, 2, 2, "th", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(4, "tr");
      ɵngcc0.ɵɵelement(5, "th", 3);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(6, "tbody", 4);
      ɵngcc0.ɵɵlistener(
        "selectedValueChange",
        function MonthViewComponent_Template_tbody_selectedValueChange_6_listener(
          $event
        ) {
          return ctx._dateSelected($event);
        }
      )(
        "keydown",
        function MonthViewComponent_Template_tbody_keydown_6_listener($event) {
          return ctx._handleCalendarBodyKeydown($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngForOf", ctx._weekdays);
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("label", ctx._monthLabel)("rows", ctx._weeks)(
        "todayValue",
        ctx._todayDate
      )("selectedValue", ctx._selectedDate)("labelMinRequiredCells", 3)(
        "activeCell",
        ctx._dateAdapter.getDate(ctx.activeDate) - 1
      );
    }
  },
  directives: [ɵngcc1.NgForOf, CalendarBodyComponent],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
MonthViewComponent.ctorParameters = () => [
  { type: ChangeDetectorRef },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_FORMATS] }],
  },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  { type: Directionality, decorators: [{ type: Optional }] },
];
MonthViewComponent.propDecorators = {
  activeDate: [{ type: Input }],
  selected: [{ type: Input }],
  minDate: [{ type: Input }],
  maxDate: [{ type: Input }],
  dateFilter: [{ type: Input }],
  dateClass: [{ type: Input }],
  selectedChange: [{ type: Output }],
  _userSelection: [{ type: Output }],
  activeDateChange: [{ type: Output }],
  _hcCalendarBody: [
    { type: ViewChild, args: [CalendarBodyComponent, { static: false }] },
  ],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._activeDate;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._selected;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._minDate;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._maxDate;
  /**
   * Function used to filter which dates are selectable.
   * @type {?}
   */
  MonthViewComponent.prototype.dateFilter;
  /**
   * Function that can be used to add custom CSS classes to dates.
   * @type {?}
   */
  MonthViewComponent.prototype.dateClass;
  /**
   * Emits when a new date is selected.
   * @type {?}
   */
  MonthViewComponent.prototype.selectedChange;
  /**
   * Emits when any date is selected.
   * @type {?}
   */
  MonthViewComponent.prototype._userSelection;
  /**
   * Emits when any date is activated.
   * @type {?}
   */
  MonthViewComponent.prototype.activeDateChange;
  /**
   * The body of calendar table
   * @type {?}
   */
  MonthViewComponent.prototype._hcCalendarBody;
  /**
   * The label for this month (e.g. "January 2017").
   * @type {?}
   */
  MonthViewComponent.prototype._monthLabel;
  /**
   * Grid of calendar cells representing the dates of the month.
   * @type {?}
   */
  MonthViewComponent.prototype._weeks;
  /**
   * The number of blank cells in the first row before the 1st of the month.
   * @type {?}
   */
  MonthViewComponent.prototype._firstWeekOffset;
  /**
   * The date of the month that the currently selected Date falls on.
   * Null if the currently selected Date is in another month.
   * @type {?}
   */
  MonthViewComponent.prototype._selectedDate;
  /**
   * The date of the month that today falls on. Null if today is in another month.
   * @type {?}
   */
  MonthViewComponent.prototype._todayDate;
  /**
   * The names of the weekdays.
   * @type {?}
   */
  MonthViewComponent.prototype._weekdays;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._changeDetectorRef;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._dateFormats;
  /** @type {?} */
  MonthViewComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  MonthViewComponent.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/year-view/year-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * An internal component used to display a single year in the datepicker.
 * \@docs-private
 */
class YearViewComponent {
  /**
   * @param {?} _changeDetectorRef
   * @param {?} _dateFormats
   * @param {?} _dateAdapter
   * @param {?=} _dir
   */
  constructor(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
    this._changeDetectorRef = _changeDetectorRef;
    this._dateFormats = _dateFormats;
    this._dateAdapter = _dateAdapter;
    this._dir = _dir;
    /**
     * Emits when a new month is selected.
     */
    this.selectedChange = new EventEmitter();
    /**
     * Emits the selected month. This doesn't imply a change on the selected date
     */
    this.monthSelected = new EventEmitter();
    /**
     * Emits when any date is activated.
     */
    this.activeDateChange = new EventEmitter();
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    if (!this._dateFormats) {
      throw createMissingDateImplError("HC_DATE_FORMATS");
    }
    this._activeDate = this._dateAdapter.today();
  }
  /**
   * The date to display in this year view (everything other than the year is ignored).
   * @return {?}
   */
  get activeDate() {
    return this._activeDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set activeDate(value) {
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const validDate =
      this._getValidDateOrNull(this._dateAdapter.deserialize(value)) ||
      this._dateAdapter.today();
    this._activeDate = this._dateAdapter.clampDate(
      validDate,
      this.minDate,
      this.maxDate
    );
    if (
      this._dateAdapter.getYear(oldActiveDate) !==
      this._dateAdapter.getYear(this._activeDate)
    ) {
      this._init();
    }
  }
  /**
   * The currently selected date.
   * @return {?}
   */
  get selected() {
    return this._selected;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set selected(value) {
    this._selected = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
    this._selectedMonth = this._getMonthInCurrentYear(this._selected);
  }
  /**
   * The minimum selectable date.
   * @return {?}
   */
  get minDate() {
    return this._minDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set minDate(value) {
    this._minDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * The maximum selectable date.
   * @return {?}
   */
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set maxDate(value) {
    this._maxDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._init();
  }
  /**
   * Handles when a new month is selected.
   * @param {?} month
   * @return {?}
   */
  _monthSelected(month) {
    /** @type {?} */
    const normalizedDate = this._dateAdapter.createDate(
      this._dateAdapter.getYear(this.activeDate),
      month,
      1
    );
    this.monthSelected.emit(normalizedDate);
    /** @type {?} */
    const daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
    this.selectedChange.emit(
      this._dateAdapter.createDate(
        this._dateAdapter.getYear(this.activeDate),
        month,
        Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)
      )
    );
  }
  /**
   * Handles keydown events on the calendar body when calendar is in year view.
   * @param {?} event
   * @return {?}
   */
  _handleCalendarBodyKeydown(event) {
    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
    // disabled ones from being selected. This may not be ideal, we should look into whether
    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
    /** @type {?} */
    const oldActiveDate = this._activeDate;
    /** @type {?} */
    const isRtl = this._isRtl();
    switch (event.keyCode) {
      case LEFT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          isRtl ? 1 : -1
        );
        break;
      case RIGHT_ARROW:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          isRtl ? -1 : 1
        );
        break;
      case UP_ARROW:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          -4
        );
        break;
      case DOWN_ARROW:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          4
        );
        break;
      case HOME:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          -this._dateAdapter.getMonth(this._activeDate)
        );
        break;
      case END:
        this.activeDate = this._dateAdapter.addCalendarMonths(
          this._activeDate,
          11 - this._dateAdapter.getMonth(this._activeDate)
        );
        break;
      case PAGE_UP:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          event.altKey ? -10 : -1
        );
        break;
      case PAGE_DOWN:
        this.activeDate = this._dateAdapter.addCalendarYears(
          this._activeDate,
          event.altKey ? 10 : 1
        );
        break;
      case ENTER:
      case SPACE:
        this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
        break;
      default:
        // Don't prevent default or focus active cell on keys that we don't explicitly handle.
        return;
    }
    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
      this.activeDateChange.emit(this.activeDate);
    }
    this._focusActiveCell();
    // Prevent unexpected default actions such as form submission.
    event.preventDefault();
  }
  /**
   * Initializes this year view.
   * @return {?}
   */
  _init() {
    this._selectedMonth = this._getMonthInCurrentYear(this.selected);
    this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
    this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
    /** @type {?} */
    const monthNames = this._dateAdapter.getMonthNames("short");
    // First row of months only contains 5 elements so we can fit the year label on the same row.
    this._months = [
      [0, 1, 2, 3],
      [4, 5, 6, 7],
      [8, 9, 10, 11],
    ].map(
      /**
       * @param {?} row
       * @return {?}
       */
      (row) =>
        row.map(
          /**
           * @param {?} month
           * @return {?}
           */
          (month) => this._createCellForMonth(month, monthNames[month])
        )
    );
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Focuses the active cell after the microtask queue is empty.
   * @return {?}
   */
  _focusActiveCell() {
    this._hcCalendarBody._focusActiveCell();
  }
  /**
   * Gets the month in this year that the given Date falls on.
   * Returns null if the given Date is in another year.
   * @private
   * @param {?} date
   * @return {?}
   */
  _getMonthInCurrentYear(date) {
    return date &&
      this._dateAdapter.getYear(date) ===
        this._dateAdapter.getYear(this.activeDate)
      ? this._dateAdapter.getMonth(date)
      : null;
  }
  /**
   * Creates an hcCalendarCell for the given month.
   * @private
   * @param {?} month
   * @param {?} monthName
   * @return {?}
   */
  _createCellForMonth(month, monthName) {
    /** @type {?} */
    const ariaLabel = this._dateAdapter.format(
      this._dateAdapter.createDate(
        this._dateAdapter.getYear(this.activeDate),
        month,
        1
      ),
      this._dateFormats.display.monthYearA11yLabel
    );
    return new HcCalendarCell(
      month,
      monthName.toLocaleUpperCase(),
      ariaLabel,
      this._shouldEnableMonth(month)
    );
  }
  /**
   * Whether the given month is enabled.
   * @private
   * @param {?} month
   * @return {?}
   */
  _shouldEnableMonth(month) {
    /** @type {?} */
    const activeYear = this._dateAdapter.getYear(this.activeDate);
    if (
      month === undefined ||
      month === null ||
      this._isYearAndMonthAfterMaxDate(activeYear, month) ||
      this._isYearAndMonthBeforeMinDate(activeYear, month)
    ) {
      return false;
    }
    if (!this.dateFilter) {
      return true;
    }
    /** @type {?} */
    const firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
    // If any date in the month is enabled count the month as enabled.
    for (
      let date = firstOfMonth;
      this._dateAdapter.getMonth(date) === month;
      date = this._dateAdapter.addCalendarDays(date, 1)
    ) {
      if (this.dateFilter(date)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Tests whether the combination month/year is after this.maxDate, considering
   * just the month and year of this.maxDate
   * @private
   * @param {?} year
   * @param {?} month
   * @return {?}
   */
  _isYearAndMonthAfterMaxDate(year, month) {
    if (this.maxDate) {
      /** @type {?} */
      const maxYear = this._dateAdapter.getYear(this.maxDate);
      /** @type {?} */
      const maxMonth = this._dateAdapter.getMonth(this.maxDate);
      return year > maxYear || (year === maxYear && month > maxMonth);
    }
    return false;
  }
  /**
   * Tests whether the combination month/year is before this.minDate, considering
   * just the month and year of this.minDate
   * @private
   * @param {?} year
   * @param {?} month
   * @return {?}
   */
  _isYearAndMonthBeforeMinDate(year, month) {
    if (this.minDate) {
      /** @type {?} */
      const minYear = this._dateAdapter.getYear(this.minDate);
      /** @type {?} */
      const minMonth = this._dateAdapter.getMonth(this.minDate);
      return year < minYear || (year === minYear && month < minMonth);
    }
    return false;
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
  /**
   * Determines whether the user has the RTL layout direction.
   * @private
   * @return {?}
   */
  _isRtl() {
    return this._dir && this._dir.value === "rtl";
  }
}
YearViewComponent.ɵfac = function YearViewComponent_Factory(t) {
  return new (t || YearViewComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(HC_DATE_FORMATS, 8),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8)
  );
};
YearViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: YearViewComponent,
  selectors: [["hc-year-view"]],
  viewQuery: function YearViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(CalendarBodyComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._hcCalendarBody = _t.first);
    }
  },
  inputs: {
    activeDate: "activeDate",
    selected: "selected",
    minDate: "minDate",
    maxDate: "maxDate",
    dateFilter: "dateFilter",
  },
  outputs: {
    selectedChange: "selectedChange",
    monthSelected: "monthSelected",
    activeDateChange: "activeDateChange",
  },
  exportAs: ["hcYearView"],
  decls: 5,
  vars: 8,
  consts: [
    [1, "hc-calendar-table"],
    [1, "hc-calendar-table-header"],
    ["colspan", "4", 1, "hc-calendar-table-header-divider"],
    [
      "hc-calendar-body",
      "",
      3,
      "label",
      "rows",
      "todayValue",
      "selectedValue",
      "labelMinRequiredCells",
      "numCols",
      "cellAspectRatio",
      "activeCell",
      "selectedValueChange",
      "keydown",
    ],
  ],
  template: function YearViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "table", 0);
      ɵngcc0.ɵɵelementStart(1, "thead", 1);
      ɵngcc0.ɵɵelementStart(2, "tr");
      ɵngcc0.ɵɵelement(3, "th", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(4, "tbody", 3);
      ɵngcc0.ɵɵlistener(
        "selectedValueChange",
        function YearViewComponent_Template_tbody_selectedValueChange_4_listener(
          $event
        ) {
          return ctx._monthSelected($event);
        }
      )("keydown", function YearViewComponent_Template_tbody_keydown_4_listener(
        $event
      ) {
        return ctx._handleCalendarBodyKeydown($event);
      });
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("label", ctx._yearLabel)("rows", ctx._months)(
        "todayValue",
        ctx._todayMonth
      )("selectedValue", ctx._selectedMonth)("labelMinRequiredCells", 2)(
        "numCols",
        4
      )("cellAspectRatio", 4 / 7)(
        "activeCell",
        ctx._dateAdapter.getMonth(ctx.activeDate)
      );
    }
  },
  directives: [CalendarBodyComponent],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
YearViewComponent.ctorParameters = () => [
  { type: ChangeDetectorRef },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_FORMATS] }],
  },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  { type: Directionality, decorators: [{ type: Optional }] },
];
YearViewComponent.propDecorators = {
  activeDate: [{ type: Input }],
  selected: [{ type: Input }],
  minDate: [{ type: Input }],
  maxDate: [{ type: Input }],
  dateFilter: [{ type: Input }],
  selectedChange: [{ type: Output }],
  monthSelected: [{ type: Output }],
  activeDateChange: [{ type: Output }],
  _hcCalendarBody: [
    { type: ViewChild, args: [CalendarBodyComponent, { static: false }] },
  ],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._activeDate;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._selected;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._minDate;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._maxDate;
  /**
   * A function used to filter which dates are selectable.
   * @type {?}
   */
  YearViewComponent.prototype.dateFilter;
  /**
   * Emits when a new month is selected.
   * @type {?}
   */
  YearViewComponent.prototype.selectedChange;
  /**
   * Emits the selected month. This doesn't imply a change on the selected date
   * @type {?}
   */
  YearViewComponent.prototype.monthSelected;
  /**
   * Emits when any date is activated.
   * @type {?}
   */
  YearViewComponent.prototype.activeDateChange;
  /**
   * The body of calendar table
   * @type {?}
   */
  YearViewComponent.prototype._hcCalendarBody;
  /**
   * Grid of calendar cells representing the months of the year.
   * @type {?}
   */
  YearViewComponent.prototype._months;
  /**
   * The label for this year (e.g. "2017").
   * @type {?}
   */
  YearViewComponent.prototype._yearLabel;
  /**
   * The month in this year that today falls on. Null if today is in a different year.
   * @type {?}
   */
  YearViewComponent.prototype._todayMonth;
  /**
   * The month in this year that the selected Date falls on.
   * Null if the selected Date is in a different year.
   * @type {?}
   */
  YearViewComponent.prototype._selectedMonth;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._changeDetectorRef;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._dateFormats;
  /** @type {?} */
  YearViewComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  YearViewComponent.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/calendar/calendar.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default header for hcCalendar
 */
class CalendarHeaderComponent {
  /**
   * @param {?} _intl
   * @param {?} calendar
   * @param {?} _dateAdapter
   * @param {?} _dateFormats
   * @param {?} changeDetectorRef
   */
  constructor(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
    this._intl = _intl;
    this.calendar = calendar;
    this._dateAdapter = _dateAdapter;
    this._dateFormats = _dateFormats;
    this.calendar.stateChanges.subscribe(
      /**
       * @return {?}
       */
      () => changeDetectorRef.markForCheck()
    );
  }
  /**
   * The label for the currently visible month
   * @return {?}
   */
  get monthButtonText() {
    return this._dateAdapter.getMonthNames("short")[
      this._dateAdapter.getMonth(this.calendar.activeDate)
    ];
  }
  /**
   * The label for the current calendar view.
   * @return {?}
   */
  get periodButtonText() {
    return this._dateAdapter.getYearName(this.calendar.activeDate);
  }
  /**
   * @return {?}
   */
  get periodButtonLabel() {
    return this.calendar.currentView === "month"
      ? this._intl.switchToMultiYearViewLabel
      : this._intl.switchToMonthViewLabel;
  }
  /**
   * The label for the jump to today button
   * @return {?}
   */
  get _todayButtonLabel() {
    return this._intl.switchToTodayLabel;
  }
  /**
   * The label for the currently displayed month
   * @return {?}
   */
  get monthButtonLabel() {
    return this._intl.currentMonthLabel;
  }
  /**
   * The label for the the previous button.
   * @return {?}
   */
  get prevButtonLabel() {
    return {
      month: this._intl.prevMonthLabel,
      year: this._intl.prevYearLabel,
      "multi-year": this._intl.prevMultiYearLabel,
    }[this.calendar.currentView];
  }
  /**
   * The label for the the next button.
   * @return {?}
   */
  get nextButtonLabel() {
    return {
      month: this._intl.nextMonthLabel,
      year: this._intl.nextYearLabel,
      "multi-year": this._intl.nextMultiYearLabel,
    }[this.calendar.currentView];
  }
  /**
   * Handles user clicks on the period label.
   * @return {?}
   */
  currentPeriodClicked() {
    this.calendar.currentView =
      this.calendar.currentView === "month" ? "multi-year" : "month";
  }
  /**
   * Handles user clicks on the previous button.
   * @return {?}
   */
  previousClicked() {
    this.calendar.activeDate =
      this.calendar.currentView === "month"
        ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1)
        : this._dateAdapter.addCalendarYears(
            this.calendar.activeDate,
            this.calendar.currentView === "year" ? -1 : -yearsPerPage
          );
  }
  /**
   * Handles user clicks on the next button.
   * @return {?}
   */
  nextClicked() {
    this.calendar.activeDate =
      this.calendar.currentView === "month"
        ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1)
        : this._dateAdapter.addCalendarYears(
            this.calendar.activeDate,
            this.calendar.currentView === "year" ? 1 : yearsPerPage
          );
  }
  /**
   * Handles clicks on the jump to today button
   * @return {?}
   */
  _todayClicked() {
    this.calendar.activeDate = this._dateAdapter.today();
  }
  /**
   * Whether the previous period button is enabled.
   * @return {?}
   */
  previousEnabled() {
    if (!this.calendar.minDate) {
      return true;
    }
    return (
      !this.calendar.minDate ||
      !this._isSameView(this.calendar.activeDate, this.calendar.minDate)
    );
  }
  /**
   * Whether the next period button is enabled.
   * @return {?}
   */
  nextEnabled() {
    return (
      !this.calendar.maxDate ||
      !this._isSameView(this.calendar.activeDate, this.calendar.maxDate)
    );
  }
  /**
   * @return {?}
   */
  _todayEnabled() {
    /** @type {?} */
    let minDate;
    /** @type {?} */
    let maxDate;
    /** @type {?} */
    let today = new Date(this._dateAdapter.today().toDateString());
    /** Normalize the compare dates to all be on the first day of the month because we are only concerned
     * about whether today falls outside of the month than min or max is in */
    today.setDate(1);
    if (this.calendar.minDate) {
      minDate = new Date(this.calendar.minDate.toDateString());
      minDate.setDate(1);
    }
    if (this.calendar.maxDate) {
      maxDate = new Date(this.calendar.maxDate.toDateString());
      maxDate.setDate(1);
    }
    return (
      (!minDate || this._dateAdapter.compareDate(minDate, today) < 1) &&
      (!maxDate || this._dateAdapter.compareDate(maxDate, today) > -1)
    );
  }
  /**
   * Whether the two dates represent the same view in the current view mode (month or year).
   * @private
   * @param {?} date1
   * @param {?} date2
   * @return {?}
   */
  _isSameView(date1, date2) {
    if (this.calendar.currentView === "month") {
      return (
        this._dateAdapter.getYear(date1) === this._dateAdapter.getYear(date2) &&
        this._dateAdapter.getMonth(date1) === this._dateAdapter.getMonth(date2)
      );
    }
    if (this.calendar.currentView === "year") {
      return (
        this._dateAdapter.getYear(date1) === this._dateAdapter.getYear(date2)
      );
    }
    // Otherwise we are in 'multi-year' view.
    return (
      Math.floor(this._dateAdapter.getYear(date1) / yearsPerPage) ===
      Math.floor(this._dateAdapter.getYear(date2) / yearsPerPage)
    );
  }
}
CalendarHeaderComponent.ɵfac = function CalendarHeaderComponent_Factory(t) {
  return new (t || CalendarHeaderComponent)(
    ɵngcc0.ɵɵdirectiveInject(HcDatepickerIntl),
    ɵngcc0.ɵɵdirectiveInject(
      forwardRef(
        /**
         * @return {?}
         */ () => CalendarComponent
      )
    ),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(HC_DATE_FORMATS, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
CalendarHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CalendarHeaderComponent,
  selectors: [["hc-calendar-header"]],
  exportAs: ["hcCalendarHeader"],
  ngContentSelectors: _c3,
  decls: 1,
  vars: 1,
  consts: [
    ["class", "hc-calendar-header", 4, "ngIf"],
    [1, "hc-calendar-header"],
    [1, "hc-calendar-controls"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      "type",
      "button",
      1,
      "hc-calendar-today-button",
      "hc-calendar-control-button",
      3,
      "disabled",
      "title",
      "click",
    ],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      "type",
      "button",
      1,
      "hc-calendar-previous-button",
      "hc-calendar-control-button",
      3,
      "disabled",
      "title",
      "click",
    ],
    [1, "hc-calendar-month-label"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      "type",
      "button",
      1,
      "hc-calendar-next-button",
      "hc-calendar-control-button",
      3,
      "disabled",
      "title",
      "click",
    ],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      "type",
      "button",
      1,
      "hc-calendar-period-button",
      "hc-calendar-control-button",
      3,
      "title",
      "click",
    ],
    [1, "hc-calendar-dropdown-caret"],
  ],
  template: function CalendarHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(
        0,
        CalendarHeaderComponent_div_0_Template,
        13,
        15,
        "div",
        0
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", ctx.calendar.mode !== "time");
    }
  },
  directives: [ɵngcc1.NgIf, ButtonComponent],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
CalendarHeaderComponent.ctorParameters = () => [
  { type: HcDatepickerIntl },
  {
    type: CalendarComponent,
    decorators: [
      {
        type: Inject,
        args: [
          forwardRef(
            /**
             * @return {?}
             */
            () => CalendarComponent
          ),
        ],
      },
    ],
  },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_FORMATS] }],
  },
  { type: ChangeDetectorRef },
];
if (false) {
  /**
   * @type {?}
   * @private
   */
  CalendarHeaderComponent.prototype._intl;
  /** @type {?} */
  CalendarHeaderComponent.prototype.calendar;
  /**
   * @type {?}
   * @private
   */
  CalendarHeaderComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  CalendarHeaderComponent.prototype._dateFormats;
}
/**
 * A calendar that is used as part of the datepicker.
 * \@docs-private
 */
class CalendarComponent {
  /**
   * @param {?} _intl
   * @param {?} _dateAdapter
   * @param {?} _dateFormats
   * @param {?} _changeDetectorRef
   */
  constructor(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
    this._intl = _intl;
    this._dateAdapter = _dateAdapter;
    this._dateFormats = _dateFormats;
    this._changeDetectorRef = _changeDetectorRef;
    /**
     * Stores the current am/pm value
     */
    this._period = new FormControl("am");
    /**
     * Used for scheduling that focus should be moved to the active cell on the next tick.
     * We need to schedule it, rather than do it immediately, because we have to wait
     * for Angular to re-evaluate the view children.
     */
    this._moveFocusOnNextTick = false;
    /**
     * Whether the calendar should be started in month or year view.
     */
    this.startView = "month";
    /**
     * Whether the calendar should show calendar, time-picker, or both
     */
    this.mode = "date";
    this._hourCycle = 12;
    /**
     * Emits when the currently selected date changes.
     */
    this.selectedChange = new EventEmitter();
    /**
     * Emits the year chosen in multiyear view.
     * This doesn't imply a change on the selected date.
     */
    this.yearSelected = new EventEmitter();
    /**
     * Emits the month chosen in year view.
     * This doesn't imply a change on the selected date.
     */
    this.monthSelected = new EventEmitter();
    /**
     * Emits when any date is selected.
     */
    this._userSelection = new EventEmitter();
    /**
     * Emits whenever there is a state change that the header may need to respond to.
     */
    this.stateChanges = new Subject();
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    if (!this._dateFormats) {
      throw createMissingDateImplError("HC_DATE_FORMATS");
    }
    this._intlChanges = _intl.changes.subscribe(
      /**
       * @return {?}
       */
      () => {
        _changeDetectorRef.markForCheck();
        this.stateChanges.next();
      }
    );
  }
  /**
   * A date representing the period (month or year) to start the calendar in.
   * @return {?}
   */
  get startAt() {
    return this._startAt;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set startAt(value) {
    this._startAt = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * Whether the time picker should display a 12-hour or 24-clock. Accepts 12 or 24. Defaults to 12.
   * @return {?}
   */
  get hourCycle() {
    return this._hourCycle;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set hourCycle(value) {
    if (+value === 12 || +value === 24) {
      this._hourCycle = +value;
    } else if (value) {
      throw Error(
        "Unsupported hourCycle value: " +
          value +
          ". Accepted values are 12 or 24."
      );
    }
  }
  /**
   * The currently selected date.
   * @return {?}
   */
  get selected() {
    return this._selected;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set selected(value) {
    this._selected = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
    if (this._selected) {
      this._period.setValue(this._selected.getHours() > 11 ? "pm" : "am");
    }
  }
  /**
   * The minimum selectable date.
   * @return {?}
   */
  get minDate() {
    return this._minDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set minDate(value) {
    this._minDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * The maximum selectable date.
   * @return {?}
   */
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set maxDate(value) {
    this._maxDate = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * The current active date. This determines which time period is shown and which date is
   * highlighted when using keyboard navigation.
   * @return {?}
   */
  get activeDate() {
    return this._clampedActiveDate;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set activeDate(value) {
    this._clampedActiveDate = this._dateAdapter.clampDate(
      value,
      this.minDate,
      this.maxDate
    );
    this.stateChanges.next();
  }
  /**
   * Whether the calendar is in month view.
   * @return {?}
   */
  get currentView() {
    return this._currentView;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set currentView(value) {
    this._currentView = value;
    this._moveFocusOnNextTick = true;
  }
  /**
   * A string containing the value of minutes for the current date
   * @return {?}
   */
  get minutes() {
    if (this.selected) {
      /** @type {?} */
      let minVal = this.selected.getMinutes();
      return minVal < 10 ? "0" + minVal : minVal.toString();
    } else {
      return this.selected;
    }
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set minutes(value) {
    if (value && !isNaN(+value)) {
      /** @type {?} */
      let tempDate = this.selected
        ? new Date(this.selected.getTime())
        : new Date();
      tempDate.setMinutes(+value);
      this.selectedChange.emit(tempDate);
      this._userSelected();
    }
  }
  /**
   * A string containing the hour for the current date
   * @return {?}
   */
  get hours() {
    if (this.selected) {
      /** @type {?} */
      let hourVal = this.selected.getHours();
      if (this._hourCycle === 12) {
        if (hourVal > 11) {
          return hourVal === 12
            ? hourVal.toString()
            : (hourVal - 12).toString();
        } else {
          return hourVal === 0 ? "12" : hourVal.toString();
        }
      } else {
        return hourVal.toString();
      }
    } else {
      return this.selected;
    }
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set hours(value) {
    if (value && !isNaN(+value)) {
      /** @type {?} */
      let hourVal = +value;
      if (this._hourCycle === 12) {
        if (this._period.value === "pm" && hourVal !== 12) {
          hourVal += 12;
        } else if (this._period.value === "am" && hourVal === 12) {
          hourVal = 0;
        }
      }
      /** @type {?} */
      let tempDate = this.selected
        ? new Date(this.selected.getTime())
        : new Date();
      tempDate.setHours(hourVal);
      this.selectedChange.emit(tempDate);
      this._userSelected();
    }
  }
  /**
   * @return {?}
   */
  _periodChange() {
    if (this.selected) {
      /** @type {?} */
      let tempDate = new Date(this.selected.getTime());
      /** @type {?} */
      let curHours = tempDate.getHours();
      if (this._period.value === "pm") {
        tempDate.setHours(curHours + 12);
      } else {
        tempDate.setHours(curHours - 12);
      }
      this.selectedChange.emit(tempDate);
      this._userSelected();
    }
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._calendarHeaderPortal = new ComponentPortal(
      this.headerComponent || CalendarHeaderComponent
    );
    this.activeDate = this.startAt || this._dateAdapter.today();
    // Assign to the private property since we don't want to move focus on init.
    this._currentView = this.startView;
  }
  /**
   * @return {?}
   */
  ngAfterViewChecked() {
    if (this._moveFocusOnNextTick) {
      this._moveFocusOnNextTick = false;
      this.focusActiveCell();
    }
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this._intlChanges.unsubscribe();
    this.stateChanges.complete();
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    /** @type {?} */
    const change = changes.minDate || changes.maxDate || changes.dateFilter;
    if (change && !change.firstChange) {
      /** @type {?} */
      const view = this._getCurrentViewComponent();
      if (view) {
        // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
        // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
        this._changeDetectorRef.detectChanges();
        view._init();
      }
    }
    this.stateChanges.next();
  }
  /**
   * @return {?}
   */
  focusActiveCell() {
    if (this.mode !== "time") {
      this._getCurrentViewComponent()._focusActiveCell();
    }
  }
  /**
   * Updates today's date after an update of the active date
   * @return {?}
   */
  updateTodaysDate() {
    /** @type {?} */
    const view =
      this.currentView === "month"
        ? this.monthView
        : this.currentView === "year"
        ? this.yearView
        : this.multiYearView;
    view.ngAfterContentInit();
  }
  /**
   * Handles date selection in the month view.
   * @param {?} date
   * @return {?}
   */
  _dateSelected(date) {
    if (!this._dateAdapter.sameDate(date, this.selected)) {
      this.selectedChange.emit(date);
    }
  }
  /**
   * Handles year selection in the multiyear view.
   * @param {?} normalizedYear
   * @return {?}
   */
  _yearSelectedInMultiYearView(normalizedYear) {
    this.yearSelected.emit(normalizedYear);
  }
  /**
   * Handles month selection in the year view.
   * @param {?} normalizedMonth
   * @return {?}
   */
  _monthSelectedInYearView(normalizedMonth) {
    this.monthSelected.emit(normalizedMonth);
  }
  /**
   * @return {?}
   */
  _userSelected() {
    this._userSelection.emit();
  }
  /**
   * Handles year/month selection in the multi-year/year views.
   * @param {?} date
   * @param {?} view
   * @return {?}
   */
  _goToDateInView(date, view) {
    this.activeDate = date;
    this.currentView = view;
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
  /**
   * Returns the component instance that corresponds to the current calendar view.
   * @private
   * @return {?}
   */
  _getCurrentViewComponent() {
    return this.monthView || this.yearView || this.multiYearView;
  }
  /**
   * @return {?}
   */
  _hoursUp() {
    if (!this.hours) {
      this.hours = this._hourCycle > 12 ? "0" : "1";
    } else {
      /** @type {?} */
      let curHour = +this.hours;
      curHour++;
      /** @type {?} */
      const tempCycle = this._hourCycle > 12 ? 24 : 12;
      if (curHour > tempCycle) {
        curHour = this._hourCycle > 12 ? 0 : 1;
      }
      this._changeMeridiem(curHour, 12);
      this.hours = curHour.toString();
    }
  }
  /**
   * @return {?}
   */
  _hoursDown() {
    if (!this.hours) {
      this.hours = this._hourCycle > 12 ? "23" : "12";
    } else {
      /** @type {?} */
      let curHour = +this.hours;
      curHour--;
      /** @type {?} */
      const tempCycle = this._hourCycle > 12 ? 0 : 1;
      if (curHour < tempCycle) {
        curHour = this._hourCycle > 12 ? 23 : 12;
      }
      this._changeMeridiem(curHour, 11);
      this.hours = curHour.toString();
    }
  }
  /**
   * @param {?} curHour
   * @param {?} hourChange
   * @return {?}
   */
  _changeMeridiem(curHour, hourChange) {
    if (curHour === hourChange) {
      this._period.setValue(this._period.value > "am" ? "am" : "pm");
    }
  }
  /**
   * @return {?}
   */
  _minutesUp() {
    if (!this.minutes) {
      this.minutes = "00";
    } else {
      /** @type {?} */
      let curMin = +this.minutes;
      curMin++;
      if (curMin > 59) {
        curMin = 59;
      }
      this.minutes = curMin.toString();
    }
  }
  /**
   * @return {?}
   */
  _minutesDown() {
    if (!this.minutes) {
      this.minutes = "59";
    } else {
      /** @type {?} */
      let curMin = +this.minutes;
      curMin--;
      if (curMin < 1) {
        curMin = 1;
      }
      this.minutes = curMin.toString();
    }
  }
}
CalendarComponent.ɵfac = function CalendarComponent_Factory(t) {
  return new (t || CalendarComponent)(
    ɵngcc0.ɵɵdirectiveInject(HcDatepickerIntl),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(HC_DATE_FORMATS, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
CalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CalendarComponent,
  selectors: [["hc-calendar"]],
  viewQuery: function CalendarComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(MonthViewComponent, true);
      ɵngcc0.ɵɵviewQuery(YearViewComponent, true);
      ɵngcc0.ɵɵviewQuery(MultiYearViewComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.monthView = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.yearView = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.multiYearView = _t.first);
    }
  },
  hostAttrs: [1, "hc-calendar"],
  inputs: {
    startView: "startView",
    mode: "mode",
    startAt: "startAt",
    hourCycle: "hourCycle",
    selected: "selected",
    minDate: "minDate",
    maxDate: "maxDate",
    headerComponent: "headerComponent",
    dateFilter: "dateFilter",
    dateClass: "dateClass",
  },
  outputs: {
    selectedChange: "selectedChange",
    yearSelected: "yearSelected",
    monthSelected: "monthSelected",
    _userSelection: "_userSelection",
  },
  exportAs: ["hcCalendar"],
  features: [ɵngcc0.ɵɵNgOnChangesFeature],
  decls: 3,
  vars: 3,
  consts: [
    [3, "cdkPortalOutlet"],
    [4, "ngIf"],
    ["class", "hc-calendar-time-picker", 4, "ngIf"],
    [
      "cdkMonitorSubtreeFocus",
      "",
      "tabindex",
      "-1",
      1,
      "hc-calendar-content",
      3,
      "ngSwitch",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "dateClass",
      "activeDateChange",
      "selectedChange",
      "_userSelection",
      4,
      "ngSwitchCase",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "activeDateChange",
      "monthSelected",
      "selectedChange",
      4,
      "ngSwitchCase",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "activeDateChange",
      "yearSelected",
      "selectedChange",
      4,
      "ngSwitchCase",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "dateClass",
      "activeDateChange",
      "selectedChange",
      "_userSelection",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "activeDateChange",
      "monthSelected",
      "selectedChange",
    ],
    [
      3,
      "activeDate",
      "selected",
      "dateFilter",
      "maxDate",
      "minDate",
      "activeDateChange",
      "yearSelected",
      "selectedChange",
    ],
    [1, "hc-calendar-time-picker"],
    [
      "fontSet",
      "fa",
      "fontIcon",
      "fa-clock-o",
      1,
      "hc-calendar-time-picker-icon",
    ],
    ["inline", "true", 1, "hc-calendar-time-picker-field"],
    [
      "hcInput",
      "",
      "placeholder",
      "hh",
      1,
      "hc-calendar-time-picker-input",
      3,
      "ngModel",
      "ngModelChange",
      "keydown.arrowup",
      "keydown.arrowdown",
    ],
    ["hcSuffix", "", 1, "hc-calendar-time-controls"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "minimal",
      "size",
      "sm",
      1,
      "hc-calendar-time-controls-button",
      3,
      "click",
    ],
    [
      "fontSet",
      "fa",
      "fontIcon",
      "fa-caret-up",
      "hcIconSm",
      "",
      1,
      "hc-calendar-controls-icon",
    ],
    [
      "fontSet",
      "fa",
      "fontIcon",
      "fa-caret-down",
      "hcIconSm",
      "",
      1,
      "hc-calendar-controls-icon",
    ],
    [
      "hcInput",
      "",
      "placeholder",
      "mm",
      1,
      "hc-calendar-time-picker-input",
      3,
      "ngModel",
      "ngModelChange",
      "keydown.arrowup",
      "keydown.arrowdown",
    ],
    ["inline", "true", "class", "hc-calendar-time-picker-field", 4, "ngIf"],
    [1, "hc-calendar-time-picker-select", 3, "formControl", "change"],
    ["value", "am"],
    ["value", "pm"],
  ],
  template: function CalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵtemplate(
        0,
        CalendarComponent_ng_template_0_Template,
        0,
        0,
        "ng-template",
        0
      );
      ɵngcc0.ɵɵtemplate(
        1,
        CalendarComponent_ng_container_1_Template,
        5,
        4,
        "ng-container",
        1
      );
      ɵngcc0.ɵɵtemplate(2, CalendarComponent_div_2_Template, 17, 3, "div", 2);
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("cdkPortalOutlet", ctx._calendarHeaderPortal);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx.mode !== "time");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx.mode !== "date");
    }
  },
  directives: function () {
    return [
      ɵngcc8.CdkPortalOutlet,
      ɵngcc1.NgIf,
      ɵngcc2.CdkMonitorFocus,
      ɵngcc1.NgSwitch,
      ɵngcc1.NgSwitchCase,
      MonthViewComponent,
      YearViewComponent,
      MultiYearViewComponent,
      IconComponent,
      HcFormFieldComponent,
      ɵngcc7.DefaultValueAccessor,
      InputDirective,
      ɵngcc7.NgControlStatus,
      ɵngcc7.NgModel,
      HcSuffixDirective,
      ButtonComponent,
      HcIconSmallDirective,
      SelectComponent,
      ɵngcc7.FormControlDirective,
      ɵngcc7.NgSelectOption,
      ɵngcc7.ɵangular_packages_forms_forms_x,
    ];
  },
  styles: [
    "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-header{padding:0 8px}.hc-calendar-content{outline:0;padding:0 8px 8px}.hc-calendar-controls{display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:0 calc(33% / 7 - 16px) 5%}.hc-calendar-control-button.hc-calendar-period-button,.hc-calendar-control-button.hc-calendar-today-button{font-size:14px;min-width:inherit;padding:10px}.hc-calendar-control-button.hc-calendar-next-button,.hc-calendar-control-button.hc-calendar-previous-button{color:#00aeff;height:40px;min-width:inherit;padding:0;position:relative;top:-2px;width:40px}.hc-calendar-control-button.hc-calendar-next-button::after,.hc-calendar-control-button.hc-calendar-previous-button::after{border:0 solid currentColor;border-top-width:2px;bottom:0;content:'';left:0;margin:15.5px;position:absolute;right:0;top:0}[dir=rtl] .hc-calendar-control-button.hc-calendar-next-button,[dir=rtl] .hc-calendar-control-button.hc-calendar-previous-button{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-calendar-dropdown-caret{border-left:5px solid transparent;border-right:5px solid transparent;border-top-style:solid;border-top-width:5px;display:inline-block;height:0;margin:0 0 0 5px;vertical-align:middle;width:0}[dir=rtl] .hc-calendar-dropdown-caret{margin:0 5px 0 0}.hc-calendar-dropdown-caret.hc-calendar-dropdown-caret-invert{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-calendar-previous-button::after{border-left-width:2px!important;-webkit-transform:translateX(2px) rotate(-45deg);transform:translateX(2px) rotate(-45deg)}.hc-calendar-next-button::after{border-right-width:2px!important;-webkit-transform:translateX(-2px) rotate(45deg);transform:translateX(-2px) rotate(45deg)}.hc-calendar-month-label{-webkit-box-align:center;align-items:center;color:#00aeff;display:-webkit-inline-box;display:inline-flex;font-size:1.07143rem;font-weight:600;height:35px;-webkit-box-pack:center;justify-content:center;line-height:15px;min-width:35px;vertical-align:baseline}.hc-calendar-table{border-collapse:collapse;border-spacing:0;width:100%}.hc-calendar-table-header{color:#00aeff}.hc-calendar-table-header th{font-size:.64286rem;color:#6d6e70;padding:0 0 8px;text-align:center}.hc-calendar-table-header-divider{height:2px;position:relative}.hc-calendar-table-header-divider::after{background:#e0e0e0;content:'';height:2px;left:0;position:absolute;right:0;top:0}.hc-calendar-time-picker{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;margin-top:10px}.hc-calendar-time-picker-field{margin:0 3px}.hc-calendar-time-picker-input{width:25px}.hc-calendar-time-controls{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.hc-calendar-time-controls-button{height:16px!important;line-height:16px!important;padding:0!important;width:16px!important}.hc-calendar-controls-icon{line-height:1!important}.hc-calendar-time-picker-select{width:70px}.hc-calendar-time-picker-icon{color:#708090;font-size:25px;height:25px;margin-right:10px;width:25px}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
CalendarComponent.ctorParameters = () => [
  { type: HcDatepickerIntl },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_FORMATS] }],
  },
  { type: ChangeDetectorRef },
];
CalendarComponent.propDecorators = {
  headerComponent: [{ type: Input }],
  startAt: [{ type: Input }],
  startView: [{ type: Input }],
  mode: [{ type: Input }],
  hourCycle: [{ type: Input }],
  selected: [{ type: Input }],
  minDate: [{ type: Input }],
  maxDate: [{ type: Input }],
  dateFilter: [{ type: Input }],
  dateClass: [{ type: Input }],
  selectedChange: [{ type: Output }],
  yearSelected: [{ type: Output }],
  monthSelected: [{ type: Output }],
  _userSelection: [{ type: Output }],
  monthView: [
    { type: ViewChild, args: [MonthViewComponent, { static: false }] },
  ],
  yearView: [{ type: ViewChild, args: [YearViewComponent, { static: false }] }],
  multiYearView: [
    { type: ViewChild, args: [MultiYearViewComponent, { static: false }] },
  ],
};
if (false) {
  /**
   * An input indicating the type of the header component, if set.
   * @type {?}
   */
  CalendarComponent.prototype.headerComponent;
  /**
   * A portal containing the header component type for this calendar.
   * @type {?}
   */
  CalendarComponent.prototype._calendarHeaderPortal;
  /**
   * Stores the current am/pm value
   * @type {?}
   */
  CalendarComponent.prototype._period;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._intlChanges;
  /**
   * Used for scheduling that focus should be moved to the active cell on the next tick.
   * We need to schedule it, rather than do it immediately, because we have to wait
   * for Angular to re-evaluate the view children.
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._moveFocusOnNextTick;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._startAt;
  /**
   * Whether the calendar should be started in month or year view.
   * @type {?}
   */
  CalendarComponent.prototype.startView;
  /**
   * Whether the calendar should show calendar, time-picker, or both
   * @type {?}
   */
  CalendarComponent.prototype.mode;
  /** @type {?} */
  CalendarComponent.prototype._hourCycle;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._selected;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._minDate;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._maxDate;
  /**
   * Function used to filter which dates are selectable.
   * @type {?}
   */
  CalendarComponent.prototype.dateFilter;
  /**
   * Function that can be used to add custom CSS classes to dates.
   * @type {?}
   */
  CalendarComponent.prototype.dateClass;
  /**
   * Emits when the currently selected date changes.
   * @type {?}
   */
  CalendarComponent.prototype.selectedChange;
  /**
   * Emits the year chosen in multiyear view.
   * This doesn't imply a change on the selected date.
   * @type {?}
   */
  CalendarComponent.prototype.yearSelected;
  /**
   * Emits the month chosen in year view.
   * This doesn't imply a change on the selected date.
   * @type {?}
   */
  CalendarComponent.prototype.monthSelected;
  /**
   * Emits when any date is selected.
   * @type {?}
   */
  CalendarComponent.prototype._userSelection;
  /**
   * Reference to the current month view component.
   * @type {?}
   */
  CalendarComponent.prototype.monthView;
  /**
   * Reference to the current year view component.
   * @type {?}
   */
  CalendarComponent.prototype.yearView;
  /**
   * Reference to the current multi-year view component.
   * @type {?}
   */
  CalendarComponent.prototype.multiYearView;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._clampedActiveDate;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._currentView;
  /**
   * Emits whenever there is a state change that the header may need to respond to.
   * @type {?}
   */
  CalendarComponent.prototype.stateChanges;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._intl;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._dateFormats;
  /**
   * @type {?}
   * @private
   */
  CalendarComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker-animations.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animations used by the Material datepicker.
 * \@docs-private
 * @type {?}
 */
const HcDatepickerAnimations = {
  /**
   * Transforms the height of the datepicker's calendar.
   */
  transformPanel: trigger("transformPanel", [
    state(
      "void",
      style({
        opacity: 0,
        transform: "scale(1, 0.8)",
      })
    ),
    transition(
      "void => enter",
      animate(
        "120ms cubic-bezier(0, 0, 0.2, 1)",
        style({
          opacity: 1,
          transform: "scale(1, 1)",
        })
      )
    ),
    transition("* => void", animate("100ms linear", style({ opacity: 0 }))),
  ]),
  /**
   * Fades in the content of the calendar.
   */
  fadeInCalendar: trigger("fadeInCalendar", [
    state("void", style({ opacity: 0 })),
    state("enter", style({ opacity: 1 })),
    // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we
    // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.
    transition(
      "void => *",
      animate("120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
    ),
  ]),
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker-content/datepicker-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component used as the content for the datepicker popup. We use this instead of using
 * hcCalendar directly as the content so we can control the initial focus. This also gives us a
 * place to put additional features of the popup that are not part of the calendar itself in the
 * future. (e.g. confirmation buttons).
 * \@docs-private
 */
class DatepickerContentComponent {
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    this._calendar.focusActiveCell();
  }
  /**
   * Close the datepicker automatically on selection only if in date mode
   * @return {?}
   */
  autoClose() {
    if (this.datepicker.mode === "date") {
      this.datepicker.close();
    }
  }
}
DatepickerContentComponent.ɵfac = function DatepickerContentComponent_Factory(
  t
) {
  return new (t || DatepickerContentComponent)();
};
DatepickerContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: DatepickerContentComponent,
  selectors: [["hc-datepicker-content"]],
  viewQuery: function DatepickerContentComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(CalendarComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._calendar = _t.first);
    }
  },
  hostAttrs: [1, "hc-datepicker-content"],
  hostVars: 1,
  hostBindings: function DatepickerContentComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵsyntheticHostProperty("@transformPanel", "enter");
    }
  },
  exportAs: ["hcDatepickerContent"],
  decls: 1,
  vars: 13,
  consts: [
    [
      "cdkTrapFocus",
      "",
      3,
      "id",
      "ngClass",
      "mode",
      "hourCycle",
      "startAt",
      "startView",
      "minDate",
      "maxDate",
      "dateFilter",
      "headerComponent",
      "selected",
      "dateClass",
      "selectedChange",
      "yearSelected",
      "monthSelected",
      "_userSelection",
    ],
  ],
  template: function DatepickerContentComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "hc-calendar", 0);
      ɵngcc0.ɵɵlistener(
        "selectedChange",
        function DatepickerContentComponent_Template_hc_calendar_selectedChange_0_listener(
          $event
        ) {
          return ctx.datepicker.select($event);
        }
      )(
        "yearSelected",
        function DatepickerContentComponent_Template_hc_calendar_yearSelected_0_listener(
          $event
        ) {
          return ctx.datepicker._selectYear($event);
        }
      )(
        "monthSelected",
        function DatepickerContentComponent_Template_hc_calendar_monthSelected_0_listener(
          $event
        ) {
          return ctx.datepicker._selectMonth($event);
        }
      )(
        "_userSelection",
        function DatepickerContentComponent_Template_hc_calendar__userSelection_0_listener() {
          return ctx.autoClose();
        }
      );
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("id", ctx.datepicker.id)(
        "ngClass",
        ctx.datepicker.panelClass
      )("mode", ctx.datepicker.mode)("hourCycle", ctx.datepicker.hourCycle)(
        "startAt",
        ctx.datepicker.startAt
      )("startView", ctx.datepicker.startView)(
        "minDate",
        ctx.datepicker._minDate
      )("maxDate", ctx.datepicker._maxDate)(
        "dateFilter",
        ctx.datepicker._dateFilter
      )("headerComponent", ctx.datepicker.calendarHeaderComponent)(
        "selected",
        ctx.datepicker._selected
      )("dateClass", ctx.datepicker.dateClass)("@fadeInCalendar", "enter");
    }
  },
  directives: [CalendarComponent, ɵngcc2.CdkTrapFocus, ɵngcc1.NgClass],
  encapsulation: 2,
  data: {
    animation: [
      HcDatepickerAnimations.transformPanel,
      HcDatepickerAnimations.fadeInCalendar,
    ],
  },
  changeDetection: 0,
});
DatepickerContentComponent.propDecorators = {
  _calendar: [
    { type: ViewChild, args: [CalendarComponent, { static: false }] },
  ],
};
if (false) {
  /**
   * Reference to the internal calendar component.
   * @type {?}
   */
  DatepickerContentComponent.prototype._calendar;
  /**
   * Reference to the datepicker that created the overlay.
   * @type {?}
   */
  DatepickerContentComponent.prototype.datepicker;
  /**
   * Whether the datepicker is above or below the input.
   * @type {?}
   */
  DatepickerContentComponent.prototype._isAbove;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/utils/boolean-property.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Coerces a data-bound value (typically a string) to a boolean.
 * @param {?} value
 * @return {?}
 */
function coerceBooleanProperty(value) {
  return value != null && `${value}` !== "false";
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:no-output-rename
/**
 * Used to generate a unique ID for each datepicker instance.
 * @type {?}
 */
let datepickerUid = 0;
/**
 * Injection token that determines the scroll handling while the calendar is open.
 * @type {?}
 */
const HC_DATEPICKER_SCROLL_STRATEGY = new InjectionToken(
  "hc-datepicker-scroll-strategy"
);
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function HC_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {
  return (
    /**
     * @return {?}
     */
    () => overlay.scrollStrategies.reposition()
  );
}
/**
 * \@docs-private
 * @type {?}
 */
const HC_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: HC_DATEPICKER_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: HC_DATEPICKER_SCROLL_STRATEGY_FACTORY,
};
// Boilerplate for applying mixins to hcDatepickerContent.
/**
 * \@docs-private
 */
class HcDatepickerContentBase {
  /**
   * @param {?} _elementRef
   */
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
}
if (false) {
  /** @type {?} */
  HcDatepickerContentBase.prototype._elementRef;
}
/**
 * Component responsible for managing the datepicker popup
 */
class DatepickerComponent {
  /**
   * @param {?} _overlay
   * @param {?} _ngZone
   * @param {?} _viewContainerRef
   * @param {?} scrollStrategy
   * @param {?} _dateAdapter
   * @param {?} _dir
   * @param {?} _document
   */
  constructor(
    _overlay,
    _ngZone,
    _viewContainerRef,
    scrollStrategy,
    _dateAdapter,
    _dir,
    _document
  ) {
    this._overlay = _overlay;
    this._ngZone = _ngZone;
    this._viewContainerRef = _viewContainerRef;
    this._dateAdapter = _dateAdapter;
    this._dir = _dir;
    this._document = _document;
    this._mode = "date";
    this._hourCycle = 12;
    /**
     * The view that the calendar should start in.
     */
    this.startView = "month";
    this._touchUi = false;
    /**
     * Emits selected year in multiyear view.
     * This doesn't imply a change on the selected date.
     */
    this.yearSelected = new EventEmitter();
    /**
     * Emits selected month in year view.
     * This doesn't imply a change on the selected date.
     */
    this.monthSelected = new EventEmitter();
    /**
     * Emits when the datepicker has been opened.
     */
    this.openedStream = new EventEmitter();
    /**
     * Emits when the datepicker has been closed.
     */
    this.closedStream = new EventEmitter();
    this._opened = false;
    /**
     * The id for the datepicker calendar.
     */
    this.id = `hc-datepicker-${datepickerUid++}`;
    this._validSelected = null;
    /**
     * The element that was focused before the datepicker was opened.
     */
    this._focusedElementBeforeOpen = null;
    /**
     * Subscription to value changes in the associated input element.
     */
    this._inputSubscription = Subscription.EMPTY;
    /**
     * Emits when the datepicker is disabled.
     */
    this._disabledChange = new Subject();
    /**
     * Emits new selected date when selected date changes.
     */
    this._selectedChanged = new Subject();
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    this._scrollStrategy = scrollStrategy;
  }
  /**
   * Whether the datepicker includes the calendar, time selector, or both. Defaults to `date`.
   * @return {?}
   */
  get mode() {
    return this._mode;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set mode(value) {
    this._mode = value;
    if (this._selected) {
      this._selectedChanged.next(this._selected);
    }
  }
  /**
   * Whether the time picker uses a 12 or 24 hour clock. Defaults to 12.
   * @return {?}
   */
  get hourCycle() {
    return this._hourCycle;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set hourCycle(value) {
    if (+value !== this._hourCycle) {
      this._hourCycle = +value;
      if (this._selected) {
        this._selectedChanged.next(this._selected);
      }
    }
  }
  /**
   * The date to open the calendar to initially.
   * @return {?}
   */
  get startAt() {
    // If an explicit startAt is set we start there, otherwise we start at whatever the currently
    // selected value is.
    return (
      this._startAt ||
      (this._datepickerInput ? this._datepickerInput.value : null)
    );
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set startAt(value) {
    this._startAt = this._getValidDateOrNull(
      this._dateAdapter.deserialize(value)
    );
  }
  /**
   * @deprecated
   * \@description The datepicker now only uses `hcPop` to display
   *
   * @return {?}
   */
  get touchUi() {
    return this._touchUi;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set touchUi(value) {
    this._touchUi = coerceBooleanProperty(value);
  }
  /**
   * Whether the datepicker pop-up should be disabled.
   * @return {?}
   */
  get disabled() {
    return this._disabled === undefined && this._datepickerInput
      ? this._datepickerInput.disabled
      : !!this._disabled;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set disabled(value) {
    /** @type {?} */
    const newValue = coerceBooleanProperty(value);
    if (newValue !== this._disabled) {
      this._disabled = newValue;
      this._disabledChange.next(newValue);
    }
  }
  /**
   * Whether the calendar is open.
   * @return {?}
   */
  get opened() {
    return this._opened;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set opened(value) {
    value ? this.open() : this.close();
  }
  /**
   * The currently selected date.
   * @return {?}
   */
  get _selected() {
    return this._validSelected;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set _selected(value) {
    this._validSelected = value;
  }
  /**
   * The minimum selectable date.
   * @return {?}
   */
  get _minDate() {
    return this._datepickerInput && this._datepickerInput.min;
  }
  /**
   * The maximum selectable date.
   * @return {?}
   */
  get _maxDate() {
    return this._datepickerInput && this._datepickerInput.max;
  }
  /**
   * @return {?}
   */
  get _dateFilter() {
    return this._datepickerInput && this._datepickerInput._dateFilter;
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.close();
    this._inputSubscription.unsubscribe();
    this._disabledChange.complete();
    if (this._popupRef) {
      this._popupRef.dispose();
      this._popupComponentRef = null;
    }
  }
  /**
   * Selects the given date
   * @param {?} date
   * @return {?}
   */
  select(date) {
    /** @type {?} */
    const oldValue = this._selected;
    this._selected = date;
    if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
      this._selectedChanged.next(date);
    }
  }
  /**
   * Emits the selected year in multiyear view
   * @param {?} normalizedYear
   * @return {?}
   */
  _selectYear(normalizedYear) {
    this.yearSelected.emit(normalizedYear);
  }
  /**
   * Emits selected month in year view
   * @param {?} normalizedMonth
   * @return {?}
   */
  _selectMonth(normalizedMonth) {
    this.monthSelected.emit(normalizedMonth);
  }
  /**
   * Register an input with this datepicker.
   * @param {?} input The datepicker input to register with this datepicker.
   * @return {?}
   */
  _registerInput(input) {
    if (this._datepickerInput) {
      throw Error("A hcDatepicker can only be associated with a single input.");
    }
    this._datepickerInput = input;
    this._inputSubscription = this._datepickerInput._valueChange.subscribe(
      /**
       * @param {?} value
       * @return {?}
       */
      (value) => (this._selected = value)
    );
  }
  /**
   * Open the calendar.
   * @return {?}
   */
  open() {
    if (this._opened || this.disabled) {
      return;
    }
    if (!this._datepickerInput) {
      throw Error(
        "Attempted to open an hcDatepicker with no associated input."
      );
    }
    if (this._document) {
      this._focusedElementBeforeOpen = this._document.activeElement;
    }
    this._openAsPopup();
    this._opened = true;
    this.openedStream.emit();
  }
  /**
   * Close the calendar.
   * @return {?}
   */
  close() {
    if (!this._opened) {
      return;
    }
    if (this._popupRef && this._popupRef.hasAttached()) {
      this._popupRef.detach();
      this._popupRef.dispose();
      this._popupRef = null;
    }
    if (this._calendarPortal && this._calendarPortal.isAttached) {
      this._calendarPortal.detach();
    }
    /** @type {?} */
    const completeClose =
      /**
       * @return {?}
       */
      () => {
        // The `_opened` could've been reset already if
        // we got two events in quick succession.
        if (this._opened) {
          this._opened = false;
          this.closedStream.emit();
          this._focusedElementBeforeOpen = null;
        }
      };
    if (
      this._focusedElementBeforeOpen &&
      typeof this._focusedElementBeforeOpen.focus === "function"
    ) {
      // Because IE moves focus asynchronously, we can't count on it being restored before we've
      // marked the datepicker as closed. If the event fires out of sequence and the element that
      // we're refocusing opens the datepicker on focus, the user could be stuck with not being
      // able to close the calendar at all. We work around it by making the logic, that marks
      // the datepicker as closed, async as well.
      this._focusedElementBeforeOpen.focus();
      setTimeout(completeClose);
    } else {
      completeClose();
    }
  }
  /**
   * Open the calendar as a popup.
   * @private
   * @return {?}
   */
  _openAsPopup() {
    if (!this._calendarPortal) {
      this._calendarPortal = new ComponentPortal(
        DatepickerContentComponent,
        this._viewContainerRef
      );
    }
    if (!this._popupRef) {
      this._createPopup();
    }
    if (this._popupRef && !this._popupRef.hasAttached()) {
      this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
      this._popupComponentRef.instance.datepicker = this;
      // Update the position once the calendar has rendered.
      this._ngZone.onStable
        .asObservable()
        .pipe(take(1))
        .subscribe(
          /**
           * @return {?}
           */
          () => {
            if (this._popupRef) {
              this._popupRef.updatePosition();
            }
          }
        );
    }
  }
  /**
   * Create the popup.
   * @private
   * @return {?}
   */
  _createPopup() {
    /** @type {?} */
    const overlayConfig = new OverlayConfig({
      positionStrategy: this._createPopupPositionStrategy(),
      hasBackdrop: true,
      backdropClass: "hc-overlay-transparent-backdrop",
      direction: this._dir,
      scrollStrategy: this._scrollStrategy(),
      panelClass: "hc-datepicker-popup",
    });
    this._popupRef = this._overlay.create(overlayConfig);
    this._popupRef.overlayElement.setAttribute("role", "dialog");
    merge(
      this._popupRef.backdropClick(),
      this._popupRef.detachments(),
      this._popupRef.keydownEvents().pipe(
        filter(
          /**
           * @param {?} event
           * @return {?}
           */
          (event) => {
            // Closing on alt + up is only valid when there's an input associated with the datepicker.
            return (
              event.keyCode === ESCAPE ||
              (this._datepickerInput &&
                event.altKey &&
                event.keyCode === UP_ARROW)
            );
          }
        )
      )
    ).subscribe(
      /**
       * @return {?}
       */
      () => this.close()
    );
  }
  /**
   * Create the popup PositionStrategy.
   * @private
   * @return {?}
   */
  _createPopupPositionStrategy() {
    return this._overlay
      .position()
      .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
      .withTransformOriginOn(".hc-datepicker-content")
      .withFlexibleDimensions(false)
      .withViewportMargin(8)
      .withLockedPosition()
      .withPositions([
        {
          originX: "start",
          originY: "bottom",
          overlayX: "start",
          overlayY: "top",
          // hc form field wrapper bottom margin
          offsetY: -20,
        },
        {
          originX: "start",
          originY: "top",
          overlayX: "start",
          overlayY: "center",
        },
        {
          originX: "end",
          originY: "bottom",
          overlayX: "end",
          overlayY: "top",
        },
        {
          originX: "end",
          originY: "top",
          overlayX: "end",
          overlayY: "bottom",
          offsetY: 60,
        },
      ]);
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
}
DatepickerComponent.ɵfac = function DatepickerComponent_Factory(t) {
  return new (t || DatepickerComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef),
    ɵngcc0.ɵɵdirectiveInject(HC_DATEPICKER_SCROLL_STRATEGY),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8),
    ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)
  );
};
DatepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: DatepickerComponent,
  selectors: [["hc-datepicker"]],
  inputs: {
    startView: "startView",
    mode: "mode",
    hourCycle: "hourCycle",
    startAt: "startAt",
    touchUi: "touchUi",
    disabled: "disabled",
    opened: "opened",
    calendarHeaderComponent: "calendarHeaderComponent",
    panelClass: "panelClass",
    dateClass: "dateClass",
  },
  outputs: {
    yearSelected: "yearSelected",
    monthSelected: "monthSelected",
    openedStream: "opened",
    closedStream: "closed",
  },
  exportAs: ["hcDatepicker"],
  decls: 0,
  vars: 0,
  template: function DatepickerComponent_Template(rf, ctx) {},
  styles: [
    "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-datepicker-content{background-color:#fff;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;display:block;height:100%;width:310px}.hc-datepicker-toggle-active{color:#00aeff}.hc-calendar{display:block;height:100%;padding:10px 0 20px;width:310px}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
DatepickerComponent.ctorParameters = () => [
  { type: Overlay },
  { type: NgZone },
  { type: ViewContainerRef },
  {
    type: undefined,
    decorators: [{ type: Inject, args: [HC_DATEPICKER_SCROLL_STRATEGY] }],
  },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  { type: Directionality, decorators: [{ type: Optional }] },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT] }],
  },
];
DatepickerComponent.propDecorators = {
  mode: [{ type: Input }],
  hourCycle: [{ type: Input }],
  calendarHeaderComponent: [{ type: Input }],
  startAt: [{ type: Input }],
  startView: [{ type: Input }],
  touchUi: [{ type: Input }],
  disabled: [{ type: Input }],
  yearSelected: [{ type: Output }],
  monthSelected: [{ type: Output }],
  panelClass: [{ type: Input }],
  dateClass: [{ type: Input }],
  openedStream: [{ type: Output, args: ["opened"] }],
  closedStream: [{ type: Output, args: ["closed"] }],
  opened: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._scrollStrategy;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._mode;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._hourCycle;
  /**
   * An input indicating the type of the custom header component for the calendar, if set.
   * @type {?}
   */
  DatepickerComponent.prototype.calendarHeaderComponent;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._startAt;
  /**
   * The view that the calendar should start in.
   * @type {?}
   */
  DatepickerComponent.prototype.startView;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._touchUi;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._disabled;
  /**
   * Emits selected year in multiyear view.
   * This doesn't imply a change on the selected date.
   * @type {?}
   */
  DatepickerComponent.prototype.yearSelected;
  /**
   * Emits selected month in year view.
   * This doesn't imply a change on the selected date.
   * @type {?}
   */
  DatepickerComponent.prototype.monthSelected;
  /**
   * Classes to be passed to the date picker panel. Supports the same syntax as `ngClass`.
   * @type {?}
   */
  DatepickerComponent.prototype.panelClass;
  /**
   * Function that can be used to add custom CSS classes to dates.
   * @type {?}
   */
  DatepickerComponent.prototype.dateClass;
  /**
   * Emits when the datepicker has been opened.
   * @type {?}
   */
  DatepickerComponent.prototype.openedStream;
  /**
   * Emits when the datepicker has been closed.
   * @type {?}
   */
  DatepickerComponent.prototype.closedStream;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._opened;
  /**
   * The id for the datepicker calendar.
   * @type {?}
   */
  DatepickerComponent.prototype.id;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._validSelected;
  /**
   * A reference to the overlay when the calendar is opened as a popup.
   * @type {?}
   */
  DatepickerComponent.prototype._popupRef;
  /**
   * A portal containing the calendar for this datepicker.
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._calendarPortal;
  /**
   * Reference to the component instantiated in popup mode.
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._popupComponentRef;
  /**
   * The element that was focused before the datepicker was opened.
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._focusedElementBeforeOpen;
  /**
   * Subscription to value changes in the associated input element.
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._inputSubscription;
  /**
   * The input element this datepicker is associated with.
   * @type {?}
   */
  DatepickerComponent.prototype._datepickerInput;
  /**
   * Emits when the datepicker is disabled.
   * @type {?}
   */
  DatepickerComponent.prototype._disabledChange;
  /**
   * Emits new selected date when selected date changes.
   * @type {?}
   */
  DatepickerComponent.prototype._selectedChanged;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._overlay;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._ngZone;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._viewContainerRef;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._dir;
  /**
   * @type {?}
   * @private
   */
  DatepickerComponent.prototype._document;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-error.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Single error to be shown under HcFormFieldComponent
 */
class HcErrorComponent {
  constructor() {
    this._hostClass = true;
  }
}
HcErrorComponent.ɵfac = function HcErrorComponent_Factory(t) {
  return new (t || HcErrorComponent)();
};
HcErrorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcErrorComponent,
  selectors: [["hc-error"]],
  hostVars: 2,
  hostBindings: function HcErrorComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-error", ctx._hostClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function HcErrorComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
HcErrorComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-error"] }],
};
if (false) {
  /** @type {?} */
  HcErrorComponent.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-prefix.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Position an element at the front of HcFormFieldComponent
 */
class HcPrefixDirective {
  constructor() {
    this._hostHcPrefixClass = true;
  }
}
HcPrefixDirective.ɵfac = function HcPrefixDirective_Factory(t) {
  return new (t || HcPrefixDirective)();
};
HcPrefixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcPrefixDirective,
  selectors: [["", "hcPrefix", ""]],
  hostVars: 2,
  hostBindings: function HcPrefixDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-prefix", ctx._hostHcPrefixClass);
    }
  },
});
HcPrefixDirective.propDecorators = {
  _hostHcPrefixClass: [{ type: HostBinding, args: ["class.hc-prefix"] }],
};
if (false) {
  /** @type {?} */
  HcPrefixDirective.prototype._hostHcPrefixClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-suffix.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Position an element at the end of HcFormFieldComponent
 */
class HcSuffixDirective {
  constructor() {
    this._hostHcSuffixClass = true;
  }
}
HcSuffixDirective.ɵfac = function HcSuffixDirective_Factory(t) {
  return new (t || HcSuffixDirective)();
};
HcSuffixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcSuffixDirective,
  selectors: [["", "hcSuffix", ""]],
  hostVars: 2,
  hostBindings: function HcSuffixDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-suffix", ctx._hostHcSuffixClass);
    }
  },
});
HcSuffixDirective.propDecorators = {
  _hostHcSuffixClass: [{ type: HostBinding, args: ["class.hc-suffix"] }],
};
if (false) {
  /** @type {?} */
  HcSuffixDirective.prototype._hostHcSuffixClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-label.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Label for HcFormFieldComponent
 */
class HcLabelComponent {}
HcLabelComponent.ɵfac = function HcLabelComponent_Factory(t) {
  return new (t || HcLabelComponent)();
};
HcLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcLabelComponent,
  selectors: [["hc-label"]],
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function HcLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/input/input.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} type
 * @return {?}
 */
function getUnsupportedHCInputType(type) {
  return new Error(`hc-input doesn't support the following type: ${type}`);
}
/** @type {?} */
let uniqueId = 1;
/** @type {?} */
const unsupportedTypes = [
  "button",
  "checkbox",
  "file",
  "hidden",
  "image",
  "radio",
  "reset",
];
/**
 * Directive that allows a native input to work inside a HcFormFieldComponent
 */
class InputDirective extends HcFormControlComponent {
  /**
   * @param {?} _elementRef
   * @param {?} _parentForm
   * @param {?} _parentFormGroup
   * @param {?} _ngControl
   */
  constructor(_elementRef, _parentForm, _parentFormGroup, _ngControl) {
    super();
    this._elementRef = _elementRef;
    this._ngControl = _ngControl;
    this._focused = false;
    this._uniqueInputId = `hc-input-${uniqueId++}`;
    this._componentId = this._uniqueInputId;
    this._type = "input";
    this._readonly = false;
    this.focusChanged = new EventEmitter();
    this._hostHcInputClass = true;
    this._form = _parentForm || _parentFormGroup;
  }
  /**
   * Input type of the element.
   * @return {?}
   */
  get type() {
    return this._type;
  }
  /**
   * @param {?} type
   * @return {?}
   */
  set type(type) {
    if (unsupportedTypes.indexOf(type) > -1) {
      throw getUnsupportedHCInputType(type);
    }
    this._type = type;
    // textArea doesn't have type property
    if (!this._isTextArea()) {
      this._elementRef.nativeElement.type = this.type;
    }
  }
  /**
   * Element id.
   * @return {?}
   */
  get id() {
    return this._componentId || this._uniqueInputId;
  }
  /**
   * @param {?} idVal
   * @return {?}
   */
  set id(idVal) {
    this._componentId = idVal ? idVal : this._uniqueInputId;
  }
  /**
   * Sets input element as readonly.
   * @return {?}
   */
  get readonly() {
    return this._readonly;
  }
  /**
   * @param {?} isReadOnly
   * @return {?}
   */
  set readonly(isReadOnly) {
    this._readonly = parseBooleanAttribute(isReadOnly);
  }
  /**
   * Disables the input element.
   * @return {?}
   */
  get disabled() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @param {?} disabledInput
   * @return {?}
   */
  set disabled(disabledInput) {
    this._isDisabled = parseBooleanAttribute(disabledInput);
    if (this._focused) {
      this._focused = false;
      // TODO: trigger state change
    }
  }
  /**
   * Sets required attribute.
   * @return {?}
   */
  get required() {
    return this._isRequired;
  }
  /**
   * @param {?} requiredInput
   * @return {?}
   */
  set required(requiredInput) {
    this._isRequired = parseBooleanAttribute(requiredInput);
  }
  /**
   * @return {?}
   */
  get _hostId() {
    return this._componentId || this._uniqueInputId;
  }
  /**
   * @return {?}
   */
  get _hostReadOnly() {
    return this.readonly;
  }
  /**
   * @return {?}
   */
  get _hostDisabled() {
    return this.disabled;
  }
  /**
   * @return {?}
   */
  get _hostRequired() {
    return this._isRequired;
  }
  /**
   * @return {?}
   */
  _onBlur() {
    this._changeFocus(false);
  }
  /**
   * @return {?}
   */
  _onFocus() {
    this._changeFocus(true);
  }
  /**
   * Sets value of the input element
   * @return {?}
   */
  get value() {
    return this._elementRef.nativeElement.value;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set value(value) {
    if (value !== this.value) {
      this._elementRef.nativeElement.value = value;
    }
  }
  /**
   * @return {?}
   */
  _inputEvent() {
    // causes angular to run change detection on input event
  }
  /**
   * @return {?}
   */
  ngDoCheck() {
    // This needs to be checked every cycle because we can't subscribe to form submissions
    if (this._ngControl) {
      this._updateErrorState();
    }
  }
  /**
   * Sets the focus on the input element
   * @return {?}
   */
  focus() {
    this._elementRef.nativeElement.focus();
  }
  /**
   * @private
   * @param {?} focused
   * @return {?}
   */
  _changeFocus(focused) {
    if (this._focused !== focused && !this.readonly) {
      this._focused = focused;
      this.focusChanged.emit(focused);
    }
  }
  /**
   * @private
   * @return {?}
   */
  _isTextArea() {
    return this._elementRef.nativeElement.nodeName.toLowerCase() !== "textarea";
  }
  /**
   * @private
   * @return {?}
   */
  _updateErrorState() {
    /** @type {?} */
    const oldState = this._errorState;
    // TODO: this could be abstracted out as an @Input() if we need this to be configurable
    /** @type {?} */
    const newState = !!(
      this._ngControl &&
      this._ngControl.invalid &&
      (this._ngControl.touched || (this._form && this._form.submitted))
    );
    if (oldState !== newState) {
      this._errorState = newState;
    }
  }
}
InputDirective.ɵfac = function InputDirective_Factory(t) {
  return new (t || InputDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgForm, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FormGroupDirective, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgControl, 10)
  );
};
InputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: InputDirective,
  selectors: [["", "hcInput", ""]],
  hostVars: 6,
  hostBindings: function InputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "blur",
        function InputDirective_blur_HostBindingHandler() {
          return ctx._onBlur();
        }
      )("focus", function InputDirective_focus_HostBindingHandler() {
        return ctx._onFocus();
      })("input", function InputDirective_input_HostBindingHandler() {
        return ctx._inputEvent();
      });
    }
    if (rf & 2) {
      ɵngcc0.ɵɵhostProperty("readonly", ctx._hostReadOnly)(
        "disabled",
        ctx._hostDisabled
      )("required", ctx._hostRequired);
      ɵngcc0.ɵɵattribute("id", ctx._hostId);
      ɵngcc0.ɵɵclassProp("hc-input", ctx._hostHcInputClass);
    }
  },
  inputs: {
    type: "type",
    id: "id",
    readonly: "readonly",
    disabled: "disabled",
    required: "required",
    value: "value",
  },
  outputs: { focusChanged: "focusChanged" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => InputDirective
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/** @nocollapse */
InputDirective.ctorParameters = () => [
  { type: ElementRef },
  { type: NgForm, decorators: [{ type: Optional }] },
  { type: FormGroupDirective, decorators: [{ type: Optional }] },
  { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
];
InputDirective.propDecorators = {
  type: [{ type: Input }],
  id: [{ type: Input }],
  readonly: [{ type: Input }],
  disabled: [{ type: Input }],
  required: [{ type: Input }],
  focusChanged: [{ type: Output }],
  _hostHcInputClass: [{ type: HostBinding, args: ["class.hc-input"] }],
  _hostId: [{ type: HostBinding, args: ["attr.id"] }],
  _hostReadOnly: [{ type: HostBinding, args: ["readonly"] }],
  _hostDisabled: [{ type: HostBinding, args: ["disabled"] }],
  _hostRequired: [{ type: HostBinding, args: ["required"] }],
  _onBlur: [{ type: HostListener, args: ["blur"] }],
  _onFocus: [{ type: HostListener, args: ["focus"] }],
  value: [{ type: Input }],
  _inputEvent: [{ type: HostListener, args: ["input"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._focused;
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._uniqueInputId;
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._form;
  /** @type {?} */
  InputDirective.prototype._componentId;
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._type;
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._readonly;
  /** @type {?} */
  InputDirective.prototype.focusChanged;
  /** @type {?} */
  InputDirective.prototype._hostHcInputClass;
  /**
   * @type {?}
   * @private
   */
  InputDirective.prototype._elementRef;
  /** @type {?} */
  InputDirective.prototype._ngControl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-form-field.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getControlMissing() {
  return new Error(
    `HcFormField must contain a component that extends HcFormControl`
  );
}
/**
 * Container for form fields that applies Cashmere styling and behavior
 */
class HcFormFieldComponent {
  /**
   * @param {?} _elementRef
   */
  constructor(_elementRef) {
    this._elementRef = _elementRef;
    this._inline = false;
    this._tight = false;
    this.unsubscribe$ = new Subject();
    this._classHcFormFieldClass = true;
    this._hasFocusedInput = false;
  }
  /**
   * @return {?}
   */
  get _disabledClass() {
    if (this._inputChildren.length > 0) {
      return this._inputChildren.first.disabled;
    } else {
      return this._control._isDisabled;
    }
  }
  /**
   * Read-only boolean value of whether the form field has an associated label element
   * @return {?}
   */
  get hasLabel() {
    return !!this._labelChildren.length;
  }
  /**
   * Read-only boolean value of whether the form field has an input element
   * @return {?}
   */
  get hasInput() {
    return !!this._inputChildren.length;
  }
  /**
   * Whether the form elements should be stacked (default), or inline
   * @return {?}
   */
  get inline() {
    return this._inline;
  }
  /**
   * @param {?} isInline
   * @return {?}
   */
  set inline(isInline) {
    this._inline = parseBooleanAttribute(isInline);
  }
  /**
   * If true, condense the default padding on all included elements and reduce the font size. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
    this._updateTightControls();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    if (!this._control) {
      throw getControlMissing();
    } else {
      this._updateTightControls();
      // Pass the current tight setting to controls that are added dynamically to the FormField
      this._controls.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(
        /**
         * @return {?}
         */
        () => this._updateTightControls()
      );
    }
    // wire up focus listener for hcInputs
    if (this.hasInput) {
      this._inputChildren.first.focusChanged
        .pipe(takeUntil(this.unsubscribe$))
        .subscribe(
          /**
           * @param {?} focused
           * @return {?}
           */
          (focused) => {
            this._hasFocusedInput = focused;
          }
        );
    }
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  /**
   * @return {?}
   */
  _updateTightControls() {
    if (this._controls) {
      this._controls.forEach(
        /**
         * @param {?} control
         * @return {?}
         */
        (control) => {
          control.tight = this._tight;
        }
      );
    }
  }
  /**
   * @return {?}
   */
  getConnectedOverlayOrigin() {
    return this._elementRef;
  }
  /**
   * @return {?}
   */
  _shouldShowErrorMessages() {
    return (
      this._control._errorState &&
      ((this._errorChildren && this._errorChildren.length > 0) ||
        (!!this._control._errorMessage &&
          this._control._errorMessage.length > 0))
    );
  }
}
HcFormFieldComponent.ɵfac = function HcFormFieldComponent_Factory(t) {
  return new (t || HcFormFieldComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
HcFormFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcFormFieldComponent,
  selectors: [["hc-form-field"]],
  contentQueries: function HcFormFieldComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcFormControlComponent, true);
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcFormControlComponent, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcErrorComponent, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcPrefixDirective, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcSuffixDirective, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, InputDirective, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcLabelComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._control = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._controls = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._errorChildren = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._prefixChildren = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._suffixChildren = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._inputChildren = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._labelChildren = _t);
    }
  },
  hostVars: 4,
  hostBindings: function HcFormFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-form-field", ctx._classHcFormFieldClass)(
        "hc-form-field-disabled",
        ctx._disabledClass
      );
    }
  },
  inputs: { inline: "inline", tight: "tight" },
  ngContentSelectors: _c26,
  decls: 7,
  vars: 12,
  consts: [
    [3, "ngClass", "hc-form-field-label-wrapper-tight", 4, "ngIf"],
    [1, "hc-form-field-content-wrapper"],
    [
      3,
      "hc-form-field-flex",
      "hc-form-field-flex-inline",
      "hc-form-field-invalid",
      "hc-form-field-flex-focused",
      4,
      "ngIf",
    ],
    [
      3,
      "hc-form-field-non-input",
      "hc-form-field-non-input-inline",
      "hc-form-field-non-input-inline-tight",
      "hc-form-field-invalid",
      4,
      "ngIf",
    ],
    ["class", "hc-form-field-error-wrapper", 4, "ngIf"],
    [3, "ngClass"],
    ["class", "hc-required-marker", "aria-hidden", "true", 4, "ngIf"],
    ["aria-hidden", "true", 1, "hc-required-marker"],
    ["class", "hc-form-field-prefix", 4, "ngIf"],
    [1, "hc-form-field-infix"],
    ["inputs", ""],
    ["class", "hc-form-field-suffix", 4, "ngIf"],
    [1, "hc-form-field-prefix"],
    [1, "hc-form-field-suffix"],
    [1, "hc-form-field-error-wrapper"],
    [4, "ngIf"],
  ],
  template: function HcFormFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c25);
      ɵngcc0.ɵɵelementStart(0, "div");
      ɵngcc0.ɵɵtemplate(
        1,
        HcFormFieldComponent_span_1_Template,
        4,
        8,
        "span",
        0
      );
      ɵngcc0.ɵɵelementStart(2, "div", 1);
      ɵngcc0.ɵɵprojection(3);
      ɵngcc0.ɵɵtemplate(
        4,
        HcFormFieldComponent_div_4_Template,
        6,
        12,
        "div",
        2
      );
      ɵngcc0.ɵɵtemplate(5, HcFormFieldComponent_div_5_Template, 2, 8, "div", 3);
      ɵngcc0.ɵɵtemplate(6, HcFormFieldComponent_div_6_Template, 3, 1, "div", 4);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-form-field-wrapper-inline", ctx.inline)(
        "hc-form-field-wrapper",
        !ctx.inline
      )("hc-form-field-no-label", !ctx.hasLabel)(
        "hc-form-field-wrapper-tight",
        ctx.tight
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx.hasLabel);
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngIf", ctx.hasInput);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", !ctx.hasInput);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._shouldShowErrorMessages());
    }
  },
  directives: [ɵngcc1.NgIf, ɵngcc1.NgClass, HcErrorComponent],
  styles: [
    ".hc-form-field{position:relative;text-align:left;font-size:inherit;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif;font-weight:400;line-height:1.5;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit}.hc-form-field-wrapper{position:relative;padding-bottom:1.525em;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit}.hc-form-field-wrapper-inline{display:-webkit-inline-box;display:inline-flex;width:100%;padding-bottom:inherit}.hc-form-field-wrapper-tight{padding-bottom:10px}.hc-form-field-content-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit;flex-wrap:wrap;width:100%}.hc-form-field-flex{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:baseline;align-items:baseline;box-sizing:border-box;width:100%;border:1px solid #c0c5cc;background:#fff}.hc-form-field-flex:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-form-field-flex.hc-form-field-flex-focused{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-disabled .hc-form-field-flex{cursor:not-allowed;border:1px solid #e0e0e0;background-color:#f0f3f6;color:#adadad}.hc-form-field-flex-inline{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;box-sizing:border-box;border:1px solid #c0c5cc;background:#fff}.hc-form-field-flex-inline:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-form-field-flex-inline.hc-form-field-flex-focused{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-disabled .hc-form-field-flex-inline{cursor:not-allowed;border:1px solid #e0e0e0;background-color:#f0f3f6;color:#adadad}.hc-form-field-invalid.hc-form-field-flex,.hc-form-field-invalid.hc-form-field-flex-inline{border:1px solid #cc2027}.hc-form-field-invalid.hc-form-field-flex-inline.hc-form-field-flex-focused,.hc-form-field-invalid.hc-form-field-flex.hc-form-field-flex-focused{box-shadow:0 0 3px #cc2027}.hc-form-field-non-input{display:-webkit-inline-box;display:inline-flex;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit;width:100%}.hc-form-field-non-input-inline{display:-webkit-inline-box;display:inline-flex;-webkit-box-flex:0;flex:0 0 100%;min-height:35px;-webkit-box-align:center;align-items:center}.hc-form-field-non-input-inline-tight{min-height:auto}.hc-form-field-prefix,.hc-form-field-suffix{white-space:nowrap;-webkit-box-flex:0;flex:none;position:relative}.hc-form-field-prefix .hc-icon,.hc-form-field-suffix .hc-icon{color:#a1a1a1;font-size:125%;line-height:1.5}.hc-form-field-wrapper-tight .hc-form-field-prefix .hc-icon,.hc-form-field-wrapper-tight .hc-form-field-suffix .hc-icon{line-height:1.3}.hc-form-field-disabled .hc-form-field-prefix,.hc-form-field-disabled .hc-form-field-suffix{opacity:.5}.hc-form-field-suffix{padding-right:7px}.hc-form-field-prefix{padding-left:7px}.hc-form-field-infix{display:block;position:relative;-webkit-box-flex:1;flex:auto;padding:.393em 10px}.hc-form-field-infix-tight{padding:.1965em 7px;font-size:.92857rem}.hc-form-field-label-wrapper{box-sizing:content-box;width:100%}.hc-form-field-label-wrapper .hc-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.hc-form-field-label-wrapper.hc-form-field-label-wrapper-tight{font-size:.92857rem}.hc-form-field-label-wrapper-inline{-webkit-box-flex:1;flex:1 0 auto;padding:7px 15px 0 0}.hc-form-field-label-wrapper-inline .hc-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.hc-form-field-label-wrapper-inline.hc-form-field-label-wrapper-tight{padding-top:0;line-height:1.9}.hc-form-field-label{display:block;width:100%;margin-bottom:3px;font:inherit;font-size:1rem;color:#333}.hc-form-field-label-extension{color:#6d6e70;font-size:.85714rem;margin-bottom:10px}.hc-form-field-label-inline{width:100%;font:inherit;font-size:1rem;color:#333}.hc-form-field-label-tight{font-size:.92857rem}.hc-form-field-error-wrapper{box-sizing:border-box;width:100%;overflow:hidden;margin-top:.53333em;font-size:75%}.hc-error{display:block;color:#cc2027}.hc-required-marker{color:#cc2027}",
    ".hc-input{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;text-align:inherit}.hc-input[disabled]{cursor:not-allowed}.hc-input:-moz-ui-invalid{box-shadow:none}.hc-input::-ms-clear,.hc-input::-ms-reveal{display:none}.hc-input::-webkit-input-placeholder{color:#c0c5cc}.hc-input::-moz-placeholder{color:#c0c5cc}.hc-input::placeholder{color:#c0c5cc}.hc-input:-ms-input-placeholder{color:#c0c5cc}.hc-input::-ms-input-placeholder{color:#c0c5cc}textarea.hc-input{resize:vertical;overflow:auto;padding:2px 0;margin:-2px 0}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
HcFormFieldComponent.ctorParameters = () => [{ type: ElementRef }];
HcFormFieldComponent.propDecorators = {
  _control: [
    { type: ContentChild, args: [HcFormControlComponent, { static: false }] },
  ],
  _controls: [{ type: ContentChildren, args: [HcFormControlComponent] }],
  _errorChildren: [{ type: ContentChildren, args: [HcErrorComponent] }],
  _prefixChildren: [{ type: ContentChildren, args: [HcPrefixDirective] }],
  _suffixChildren: [{ type: ContentChildren, args: [HcSuffixDirective] }],
  _inputChildren: [{ type: ContentChildren, args: [InputDirective] }],
  _labelChildren: [{ type: ContentChildren, args: [HcLabelComponent] }],
  _classHcFormFieldClass: [
    { type: HostBinding, args: ["class.hc-form-field"] },
  ],
  _disabledClass: [
    { type: HostBinding, args: ["class.hc-form-field-disabled"] },
  ],
  inline: [{ type: Input }],
  tight: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcFormFieldComponent.prototype._inline;
  /**
   * @type {?}
   * @private
   */
  HcFormFieldComponent.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  HcFormFieldComponent.prototype.unsubscribe$;
  /** @type {?} */
  HcFormFieldComponent.prototype._control;
  /** @type {?} */
  HcFormFieldComponent.prototype._controls;
  /** @type {?} */
  HcFormFieldComponent.prototype._errorChildren;
  /** @type {?} */
  HcFormFieldComponent.prototype._prefixChildren;
  /** @type {?} */
  HcFormFieldComponent.prototype._suffixChildren;
  /** @type {?} */
  HcFormFieldComponent.prototype._inputChildren;
  /** @type {?} */
  HcFormFieldComponent.prototype._labelChildren;
  /** @type {?} */
  HcFormFieldComponent.prototype._classHcFormFieldClass;
  /** @type {?} */
  HcFormFieldComponent.prototype._hasFocusedInput;
  /**
   * @type {?}
   * @private
   */
  HcFormFieldComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker-input/datepicker-input.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:no-host-metadata-property
// tslint:disable:member-ordering
/**
 * \@docs-private
 * @type {?}
 */
const HC_DATEPICKER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(
    /**
     * @return {?}
     */
    () => DatepickerInputDirective
  ),
  multi: true,
};
/**
 * \@docs-private
 * @type {?}
 */
const HC_DATEPICKER_VALIDATORS = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(
    /**
     * @return {?}
     */
    () => DatepickerInputDirective
  ),
  multi: true,
};
/**
 * An event used for datepicker input and change events. We don't always have access to a native
 * input or change event because the event may have been triggered by the user clicking on the
 * calendar popup. For consistency, we always use hcDatepickerInputEvent instead.
 */
class HcDatepickerInputEvent {
  /**
   * @param {?} target
   * @param {?} targetElement
   */
  constructor(target, targetElement) {
    this.target = target;
    this.targetElement = targetElement;
    this.value = this.target.value;
  }
}
if (false) {
  /**
   * The new value for the target datepicker input.
   * @type {?}
   */
  HcDatepickerInputEvent.prototype.value;
  /**
   * Reference to the datepicker input component that emitted the event.
   * @type {?}
   */
  HcDatepickerInputEvent.prototype.target;
  /**
   * Reference to the native input element associated with the datepicker input.
   * @type {?}
   */
  HcDatepickerInputEvent.prototype.targetElement;
}
class DatepickerInputDirective {
  /**
   * @param {?} _elementRef
   * @param {?} _dateAdapter
   * @param {?} _dateFormats
   * @param {?} _formField
   */
  constructor(_elementRef, _dateAdapter, _dateFormats, _formField) {
    this._elementRef = _elementRef;
    this._dateAdapter = _dateAdapter;
    this._dateFormats = _dateFormats;
    this._formField = _formField;
    /**
     * Emits when a `change` event is fired on this `<input>`.
     */
    this.dateChange = new EventEmitter();
    /**
     * Emits when an `input` event is fired on this `<input>`.
     */
    this.dateInput = new EventEmitter();
    /**
     * Emits when the value changes (either due to user input or programmatic change).
     */
    this._valueChange = new EventEmitter();
    /**
     * Emits when the disabled state has changed
     */
    this._disabledChange = new EventEmitter();
    this._onTouched =
      /**
       * @return {?}
       */
      () => {};
    this._cvaOnChange =
      /**
       * @return {?}
       */
      () => {};
    this._validatorOnChange =
      /**
       * @return {?}
       */
      () => {};
    this._datepickerSubscription = Subscription.EMPTY;
    this._localeSubscription = Subscription.EMPTY;
    /**
     * The form control validator for whether the input parses.
     */
    this._parseValidator =
      /**
       * @return {?}
       */
      () => {
        return this._lastValueValid
          ? null
          : {
              hcDatepickerParse: { text: this._elementRef.nativeElement.value },
            };
      };
    /**
     * The form control validator for the min date.
     */
    this._minValidator =
      /**
       * @param {?} control
       * @return {?}
       */
      (control) => {
        /** @type {?} */
        const controlValue = this._getValidDateOrNull(
          this._dateAdapter.deserialize(control.value)
        );
        return !this.min ||
          !controlValue ||
          this._dateAdapter.compareDate(this.min, controlValue) <= 0
          ? null
          : { hcDatepickerMin: { min: this.min, actual: controlValue } };
      };
    /**
     * The form control validator for the max date.
     */
    this._maxValidator =
      /**
       * @param {?} control
       * @return {?}
       */
      (control) => {
        /** @type {?} */
        const controlValue = this._getValidDateOrNull(
          this._dateAdapter.deserialize(control.value)
        );
        return !this.max ||
          !controlValue ||
          this._dateAdapter.compareDate(this.max, controlValue) >= 0
          ? null
          : { hcDatepickerMax: { max: this.max, actual: controlValue } };
      };
    /**
     * The form control validator for the date filter.
     */
    this._filterValidator =
      /**
       * @param {?} control
       * @return {?}
       */
      (control) => {
        /** @type {?} */
        const controlValue = this._getValidDateOrNull(
          this._dateAdapter.deserialize(control.value)
        );
        return !this._dateFilter ||
          !controlValue ||
          this._dateFilter(controlValue)
          ? null
          : { hcDatepickerFilter: true };
      };
    /**
     * The combined form control validator for this input.
     */
    this._validator = Validators.compose([
      this._parseValidator,
      this._minValidator,
      this._maxValidator,
      this._filterValidator,
    ]);
    /**
     * Whether the last value set on the input was valid.
     */
    this._lastValueValid = false;
    if (!this._dateAdapter) {
      throw createMissingDateImplError("DateAdapter");
    }
    if (!this._dateFormats) {
      throw createMissingDateImplError("HC_DATE_FORMATS");
    }
    // Update the displayed date when the locale changes.
    this._localeSubscription = _dateAdapter.localeChanges.subscribe(
      /**
       * @return {?}
       */
      () => {
        this.value = this.value;
      }
    );
  }
  /**
   * The datepicker that this input is associated with.
   * @param {?} value
   * @return {?}
   */
  set hcDatepicker(value) {
    if (!value) {
      return;
    }
    this._datepicker = value;
    this._datepicker._registerInput(this);
    this._datepickerSubscription.unsubscribe();
    this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(
      /**
       * @param {?} selected
       * @return {?}
       */
      (selected) => {
        this.setDate(selected);
      }
    );
  }
  /**
   * Function that can be used to filter out dates within the datepicker.
   * @param {?} value
   * @return {?}
   */
  set hcDatepickerFilter(value) {
    this._dateFilter = value;
    this._validatorOnChange();
  }
  /**
   * The value of the input.
   * @return {?}
   */
  get value() {
    return this._value;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set value(value) {
    value = this._dateAdapter.deserialize(value);
    this._lastValueValid = !value || this._dateAdapter.isValid(value);
    value = this._getValidDateOrNull(value);
    /** @type {?} */
    const oldDate = this.value;
    this._value = value;
    this._formatValue(value);
    if (!this._dateAdapter.sameDate(oldDate, value)) {
      this._valueChange.emit(value);
    }
  }
  /**
   * The minimum valid date.
   * @return {?}
   */
  get min() {
    return this._min;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set min(value) {
    this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    this._validatorOnChange();
  }
  /**
   * The maximum valid date.
   * @return {?}
   */
  get max() {
    return this._max;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set max(value) {
    this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
    this._validatorOnChange();
  }
  /**
   * Whether the datepicker-input is disabled.
   * @return {?}
   */
  get disabled() {
    return !!this._disabled;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set disabled(value) {
    /** @type {?} */
    const newValue = coerceBooleanProperty(value);
    /** @type {?} */
    const element = this._elementRef.nativeElement;
    if (this._disabled !== newValue) {
      this._disabled = newValue;
      this._disabledChange.emit(newValue);
    }
    // We need to null check the `blur` method, because it's undefined during SSR.
    if (newValue && element.blur) {
      // Normally, native input elements automatically blur if they turn disabled. This behavior
      // is problematic, because it would mean that it triggers another change detection cycle,
      // which then causes a changed after checked error if the input element was focused before.
      element.blur();
    }
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this._datepickerSubscription.unsubscribe();
    this._localeSubscription.unsubscribe();
    this._valueChange.complete();
    this._disabledChange.complete();
  }
  /**
   * \@docs-private
   * @param {?} fn
   * @return {?}
   */
  registerOnValidatorChange(fn) {
    this._validatorOnChange = fn;
  }
  /**
   * \@docs-private
   * @param {?} c
   * @return {?}
   */
  validate(c) {
    return this._validator ? this._validator(c) : null;
  }
  /**
   * Gets the element that the datepicker popup should be connected to.
   * @return {?} The element to connect the popup to.
   */
  getConnectedOverlayOrigin() {
    return this._formField
      ? this._formField.getConnectedOverlayOrigin()
      : this._elementRef;
  }
  /**
   * Sets the focus on the input element
   * @return {?}
   */
  focus() {
    this._elementRef.nativeElement.focus();
  }
  // Implemented as part of ControlValueAccessor.
  /**
   * @param {?} value
   * @return {?}
   */
  writeValue(value) {
    this.value = value;
  }
  // Implemented as part of ControlValueAccessor.
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnChange(fn) {
    this._cvaOnChange = fn;
  }
  // Implemented as part of ControlValueAccessor.
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  /**
   * @param {?} isDisabled
   * @return {?}
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Set the date programmatically
  /**
   * @param {?} selected
   * @return {?}
   */
  setDate(selected) {
    this.value = selected;
    this._cvaOnChange(selected);
    this._onTouched();
    this.dateInput.emit(
      new HcDatepickerInputEvent(this, this._elementRef.nativeElement)
    );
    this.dateChange.emit(
      new HcDatepickerInputEvent(this, this._elementRef.nativeElement)
    );
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onKeydown(event) {
    /** @type {?} */
    const isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;
    if (
      this._datepicker &&
      isAltDownArrow &&
      !this._elementRef.nativeElement.readOnly
    ) {
      this._datepicker.open();
      event.preventDefault();
    }
  }
  /**
   * @param {?} value
   * @return {?}
   */
  _onInput(value) {
    /** @type {?} */
    let date = this._dateAdapter.parse(
      value,
      this._dateFormats.parse.dateInput
    );
    /** Two-digit year input conversion method for IE
     * Based on the current year, assume that the four-digit year date should be in
     * either the next 30 years, or the preceding 70 years */
    if (date) {
      /** @type {?} */
      let inputString = this._elementRef.nativeElement.value;
      /** Skip this check if the input string contains any 3+ digit numerical values - assumed to be a year */
      if (!inputString.match(/[1-9][0-9][0-9]/g)) {
        /** @type {?} */
        let currentDate = new Date();
        if (date.getFullYear() >= currentDate.getFullYear() + 30) {
          date.setFullYear(date.getFullYear() - 100);
        } else if (date.getFullYear() < currentDate.getFullYear() - 70) {
          date.setFullYear(date.getFullYear() + 100);
        }
      }
    }
    this._lastValueValid = !date || this._dateAdapter.isValid(date);
    date = this._getValidDateOrNull(date);
    if (!this._dateAdapter.sameDate(date, this._value)) {
      this._value = date;
      this._cvaOnChange(date);
      this._valueChange.emit(date);
      this.dateInput.emit(
        new HcDatepickerInputEvent(this, this._elementRef.nativeElement)
      );
    }
  }
  /**
   * @return {?}
   */
  _onChange() {
    this.dateChange.emit(
      new HcDatepickerInputEvent(this, this._elementRef.nativeElement)
    );
  }
  /**
   * Handles blur events on the input.
   * @return {?}
   */
  _onBlur() {
    // Reformat the input only if we have a valid value.
    if (this.value || this._elementRef.nativeElement.value) {
      this._formatValue(this.value);
    }
    this._onTouched();
  }
  /**
   * Formats a value and sets it on the input element.
   * @private
   * @param {?} value
   * @return {?}
   */
  _formatValue(value) {
    /** @type {?} */
    let dateFormat = this._dateFormats.display.dateInput;
    /** @type {?} */
    let tempMode = "date";
    /** @type {?} */
    let tempCycle = 12;
    if (this._datepicker) {
      tempMode = this._datepicker.mode;
      tempCycle = +this._datepicker.hourCycle;
    } else if (this._mode) {
      tempMode = this._mode;
      if (this._hourCycle) {
        tempCycle = this._hourCycle;
      }
    }
    if (tempMode === "time") {
      /** @type {?} */
      let tempFormat = this._dateFormats.display.timeInput;
      tempFormat["hour12"] = tempCycle === 12;
      dateFormat = tempFormat;
    } else if (tempMode === "date-time") {
      /** @type {?} */
      let tempFormat = this._dateFormats.display.dateTimeInput;
      tempFormat["hour12"] = tempCycle === 12;
      dateFormat = tempFormat;
    }
    this._elementRef.nativeElement.value = value
      ? this._dateAdapter.format(value, dateFormat)
      : "";
  }
  /**
   * @private
   * @param {?} obj The object to check.
   * @return {?} The given object if it is both a date instance and valid, otherwise null.
   */
  _getValidDateOrNull(obj) {
    return this._dateAdapter.isDateInstance(obj) &&
      this._dateAdapter.isValid(obj)
      ? obj
      : null;
  }
}
DatepickerInputDirective.ɵfac = function DatepickerInputDirective_Factory(t) {
  return new (t || DatepickerInputDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(DateAdapter, 8),
    ɵngcc0.ɵɵdirectiveInject(HC_DATE_FORMATS, 8),
    ɵngcc0.ɵɵdirectiveInject(HcFormFieldComponent, 8)
  );
};
DatepickerInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: DatepickerInputDirective,
  selectors: [["input", "hcDatepicker", ""]],
  hostVars: 5,
  hostBindings: function DatepickerInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "input",
        function DatepickerInputDirective_input_HostBindingHandler($event) {
          return ctx._onInput($event.target.value);
        }
      )(
        "change",
        function DatepickerInputDirective_change_HostBindingHandler() {
          return ctx._onChange();
        }
      )("blur", function DatepickerInputDirective_blur_HostBindingHandler() {
        return ctx._onBlur();
      })(
        "keydown",
        function DatepickerInputDirective_keydown_HostBindingHandler($event) {
          return ctx._onKeydown($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled);
      ɵngcc0.ɵɵattribute("aria-haspopup", true)(
        "aria-owns",
        ((ctx._datepicker == null ? null : ctx._datepicker.opened) &&
          ctx._datepicker.id) ||
          null
      )("min", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(
        "max",
        ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null
      );
    }
  },
  inputs: {
    value: "value",
    hcDatepicker: "hcDatepicker",
    hcDatepickerFilter: "hcDatepickerFilter",
    min: "min",
    max: "max",
    disabled: "disabled",
    _mode: "_mode",
    _hourCycle: "_hourCycle",
  },
  outputs: { dateChange: "dateChange", dateInput: "dateInput" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      HC_DATEPICKER_VALUE_ACCESSOR,
      HC_DATEPICKER_VALIDATORS,
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => DatepickerInputDirective
        ),
      },
    ]),
  ],
});
/** @nocollapse */
DatepickerInputDirective.ctorParameters = () => [
  { type: ElementRef },
  { type: DateAdapter, decorators: [{ type: Optional }] },
  {
    type: undefined,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_FORMATS] }],
  },
  { type: HcFormFieldComponent, decorators: [{ type: Optional }] },
];
DatepickerInputDirective.propDecorators = {
  hcDatepicker: [{ type: Input }],
  hcDatepickerFilter: [{ type: Input }],
  value: [{ type: Input }],
  min: [{ type: Input }],
  max: [{ type: Input }],
  disabled: [{ type: Input }],
  dateChange: [{ type: Output }],
  dateInput: [{ type: Output }],
  _mode: [{ type: Input }],
  _hourCycle: [{ type: Input }],
};
if (false) {
  /** @type {?} */
  DatepickerInputDirective.prototype._datepicker;
  /** @type {?} */
  DatepickerInputDirective.prototype._dateFilter;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._value;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._min;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._max;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._disabled;
  /**
   * Emits when a `change` event is fired on this `<input>`.
   * @type {?}
   */
  DatepickerInputDirective.prototype.dateChange;
  /**
   * Emits when an `input` event is fired on this `<input>`.
   * @type {?}
   */
  DatepickerInputDirective.prototype.dateInput;
  /**
   * Stores the mode & hourCycle for the inputs of the date range (which don't have a DatePickerComponent)
   * @type {?}
   */
  DatepickerInputDirective.prototype._mode;
  /** @type {?} */
  DatepickerInputDirective.prototype._hourCycle;
  /**
   * Emits when the value changes (either due to user input or programmatic change).
   * @type {?}
   */
  DatepickerInputDirective.prototype._valueChange;
  /**
   * Emits when the disabled state has changed
   * @type {?}
   */
  DatepickerInputDirective.prototype._disabledChange;
  /** @type {?} */
  DatepickerInputDirective.prototype._onTouched;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._cvaOnChange;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._validatorOnChange;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._datepickerSubscription;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._localeSubscription;
  /**
   * The form control validator for whether the input parses.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._parseValidator;
  /**
   * The form control validator for the min date.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._minValidator;
  /**
   * The form control validator for the max date.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._maxValidator;
  /**
   * The form control validator for the date filter.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._filterValidator;
  /**
   * The combined form control validator for this input.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._validator;
  /**
   * Whether the last value set on the input was valid.
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._lastValueValid;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._elementRef;
  /** @type {?} */
  DatepickerInputDirective.prototype._dateAdapter;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._dateFormats;
  /**
   * @type {?}
   * @private
   */
  DatepickerInputDirective.prototype._formField;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker-toggle/datepicker-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Can be used to override the icon of a `hcDatepickerToggle`.
 */
class DatepickerToggleIconDirective {}
DatepickerToggleIconDirective.ɵfac = function DatepickerToggleIconDirective_Factory(
  t
) {
  return new (t || DatepickerToggleIconDirective)();
};
DatepickerToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: DatepickerToggleIconDirective,
  selectors: [["", "hcDatepickerToggleIcon", ""]],
});
class DatepickerToggleComponent {
  /**
   * @param {?} _intl
   * @param {?} _changeDetectorRef
   * @param {?} defaultTabIndex
   */
  constructor(_intl, _changeDetectorRef, defaultTabIndex) {
    this._intl = _intl;
    this._changeDetectorRef = _changeDetectorRef;
    this._stateChanges = Subscription.EMPTY;
    /** @type {?} */
    const parsedTabIndex = Number(defaultTabIndex);
    this.tabIndex =
      parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;
  }
  /**
   * Whether the toggle button is disabled.
   * @return {?}
   */
  get disabled() {
    return this._disabled === undefined
      ? this.datepicker.disabled
      : !!this._disabled;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    if (changes.datepicker) {
      this._watchStateChanges();
    }
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this._stateChanges.unsubscribe();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._watchStateChanges();
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _open(event) {
    if (this.datepicker && !this.disabled) {
      this.datepicker.open();
      event.stopPropagation();
    }
  }
  /**
   * @private
   * @return {?}
   */
  _watchStateChanges() {
    /** @type {?} */
    const datepickerDisabled = this.datepicker
      ? this.datepicker._disabledChange
      : of();
    /** @type {?} */
    const inputDisabled =
      this.datepicker && this.datepicker._datepickerInput
        ? this.datepicker._datepickerInput._disabledChange
        : of();
    /** @type {?} */
    const datepickerToggled = this.datepicker
      ? merge(this.datepicker.openedStream, this.datepicker.closedStream)
      : of();
    this._stateChanges.unsubscribe();
    this._stateChanges = merge(
      this._intl.changes,
      datepickerDisabled,
      inputDisabled,
      datepickerToggled
    ).subscribe(
      /**
       * @return {?}
       */
      () => this._changeDetectorRef.markForCheck()
    );
  }
}
DatepickerToggleComponent.ɵfac = function DatepickerToggleComponent_Factory(t) {
  return new (t || DatepickerToggleComponent)(
    ɵngcc0.ɵɵdirectiveInject(HcDatepickerIntl),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵinjectAttribute("tabindex")
  );
};
DatepickerToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: DatepickerToggleComponent,
  selectors: [["hc-datepicker-toggle"]],
  contentQueries: function DatepickerToggleComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, DatepickerToggleIconDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._customIcon = _t.first);
    }
  },
  viewQuery: function DatepickerToggleComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c27, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._button = _t.first);
    }
  },
  hostAttrs: [1, "hc-datepicker-toggle"],
  hostVars: 3,
  hostBindings: function DatepickerToggleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "focus",
        function DatepickerToggleComponent_focus_HostBindingHandler() {
          return ctx._button.focus();
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("tabindex", -1);
      ɵngcc0.ɵɵclassProp(
        "hc-datepicker-toggle-active",
        ctx.datepicker && ctx.datepicker.opened
      );
    }
  },
  inputs: {
    tabIndex: "tabIndex",
    disabled: "disabled",
    datepicker: ["for", "datepicker"],
  },
  exportAs: ["hcDatepickerToggle"],
  features: [ɵngcc0.ɵɵNgOnChangesFeature],
  ngContentSelectors: _c29,
  decls: 4,
  vars: 4,
  consts: [
    [
      "hc-icon-button",
      "",
      "type",
      "button",
      "aria-haspopup",
      "true",
      1,
      "hc-calendar-toggle",
      3,
      "disabled",
      "click",
    ],
    ["button", ""],
    ["hcSuffix", "", "fontSet", "fa", 3, "fontIcon", 4, "ngIf"],
    ["hcSuffix", "", "fontSet", "fa", 3, "fontIcon"],
  ],
  template: function DatepickerToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c28);
      ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
      ɵngcc0.ɵɵlistener(
        "click",
        function DatepickerToggleComponent_Template_button_click_0_listener(
          $event
        ) {
          return ctx._open($event);
        }
      );
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵtemplate(
        3,
        DatepickerToggleComponent_hc_icon_3_Template,
        1,
        1,
        "hc-icon",
        2
      );
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
      ɵngcc0.ɵɵattribute("aria-label", ctx._intl.openCalendarLabel)(
        "tabindex",
        ctx.disabled ? -1 : ctx.tabIndex
      );
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngIf", !ctx._customIcon);
    }
  },
  directives: [ButtonComponent, ɵngcc1.NgIf, IconComponent, HcSuffixDirective],
  styles: [
    "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-toggle{background:0 0;border:none;box-sizing:border-box;color:#00aeff;cursor:pointer;display:inline-block;height:32px;line-height:1.5;margin:0;outline:0;overflow:visible;padding:0;position:relative;text-align:center;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:baseline;-webkit-tap-highlight-color:transparent;white-space:nowrap;width:32px}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
DatepickerToggleComponent.ctorParameters = () => [
  { type: HcDatepickerIntl },
  { type: ChangeDetectorRef },
  { type: String, decorators: [{ type: Attribute, args: ["tabindex"] }] },
];
DatepickerToggleComponent.propDecorators = {
  datepicker: [{ type: Input, args: ["for"] }],
  tabIndex: [{ type: Input }],
  disabled: [{ type: Input }],
  _customIcon: [
    {
      type: ContentChild,
      args: [DatepickerToggleIconDirective, { static: false }],
    },
  ],
  _button: [{ type: ViewChild, args: ["button", { static: false }] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  DatepickerToggleComponent.prototype._stateChanges;
  /**
   * Datepicker instance that the button will toggle.
   * @type {?}
   */
  DatepickerToggleComponent.prototype.datepicker;
  /**
   * Tabindex for the toggle.
   * @type {?}
   */
  DatepickerToggleComponent.prototype.tabIndex;
  /**
   * @type {?}
   * @private
   */
  DatepickerToggleComponent.prototype._disabled;
  /**
   * Custom icon set by the consumer.
   * @type {?}
   */
  DatepickerToggleComponent.prototype._customIcon;
  /**
   * Underlying button element.
   * @type {?}
   */
  DatepickerToggleComponent.prototype._button;
  /** @type {?} */
  DatepickerToggleComponent.prototype._intl;
  /**
   * @type {?}
   * @private
   */
  DatepickerToggleComponent.prototype._changeDetectorRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/native-date-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO(mmalerba): Remove when we no longer support safari 9.
/**
 * Whether the browser supports the Intl API.
 * @type {?}
 */
const SUPPORTS_INTL_API = typeof Intl !== "undefined";
/**
 * The default month names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_MONTH_NAMES = {
  long: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
  short: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
};
const ɵ0 =
  /**
   * @param {?} i
   * @return {?}
   */
  (i) => String(i + 1);
/**
 * The default date names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_DATE_NAMES = range(31, ɵ0);
/**
 * The default day of the week names to use if Intl API is not available.
 * @type {?}
 */
const DEFAULT_DAY_OF_WEEK_NAMES = {
  long: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ],
  short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
};
/**
 * First day of week according locale.
 * Taken form moment.js source code https://github.com/moment/moment/tree/develop/src/locale
 * @type {?}
 */
const FIRST_DAY_OF_WEEK = {
  af: 1,
  ar: 6,
  "ar-ly": 6,
  "ar-ma": 6,
  "ar-tn": 1,
  az: 1,
  be: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  ca: 1,
  cs: 1,
  cv: 1,
  cy: 1,
  da: 1,
  de: 1,
  "de-at": 1,
  "de-ch": 1,
  el: 1,
  "en-au": 1,
  "en-gb": 1,
  "en-ie": 1,
  "en-nz": 1,
  eo: 1,
  es: 1,
  "es-do": 1,
  et: 1,
  eu: 1,
  fa: 6,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-ch": 1,
  fy: 1,
  gd: 1,
  gl: 1,
  "gom-latn": 1,
  hr: 1,
  hu: 1,
  "hy-am": 1,
  id: 1,
  is: 1,
  it: 1,
  jv: 1,
  ka: 1,
  kk: 1,
  km: 1,
  ky: 1,
  lb: 1,
  lt: 1,
  lv: 1,
  me: 1,
  mi: 1,
  mk: 1,
  ms: 1,
  "ms-my": 1,
  mt: 1,
  my: 1,
  nb: 1,
  nl: 1,
  "nl-be": 1,
  nn: 1,
  pl: 1,
  pt: 1,
  "pt-BR": 0,
  ro: 1,
  ru: 1,
  sd: 1,
  se: 1,
  sk: 1,
  sl: 1,
  sq: 1,
  sr: 1,
  "sr-cyrl": 1,
  ss: 1,
  sv: 1,
  sw: 1,
  tet: 1,
  tg: 1,
  "tl-ph": 1,
  tlh: 1,
  tr: 1,
  tzl: 1,
  tzm: 6,
  "tzm-latn": 6,
  "ug-cn": 1,
  uk: 1,
  ur: 1,
  uz: 1,
  "uz-latn": 1,
  vi: 1,
  "x-pseudo": 1,
  yo: 1,
  "zh-cn": 1,
};
/**
 * Matches strings that have the form of a valid RFC 3339 string
 * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date
 * because the regex will match strings an with out of bounds month, date, etc.
 * @type {?}
 */
const ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
/**
 * Creates an array and fills it with values.
 * @template T
 * @param {?} length
 * @param {?} valueFunction
 * @return {?}
 */
function range(length, valueFunction) {
  /** @type {?} */
  const valuesArray = Array(length);
  for (let i = 0; i < length; i++) {
    valuesArray[i] = valueFunction(i);
  }
  return valuesArray;
}
/**
 * Adapts the native JS Date for use with cdk-based components that work with dates.
 */
class NativeDateAdapter extends DateAdapter {
  /**
   * @param {?} hcDateLocale
   * @param {?} platform
   */
  constructor(hcDateLocale, platform) {
    super();
    /**
     * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
     * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
     * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
     * will produce `'8/13/1800'`.
     *
     * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
     * getting the string representation of a Date object from it's utc representation. We're keeping
     * it here for sometime, just for precaution, in case we decide to revert some of these changes
     * though.
     */
    this.useUtcForDisplay = true;
    super.setLocale(hcDateLocale);
    // IE does its own time zone correction, so we disable this on IE.
    this.useUtcForDisplay = !platform.TRIDENT;
    this._clampDate = platform.TRIDENT || platform.EDGE;
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getYear(date) {
    return date.getFullYear();
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getMonth(date) {
    return date.getMonth();
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getDate(date) {
    return date.getDate();
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getHours(date) {
    return date.getHours();
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getMinutes(date) {
    return date.getMinutes();
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getDayOfWeek(date) {
    return date.getDay();
  }
  /**
   * @param {?} style
   * @return {?}
   */
  getMonthNames(style) {
    if (SUPPORTS_INTL_API) {
      /** @type {?} */
      const dtf = new Intl.DateTimeFormat(this.locale, {
        month: style,
        timeZone: "utc",
      });
      return range(
        12,
        /**
         * @param {?} i
         * @return {?}
         */ (i) =>
          this._stripDirectionalityCharacters(
            this._format(dtf, new Date(2017, i, 1))
          )
      );
    }
    return DEFAULT_MONTH_NAMES[style];
  }
  /**
   * @return {?}
   */
  getDateNames() {
    if (SUPPORTS_INTL_API) {
      /** @type {?} */
      const dtf = new Intl.DateTimeFormat(this.locale, {
        day: "numeric",
        timeZone: "utc",
      });
      return range(
        31,
        /**
         * @param {?} i
         * @return {?}
         */ (i) =>
          this._stripDirectionalityCharacters(
            this._format(dtf, new Date(2017, 0, i + 1))
          )
      );
    }
    return DEFAULT_DATE_NAMES;
  }
  /**
   * @param {?} style
   * @return {?}
   */
  getDayOfWeekNames(style) {
    if (SUPPORTS_INTL_API) {
      /** @type {?} */
      const dtf = new Intl.DateTimeFormat(this.locale, {
        weekday: style,
        timeZone: "utc",
      });
      return range(
        7,
        /**
         * @param {?} i
         * @return {?}
         */ (i) =>
          this._stripDirectionalityCharacters(
            this._format(dtf, new Date(2017, 0, i + 1))
          )
      );
    }
    return DEFAULT_DAY_OF_WEEK_NAMES[style];
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getYearName(date) {
    if (SUPPORTS_INTL_API) {
      /** @type {?} */
      const dtf = new Intl.DateTimeFormat(this.locale, {
        year: "numeric",
        timeZone: "utc",
      });
      return this._stripDirectionalityCharacters(this._format(dtf, date));
    }
    return String(this.getYear(date));
  }
  /**
   * @return {?}
   */
  getFirstDayOfWeek() {
    // We can't tell using native JS Date what the first day of the week is.
    // Sometimes people use excess language definition, e.g. ru-RU,
    // so we use fallback to two-letter language code
    /** @type {?} */
    const locale = this.locale.toLowerCase();
    return (
      FIRST_DAY_OF_WEEK[locale] || FIRST_DAY_OF_WEEK[locale.substr(0, 2)] || 0
    );
  }
  /**
   * @param {?} date
   * @return {?}
   */
  getNumDaysInMonth(date) {
    return this.getDate(
      this._createDateWithOverflow(
        this.getYear(date),
        this.getMonth(date) + 1,
        0
      )
    );
  }
  /**
   * @param {?} date
   * @return {?}
   */
  clone(date) {
    return this.createDate(
      this.getYear(date),
      this.getMonth(date),
      this.getDate(date)
    );
  }
  /**
   * @param {?} year
   * @param {?} month
   * @param {?} date
   * @return {?}
   */
  createDate(year, month, date) {
    // Check for invalid month and date (except upper bound on date which we have to check after
    // creating the Date).
    if (month < 0 || month > 11) {
      throw Error(
        `Invalid month index "${month}". Month index has to be between 0 and 11.`
      );
    }
    if (date < 1) {
      throw Error(`Invalid date "${date}". Date has to be greater than 0.`);
    }
    /** @type {?} */
    const result = this._createDateWithOverflow(year, month, date);
    // Check that the date wasn't above the upper bound for the month, causing the month to overflow
    if (result.getMonth() !== month) {
      throw Error(`Invalid date "${date}" for month with index "${month}".`);
    }
    return result;
  }
  /**
   * @return {?}
   */
  today() {
    return new Date();
  }
  /**
   * @param {?} value
   * @return {?}
   */
  parse(value) {
    // We have no way using the native JS Date to set the parse format or locale, so we ignore these
    // parameters.
    if (typeof value === "number") {
      return new Date(value);
    }
    return value ? new Date(Date.parse(value)) : null;
  }
  /**
   * @param {?} date
   * @param {?} displayFormat
   * @return {?}
   */
  format(date, displayFormat) {
    if (!this.isValid(date)) {
      throw Error("NativeDateAdapter: Cannot format invalid date.");
    }
    if (SUPPORTS_INTL_API) {
      // On IE and Edge the i18n API will throw a hard error that can crash the entire app
      // if we attempt to format a date whose year is less than 1 or greater than 9999.
      if (
        this._clampDate &&
        (date.getFullYear() < 1 || date.getFullYear() > 9999)
      ) {
        date = this.clone(date);
        date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));
      }
      displayFormat = Object.assign({}, displayFormat, { timeZone: "utc" });
      /** @type {?} */
      const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
      return this._stripDirectionalityCharacters(this._format(dtf, date));
    }
    return this._stripDirectionalityCharacters(date.toDateString());
  }
  /**
   * @param {?} date
   * @param {?} years
   * @return {?}
   */
  addCalendarYears(date, years) {
    return this.addCalendarMonths(date, years * 12);
  }
  /**
   * @param {?} date
   * @param {?} months
   * @return {?}
   */
  addCalendarMonths(date, months) {
    /** @type {?} */
    let newDate = this._createDateWithOverflow(
      this.getYear(date),
      this.getMonth(date) + months,
      this.getDate(date)
    );
    // It's possible to wind up in the wrong month if the original month has more days than the new
    // month. In this case we want to go to the last day of the desired month.
    // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
    // guarantee this.
    if (
      this.getMonth(newDate) !==
      (((this.getMonth(date) + months) % 12) + 12) % 12
    ) {
      newDate = this._createDateWithOverflow(
        this.getYear(newDate),
        this.getMonth(newDate),
        0
      );
    }
    return newDate;
  }
  /**
   * @param {?} date
   * @param {?} days
   * @return {?}
   */
  addCalendarDays(date, days) {
    return this._createDateWithOverflow(
      this.getYear(date),
      this.getMonth(date),
      this.getDate(date) + days
    );
  }
  /**
   * @param {?} date
   * @return {?}
   */
  toIso8601(date) {
    return [
      date.getUTCFullYear(),
      this._2digit(date.getUTCMonth() + 1),
      this._2digit(date.getUTCDate()),
    ].join("-");
  }
  /**
   * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
   * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
   * invalid date for all other values.
   * @param {?} value
   * @return {?}
   */
  deserialize(value) {
    if (typeof value === "string") {
      if (!value) {
        return null;
      }
      // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the
      // string is the right format first.
      if (ISO_8601_REGEX.test(value)) {
        /** @type {?} */
        const date = new Date(value);
        if (this.isValid(date)) {
          return date;
        }
      }
    }
    return super.deserialize(value);
  }
  /**
   * @param {?} obj
   * @return {?}
   */
  isDateInstance(obj) {
    return obj instanceof Date;
  }
  /**
   * @param {?} date
   * @return {?}
   */
  isValid(date) {
    return !isNaN(date.getTime());
  }
  /**
   * @return {?}
   */
  invalid() {
    return new Date(NaN);
  }
  /**
   * Creates a date but allows the month and date to overflow.
   * @private
   * @param {?} year
   * @param {?} month
   * @param {?} date
   * @return {?}
   */
  _createDateWithOverflow(year, month, date) {
    /** @type {?} */
    const result = new Date(year, month, date);
    // We need to correct for the fact that JS native Date treats years in range [0, 99] as
    // abbreviations for 19xx.
    if (year >= 0 && year < 100) {
      result.setFullYear(this.getYear(result) - 1900);
    }
    return result;
  }
  /**
   * Pads a number to make it two digits.
   * @private
   * @param {?} n The number to pad.
   * @return {?} The padded number.
   */
  _2digit(n) {
    return ("00" + n).slice(-2);
  }
  /**
   * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
   * other browsers do not. We remove them to make output consistent and because they interfere with
   * date parsing.
   * @private
   * @param {?} str The string to strip direction characters from.
   * @return {?} The stripped string.
   */
  _stripDirectionalityCharacters(str) {
    return str.replace(/[\u200e\u200f]/g, "");
  }
  /**
   * When converting Date object to string, javascript built-in functions may return wrong
   * results because it applies its internal DST rules. The DST rules around the world change
   * very frequently, and the current valid rule is not always valid in previous years though.
   * We work around this problem building a new Date object which has its internal UTC
   * representation with the local date and time.
   * @private
   * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
   *    timeZone set to 'utc' to work fine.
   * @param {?} date Date from which we want to get the string representation according to dtf
   * @return {?} A Date object with its UTC representation based on the passed in date info
   */
  _format(dtf, date) {
    /** @type {?} */
    const d = new Date(
      Date.UTC(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
        date.getMilliseconds()
      )
    );
    return dtf.format(d);
  }
}
NativeDateAdapter.ɵfac = function NativeDateAdapter_Factory(t) {
  return new (t || NativeDateAdapter)(
    ɵngcc0.ɵɵinject(HC_DATE_LOCALE, 8),
    ɵngcc0.ɵɵinject(ɵngcc9.Platform)
  );
};
NativeDateAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: NativeDateAdapter,
  factory: NativeDateAdapter.ɵfac,
});
/** @nocollapse */
NativeDateAdapter.ctorParameters = () => [
  {
    type: String,
    decorators: [{ type: Optional }, { type: Inject, args: [HC_DATE_LOCALE] }],
  },
  { type: Platform },
];
if (false) {
  /**
   * Whether to clamp the date between 1 and 9999 to avoid IE and Edge errors.
   * @type {?}
   * @private
   */
  NativeDateAdapter.prototype._clampDate;
  /**
   * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
   * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
   * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
   * will produce `'8/13/1800'`.
   *
   * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
   * getting the string representation of a Date object from it's utc representation. We're keeping
   * it here for sometime, just for precaution, in case we decide to revert some of these changes
   * though.
   * @type {?}
   */
  NativeDateAdapter.prototype.useUtcForDisplay;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/native-date-formats.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Health Catalyst All Rights Reserved.
 *
 * Use of this source code is governed by an Apache-2.0 license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/HealthCatalyst/Fabric.Cashmere/dev/LICENSE
 */
/** @type {?} */
const HC_NATIVE_DATE_FORMATS = {
  parse: {
    dateInput: null,
  },
  display: {
    dateInput: { year: "numeric", month: "numeric", day: "numeric" },
    timeInput: { hour: "numeric", minute: "2-digit", hour12: true },
    dateTimeInput: {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    },
    monthYearLabel: { year: "numeric", month: "short" },
    dateA11yLabel: { year: "numeric", month: "long", day: "numeric" },
    monthYearA11yLabel: { year: "numeric", month: "long" },
  },
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datetime/datetime.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NativeDateModule {}
NativeDateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NativeDateModule });
NativeDateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function NativeDateModule_Factory(t) {
    return new (t || NativeDateModule)();
  },
  providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],
  imports: [[PlatformModule]],
});
const ɵ0$1 = HC_NATIVE_DATE_FORMATS;
class HcNativeDateModule {}
HcNativeDateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HcNativeDateModule });
HcNativeDateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function HcNativeDateModule_Factory(t) {
    return new (t || HcNativeDateModule)();
  },
  providers: [{ provide: HC_DATE_FORMATS, useValue: ɵ0$1 }],
  imports: [[NativeDateModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-label-ext.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container for additional label content for HcFormFieldComponent
 */
class HcLabelExtensionComponent {
  constructor() {
    this._hostHcLabelClass = true;
  }
}
HcLabelExtensionComponent.ɵfac = function HcLabelExtensionComponent_Factory(t) {
  return new (t || HcLabelExtensionComponent)();
};
HcLabelExtensionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcLabelExtensionComponent,
  selectors: [["hc-label-ext"]],
  hostVars: 2,
  hostBindings: function HcLabelExtensionComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp(
        "hc-form-field-label-extension",
        ctx._hostHcLabelClass
      );
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function HcLabelExtensionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
HcLabelExtensionComponent.propDecorators = {
  _hostHcLabelClass: [
    { type: HostBinding, args: ["class.hc-form-field-label-extension"] },
  ],
};
if (false) {
  /** @type {?} */
  HcLabelExtensionComponent.prototype._hostHcLabelClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-form.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * `hcForm` directive that allows settings to be applied to all included HcFormFields
 */
class HcFormDirective {
  constructor() {
    this._tight = false;
    this.unsubscribe$ = new Subject();
  }
  /**
   * Set the tight parameter on all enclosed HcFormFields. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
    this._updateTightFields();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._updateTightFields();
    // Pass the tight setting to any FormFields added dynamically
    this._formFields.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(
      /**
       * @return {?}
       */
      () => this._updateTightFields()
    );
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  /**
   * @return {?}
   */
  _updateTightFields() {
    if (this._formFields) {
      this._formFields.forEach(
        /**
         * @param {?} field
         * @return {?}
         */
        (field) => {
          field.tight = this._tight;
        }
      );
    }
  }
}
HcFormDirective.ɵfac = function HcFormDirective_Factory(t) {
  return new (t || HcFormDirective)();
};
HcFormDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcFormDirective,
  selectors: [["", "hcForm", ""]],
  contentQueries: function HcFormDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcFormFieldComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._formFields = _t);
    }
  },
  inputs: { tight: "tight" },
});
HcFormDirective.propDecorators = {
  _formFields: [{ type: ContentChildren, args: [HcFormFieldComponent] }],
  tight: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcFormDirective.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  HcFormDirective.prototype.unsubscribe$;
  /** @type {?} */
  HcFormDirective.prototype._formFields;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/hc-form-field.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormFieldModule {}
FormFieldModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FormFieldModule });
FormFieldModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function FormFieldModule_Factory(t) {
    return new (t || FormFieldModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/input/input.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputModule {}
InputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: InputModule });
InputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function InputModule_Factory(t) {
    return new (t || InputModule)();
  },
  imports: [[CommonModule, FormFieldModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/select/hc-option.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Utility directive to hold objects used in ngValue
 */
class HcOptionDirective {}
HcOptionDirective.ɵfac = function HcOptionDirective_Factory(t) {
  return new (t || HcOptionDirective)();
};
HcOptionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcOptionDirective,
  selectors: [["option", "ngValue", ""]],
  inputs: { ngValue: "ngValue" },
});
HcOptionDirective.propDecorators = {
  ngValue: [{ type: Input }],
};
if (false) {
  /**
   * Stores the content of ngValue, including objects
   * @type {?}
   */
  HcOptionDirective.prototype.ngValue;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/select/select.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let uniqueId$1 = 1;
class SelectChangeEvent {
  /**
   * @param {?} source
   * @param {?} value
   */
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
}
if (false) {
  /** @type {?} */
  SelectChangeEvent.prototype.source;
  /** @type {?} */
  SelectChangeEvent.prototype.value;
}
/**
 * Select one of many options from a dropdown
 */
class SelectComponent extends HcFormControlComponent {
  /**
   * @param {?} _parentForm
   * @param {?} _parentFormGroup
   * @param {?} _ngControl
   */
  constructor(_parentForm, _parentFormGroup, _ngControl) {
    super();
    this._ngControl = _ngControl;
    this._uniqueInputId = `hc-select-${uniqueId$1++}`;
    this._tight = false;
    this._value = "";
    this._componentId = this._uniqueInputId;
    this.focus = new EventEmitter();
    this.blur = new EventEmitter();
    /**
     * Event emitted whenever the state changes
     */
    this.change = new EventEmitter();
    this._hostClass = true;
    this.onChange =
      /**
       * @return {?}
       */
      () => {};
    this.onTouched =
      /**
       * @return {?}
       */
      () => {};
    this._form = _parentForm || _parentFormGroup;
    if (this._ngControl != null) {
      this._ngControl.valueAccessor = this;
    }
  }
  /**
   * Enables or disables the component
   * @return {?}
   */
  get disabled() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @param {?} disabledVal
   * @return {?}
   */
  set disabled(disabledVal) {
    this._isDisabled = parseBooleanAttribute(disabledVal);
  }
  /**
   * Sets whether this is a required form element
   * @return {?}
   */
  get required() {
    return this._isRequired;
  }
  /**
   * @param {?} requiredVal
   * @return {?}
   */
  set required(requiredVal) {
    this._isRequired = parseBooleanAttribute(requiredVal);
  }
  /**
   * Element id.
   * @return {?}
   */
  get id() {
    return this._componentId || this._uniqueInputId;
  }
  /**
   * @param {?} idVal
   * @return {?}
   */
  set id(idVal) {
    this._componentId = idVal ? idVal : this._uniqueInputId;
  }
  /**
   * Get or set the value of the select component
   * @return {?}
   */
  get value() {
    return this._value;
  }
  /**
   * @param {?} val
   * @return {?}
   */
  set value(val) {
    if (val !== this._value) {
      this._value = val;
      this.onChange(val);
    }
  }
  /**
   * If true, condense the default margin and reduce the font size. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
  }
  /**
   * @return {?}
   */
  get _disabledClass() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    if (this._valueData) {
      setTimeout(
        /**
         * @return {?}
         */
        () => {
          this.writeValue(this._valueData);
        }
      );
    }
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  writeValue(value) {
    this._valueData = value;
    /** @type {?} */
    let targetVal = value;
    // If ngValue is being used, set the currently selected value based on that data
    if (this._options && this._options.length !== 0) {
      /** @type {?} */
      let selectedIndex = 0;
      this._options.forEach(
        /**
         * @param {?} option
         * @param {?} index
         * @return {?}
         */
        (option, index) => {
          if (option.ngValue === value) {
            selectedIndex = index;
          }
        }
      );
      if (this.placeholder) {
        selectedIndex += 1;
      }
      targetVal = this._nativeSelect.nativeElement.options[selectedIndex].value;
    }
    this._value = targetVal;
  }
  /**
   * @param {?} event
   * @param {?} value
   * @return {?}
   */
  _change(event, value) {
    this._valueData = value;
    // If ngValue is being used, pull that value from the directive to allow objects well as strings
    if (this._options.length !== 0) {
      /** @type {?} */
      const optionArray = this._options.toArray();
      /** @type {?} */
      const index = this.placeholder
        ? this._nativeSelect.nativeElement.selectedIndex - 1
        : this._nativeSelect.nativeElement.selectedIndex;
      this._valueData = optionArray[index].ngValue;
    }
    event.stopPropagation();
    this._value = value;
    this.onChange(this._valueData);
    this.change.emit(new SelectChangeEvent(this, this._valueData));
  }
  /**
   * @return {?}
   */
  ngDoCheck() {
    // This needs to be checked every cycle because we can't subscribe to form submissions
    if (this._ngControl) {
      this._updateErrorState();
    }
  }
  /**
   * @private
   * @return {?}
   */
  _updateErrorState() {
    /** @type {?} */
    const oldState = this._errorState;
    // TODO: this could be abstracted out as an @Input() if we need this to be configurable
    /** @type {?} */
    const newState = !!(
      this._ngControl &&
      this._ngControl.invalid &&
      (this._ngControl.touched || (this._form && this._form.submitted))
    );
    if (oldState !== newState) {
      this._errorState = newState;
    }
  }
}
SelectComponent.ɵfac = function SelectComponent_Factory(t) {
  return new (t || SelectComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgForm, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FormGroupDirective, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgControl, 10)
  );
};
SelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: SelectComponent,
  selectors: [["hc-select"]],
  contentQueries: function SelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcOptionDirective, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx._options = _t);
    }
  },
  viewQuery: function SelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c30, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._nativeSelect = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function SelectComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-select", ctx._hostClass)(
        "hc-select-disabled",
        ctx._disabledClass
      );
    }
  },
  inputs: {
    disabled: "disabled",
    required: "required",
    id: "id",
    value: "value",
    tight: "tight",
    placeholder: "placeholder",
  },
  outputs: { focus: "focus", blur: "blur", change: "change" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => SelectComponent
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  ngContentSelectors: _c3,
  decls: 6,
  vars: 6,
  consts: [
    [1, "hc-select-container"],
    [1, "hc-select-chevron"],
    [
      1,
      "hc-select-input",
      3,
      "disabled",
      "value",
      "required",
      "change",
      "focus",
      "blur",
    ],
    ["selectInput", ""],
    ["value", "", "selected", "", "disabled", "", "hidden", "", 4, "ngIf"],
    ["value", "", "selected", "", "disabled", "", "hidden", ""],
  ],
  template: function SelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r2 = ɵngcc0.ɵɵgetCurrentView();
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelement(1, "span", 1);
      ɵngcc0.ɵɵelementStart(2, "select", 2, 3);
      ɵngcc0.ɵɵlistener(
        "change",
        function SelectComponent_Template_select_change_2_listener($event) {
          ɵngcc0.ɵɵrestoreView(_r2);
          const _r0 = ɵngcc0.ɵɵreference(3);
          return ctx._change($event, _r0.value);
        }
      )("focus", function SelectComponent_Template_select_focus_2_listener() {
        return ctx.focus.next();
      })("blur", function SelectComponent_Template_select_blur_2_listener() {
        return ctx.blur.next();
      });
      ɵngcc0.ɵɵtemplate(
        4,
        SelectComponent_option_4_Template,
        2,
        1,
        "option",
        4
      );
      ɵngcc0.ɵɵprojection(5);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-select-tight", ctx.tight);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("value", ctx.value)(
        "required",
        ctx.required
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("ngIf", ctx.placeholder);
    }
  },
  directives: [ɵngcc1.NgIf],
  styles: [
    ".hc-select{display:inline-block;width:100%}.hc-select-container{position:relative}.hc-select-container select:-moz-focusring{color:transparent;text-shadow:0 0 0 #000}@-moz-document url-prefix(){.hc-select-container select:focus{outline:0}}.hc-select-chevron{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;height:35px;-webkit-box-pack:center;justify-content:center;line-height:35px;pointer-events:none;position:absolute;right:0;text-align:center;top:0;width:35px}.hc-select-chevron:after{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNi45NzgiIGhlaWdodD0iMTcuMzE5IiB2aWV3Qm94PSIwIDAgMjYuOTc4IDE3LjMxOSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNSIgZGF0YS1uYW1lPSJQYXRoIDUiIGNsYXNzPSJjbHMtMSIgZD0iTTI4LjE3NS0xMi4xODhhMS4wODEsMS4wODEsMCwwLDAsMC0xLjUyM0wyNS40LTE2LjQ3M2ExLjA2MSwxLjA2MSwwLDAsMC0xLjUwNywwTDE1LTcuNTg0bC04Ljg5LTguODlhMS4wNjEsMS4wNjEsMCwwLDAtMS41MDcsMEwxLjgyNS0xMy43MTFhMS4wODEsMS4wODEsMCwwLDAsMCwxLjUyM0wxNC4yNDcuMjE4YTEuMDYxLDEuMDYxLDAsMCwwLDEuNTA3LDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;box-sizing:border-box;content:'';height:8.5px;margin-top:2px;pointer-events:none;width:13px}.hc-select-disabled .hc-select-chevron{opacity:.4}.hc-select-tight .hc-select-chevron{height:28px}.hc-select-input{font-size:1rem;-webkit-appearance:none;-moz-appearance:none;background-color:#fff;border:1px solid #c0c5cc;border-radius:0;color:#333;cursor:pointer;font:inherit;height:35px;line-height:1.3;padding-left:9px;padding-right:32px;width:100%}.hc-select-input::-ms-expand{display:none}.hc-select-input[disabled]{background-color:#f0f3f6;border:1px solid #e0e0e0;color:#adadad;cursor:not-allowed}.hc-select-input:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-select-input:focus{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-invalid .hc-select-input{border:1px solid #cc2027}.hc-form-field-invalid .hc-select-input:focus{box-shadow:0 0 3px #cc2027}.hc-select-tight .hc-select-input{font-size:.92857rem;height:28px}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
SelectComponent.ctorParameters = () => [
  { type: NgForm, decorators: [{ type: Optional }] },
  { type: FormGroupDirective, decorators: [{ type: Optional }] },
  { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
];
SelectComponent.propDecorators = {
  _options: [{ type: ContentChildren, args: [HcOptionDirective] }],
  _nativeSelect: [
    { type: ViewChild, args: ["selectInput", { static: false }] },
  ],
  placeholder: [{ type: Input }],
  disabled: [{ type: Input }],
  required: [{ type: Input }],
  id: [{ type: Input }],
  value: [{ type: Input }],
  tight: [{ type: Input }],
  focus: [{ type: Output }],
  blur: [{ type: Output }],
  change: [{ type: Output }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-select"] }],
  _disabledClass: [{ type: HostBinding, args: ["class.hc-select-disabled"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype._uniqueInputId;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype._form;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype._value;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype._valueData;
  /** @type {?} */
  SelectComponent.prototype._componentId;
  /** @type {?} */
  SelectComponent.prototype._options;
  /** @type {?} */
  SelectComponent.prototype._nativeSelect;
  /**
   * Optional string of text to appear before selection is made
   * @type {?}
   */
  SelectComponent.prototype.placeholder;
  /** @type {?} */
  SelectComponent.prototype.focus;
  /** @type {?} */
  SelectComponent.prototype.blur;
  /**
   * Event emitted whenever the state changes
   * @type {?}
   */
  SelectComponent.prototype.change;
  /** @type {?} */
  SelectComponent.prototype._hostClass;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype.onChange;
  /**
   * @type {?}
   * @private
   */
  SelectComponent.prototype.onTouched;
  /** @type {?} */
  SelectComponent.prototype._ngControl;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/select/select.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectModule {}
SelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SelectModule });
SelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function SelectModule_Factory(t) {
    return new (t || SelectModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/datepicker.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatepickerModule {}
DatepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DatepickerModule });
DatepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function DatepickerModule_Factory(t) {
    return new (t || DatepickerModule)();
  },
  providers: [HcDatepickerIntl, HC_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER],
  imports: [
    [
      CommonModule,
      FormsModule,
      ReactiveFormsModule,
      ButtonModule,
      IconModule,
      InputModule,
      FormFieldModule,
      SelectModule,
      OverlayModule,
      A11yModule,
      PortalModule,
    ],
  ],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/datepicker/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/services/config-store.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfigStoreService {
  constructor() {
    this.defaultOptions = {
      presets: [],
      format: "medium",
      mode: "date",
      hourCycle: 12,
      excludeWeekends: false,
      locale: "en-us",
      applyLabel: "Apply",
      cancelLabel: "Cancel",
      startDatePrefix: "Start date:",
      endDatePrefix: "End date:",
      invalidDateLabel: "Please enter valid date",
    };
    this.dateRangeOptionsSubject = new BehaviorSubject(this.defaultOptions);
    this.rangeUpdateSubject = new BehaviorSubject({
      fromDate: undefined,
      toDate: undefined,
    });
    this.presetUpdateSubject = new BehaviorSubject({
      fromDate: undefined,
      toDate: undefined,
    });
    this.weekendFilter =
      /**
       * @return {?}
       */
      () => true;
    this.emptyWeekendFilter =
      /**
       * @return {?}
       */
      () => true;
    this.excludeWeekendFilter =
      /**
       * @param {?} d
       * @return {?}
       */
      (d) => {
        /** @type {?} */
        const day = d.getDay();
        return day !== 0 && day !== 6;
      };
    this.dateRangeOptions$ = this.dateRangeOptionsSubject.pipe(
      map(
        /**
         * @param {?} options
         * @return {?}
         */
        (options) => {
          return Object.assign({}, this.defaultOptions, options);
        }
      ),
      tap(
        /**
         * @param {?} options
         * @return {?}
         */
        (options) => {
          if (!!options.excludeWeekends) {
            this.weekendFilter = this.excludeWeekendFilter;
          } else {
            this.weekendFilter = this.emptyWeekendFilter;
          }
        }
      )
    );
    this.rangeUpdate$ = this.rangeUpdateSubject.pipe();
    this.presetUpdate$ = this.presetUpdateSubject.pipe();
  }
  /**
   * @param {?} options
   * @return {?}
   */
  updateDateRangeOptions(options) {
    this.dateRangeOptionsSubject.next(options);
  }
  /**
   * @param {?} dateRange
   * @return {?}
   */
  updateRange(dateRange) {
    this.rangeUpdateSubject.next(dateRange);
  }
  /**
   * @param {?} value
   * @return {?}
   */
  updatePreset(value) {
    this.presetUpdateSubject.next(value);
  }
}
ConfigStoreService.ɵfac = function ConfigStoreService_Factory(t) {
  return new (t || ConfigStoreService)();
};
ConfigStoreService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: ConfigStoreService,
  factory: ConfigStoreService.ɵfac,
});
/** @nocollapse */
ConfigStoreService.ctorParameters = () => [];
if (false) {
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.defaultOptions;
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.dateRangeOptionsSubject;
  /** @type {?} */
  ConfigStoreService.prototype.dateRangeOptions$;
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.rangeUpdateSubject;
  /** @type {?} */
  ConfigStoreService.prototype.rangeUpdate$;
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.presetUpdateSubject;
  /** @type {?} */
  ConfigStoreService.prototype.presetUpdate$;
  /** @type {?} */
  ConfigStoreService.prototype.weekendFilter;
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.emptyWeekendFilter;
  /**
   * @type {?}
   * @private
   */
  ConfigStoreService.prototype.excludeWeekendFilter;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/calendar-wrapper/calendar-wrapper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component combining a calendar and input as a representation of a date
 */
class CalendarWrapperComponent {
  /**
   * @param {?} configStore
   * @param {?} ref
   */
  constructor(configStore, ref) {
    this.configStore = configStore;
    this.ref = ref;
    this._hostClass = true;
    /**
     * Emits when selected date has changed.
     */
    this.selectedDateChange = new EventEmitter();
    /**
     * Whether the pickers include the calendar, time selector, or both. Defaults to `date`.
     */
    this.mode = "date";
    /**
     * Whether the time picker should use a 12 or 24 hour clock. Defaults to 12.
     */
    this.hourCycle = 12;
    this.weekendFilter =
      /**
       * @return {?}
       */
      () => true;
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    // Necessary to force view refresh
    if (changes.selectedDate) {
      /** @type {?} */
      const date = changes.selectedDate.currentValue;
      if (date) {
        this.hcCalendar.activeDate = date;
        this.datePickerInput.setDate(date);
        this.selectedDateChange.emit(date);
      }
    }
  }
  /**
   * @param {?} date
   * @return {?}
   */
  _onCalendarChange(date) {
    this.selectedDateChange.emit(date);
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onInputChange(event) {
    if (this.mode === "time") {
      /** @type {?} */
      let tempVal = event.value
        ? new Date(1900, 1, 1, event.value.getHours(), event.value.getMinutes())
        : new Date(1900, 1, 1);
      /** @type {?} */
      let minVal = this.minDate
        ? new Date(
            1900,
            1,
            1,
            this.minDate.getHours(),
            this.minDate.getMinutes()
          )
        : new Date(1900, 1, 1);
      /** @type {?} */
      let maxVal = this.maxDate
        ? new Date(
            1900,
            1,
            1,
            this.maxDate.getHours(),
            this.maxDate.getMinutes()
          )
        : new Date(1900, 1, 2);
      if (tempVal < minVal || tempVal > maxVal) {
        this.selectedDate = undefined;
        this.selectedDateChange.emit(undefined);
      } else {
        this.selectedDateChange.emit(event.value || undefined);
      }
    } else {
      if (
        event.value &&
        ((this.minDate && event.value < this.minDate) ||
          (this.maxDate && event.value > this.maxDate))
      ) {
        this.selectedDate = undefined;
        this.selectedDateChange.emit(undefined);
      } else {
        this.selectedDateChange.emit(event.value || undefined);
      }
    }
  }
  /**
   * Focus inner input
   * @return {?}
   */
  focusInput() {
    this.datePickerInput.focus();
    this.ref.detectChanges();
  }
}
CalendarWrapperComponent.ɵfac = function CalendarWrapperComponent_Factory(t) {
  return new (t || CalendarWrapperComponent)(
    ɵngcc0.ɵɵdirectiveInject(ConfigStoreService),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
CalendarWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: CalendarWrapperComponent,
  selectors: [["hc-calendar-wrapper"]],
  viewQuery: function CalendarWrapperComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵstaticViewQuery(CalendarComponent, true);
      ɵngcc0.ɵɵstaticViewQuery(DatepickerInputDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.hcCalendar = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.datePickerInput = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function CalendarWrapperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-calendar-wrapper", ctx._hostClass);
    }
  },
  inputs: {
    mode: "mode",
    hourCycle: "hourCycle",
    selectedDate: "selectedDate",
    dateFormat: "dateFormat",
    prefixLabel: "prefixLabel",
    excludeWeekends: "excludeWeekends",
    minDate: "minDate",
    maxDate: "maxDate",
    invalidDateLabel: "invalidDateLabel",
  },
  outputs: { selectedDateChange: "selectedDateChange" },
  features: [ɵngcc0.ɵɵNgOnChangesFeature],
  decls: 6,
  vars: 14,
  consts: [
    [1, "form-container"],
    [1, "hc-calendar-wrapper-form-field"],
    [3, "innerText"],
    [
      "hcInput",
      "",
      "hcDatepicker",
      "",
      "required",
      "",
      3,
      "ngModel",
      "min",
      "max",
      "_mode",
      "_hourCycle",
      "ngModelChange",
      "dateChange",
    ],
    [
      3,
      "mode",
      "hourCycle",
      "startAt",
      "selected",
      "minDate",
      "maxDate",
      "dateFilter",
      "selectedChange",
    ],
  ],
  template: function CalendarWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "hc-form-field", 1);
      ɵngcc0.ɵɵelement(2, "hc-label", 2);
      ɵngcc0.ɵɵelementStart(3, "input", 3);
      ɵngcc0.ɵɵlistener(
        "ngModelChange",
        function CalendarWrapperComponent_Template_input_ngModelChange_3_listener(
          $event
        ) {
          return (ctx.selectedDate = $event);
        }
      )(
        "dateChange",
        function CalendarWrapperComponent_Template_input_dateChange_3_listener(
          $event
        ) {
          return ctx._onInputChange($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(4, "hc-error", 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(5, "hc-calendar", 4);
      ɵngcc0.ɵɵlistener(
        "selectedChange",
        function CalendarWrapperComponent_Template_hc_calendar_selectedChange_5_listener(
          $event
        ) {
          return ctx._onCalendarChange($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("innerText", ctx.prefixLabel);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngModel", ctx.selectedDate)("min", ctx.minDate)(
        "max",
        ctx.maxDate
      )("_mode", ctx.mode)("_hourCycle", ctx.hourCycle);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("innerText", ctx.invalidDateLabel);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("mode", ctx.mode)("hourCycle", ctx.hourCycle)(
        "startAt",
        ctx.selectedDate
      )("selected", ctx.selectedDate)("minDate", ctx.minDate)(
        "maxDate",
        ctx.maxDate
      )("dateFilter", ctx.configStore.weekendFilter);
    }
  },
  directives: [
    HcFormFieldComponent,
    HcLabelComponent,
    DatepickerInputDirective,
    ɵngcc7.DefaultValueAccessor,
    InputDirective,
    ɵngcc7.RequiredValidator,
    ɵngcc7.NgControlStatus,
    ɵngcc7.NgModel,
    HcErrorComponent,
    CalendarComponent,
  ],
  styles: [
    ".hc-calendar-wrapper-form-field>.hc-form-field-wrapper{height:70px;padding-bottom:0}.hc-calendar-wrapper>.form-container{padding-left:13px}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
CalendarWrapperComponent.ctorParameters = () => [
  { type: ConfigStoreService },
  { type: ChangeDetectorRef },
];
CalendarWrapperComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-calendar-wrapper"] }],
  hcCalendar: [
    { type: ViewChild, args: [CalendarComponent, { static: true }] },
  ],
  datePickerInput: [
    { type: ViewChild, args: [DatepickerInputDirective, { static: true }] },
  ],
  selectedDateChange: [{ type: Output }],
  selectedDate: [{ type: Input }],
  dateFormat: [{ type: Input }],
  mode: [{ type: Input }],
  hourCycle: [{ type: Input }],
  prefixLabel: [{ type: Input }],
  excludeWeekends: [{ type: Input }],
  minDate: [{ type: Input }],
  maxDate: [{ type: Input }],
  invalidDateLabel: [{ type: Input }],
};
if (false) {
  /** @type {?} */
  CalendarWrapperComponent.prototype._hostClass;
  /** @type {?} */
  CalendarWrapperComponent.prototype.hcCalendar;
  /** @type {?} */
  CalendarWrapperComponent.prototype.datePickerInput;
  /**
   * Emits when selected date has changed.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.selectedDateChange;
  /**
   * Current selected date.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.selectedDate;
  /** @type {?} */
  CalendarWrapperComponent.prototype.dateFormat;
  /**
   * Whether the pickers include the calendar, time selector, or both. Defaults to `date`.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.mode;
  /**
   * Whether the time picker should use a 12 or 24 hour clock. Defaults to 12.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.hourCycle;
  /**
   * Prefix label on top of component.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.prefixLabel;
  /**
   * Flag to filter out weekends.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.excludeWeekends;
  /**
   * The minimum selectable date.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.minDate;
  /**
   * The maximum selectable date.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.maxDate;
  /**
   * Message displayed when a date is invalid.
   * @type {?}
   */
  CalendarWrapperComponent.prototype.invalidDateLabel;
  /** @type {?} */
  CalendarWrapperComponent.prototype.weekendFilter;
  /** @type {?} */
  CalendarWrapperComponent.prototype.configStore;
  /**
   * @type {?}
   * @private
   */
  CalendarWrapperComponent.prototype.ref;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/picker-overlay/picker-overlay.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// ** Date range wrapper component */
class PickerOverlayComponent {
  /**
   * @param {?} configStoreService
   * @param {?} overlayRef
   * @param {?} cd
   */
  constructor(configStoreService, overlayRef, cd) {
    this.configStoreService = configStoreService;
    this.overlayRef = overlayRef;
    this.cd = cd;
    this._skipRangeCheck = false;
    this.__rangeIsInvalid = false; // if true, the fromDate is after the toDate and save will not be allowed
    this.options$ = configStoreService.dateRangeOptions$;
  }
  /**
   * @param {?} fd
   * @return {?}
   */
  set _fromDate(fd) {
    this.__fromDate = fd;
    this.cd.markForCheck();
  }
  /**
   * @param {?} td
   * @return {?}
   */
  set _toDate(td) {
    this.__toDate = td;
    this.cd.markForCheck();
  }
  /**
   * @param {?} s
   * @return {?}
   */
  set _selectedPreset(s) {
    this.__selectedPreset = s;
    this.cd.markForCheck();
  }
  /**
   * @param {?} isInvalid
   * @return {?}
   */
  set _rangeIsInvalid(isInvalid) {
    this.__rangeIsInvalid = isInvalid;
    this.cd.markForCheck();
  }
  /**
   * @return {?}
   */
  get _fromDate() {
    return this.__fromDate;
  }
  /**
   * @return {?}
   */
  get _toDate() {
    return this.__toDate;
  }
  /**
   * @return {?}
   */
  get _selectedPreset() {
    return this.__selectedPreset;
  }
  /**
   * @return {?}
   */
  get _rangeIsInvalid() {
    return this.__rangeIsInvalid;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this.options$.subscribe(
      /**
       * @param {?} options
       * @return {?}
       */
      (options) => {
        this._presetValues = options.presets;
        this.cd.markForCheck();
      }
    );
    this.configStoreService.rangeUpdate$.subscribe(
      /**
       * @param {?} dateRange
       * @return {?}
       */
      (dateRange) => {
        if (dateRange) {
          this._fromDate = dateRange.fromDate;
          this._toDate = dateRange.toDate;
        } else {
          this._fromDate = undefined;
          this._toDate = undefined;
        }
        this._validateRange();
      }
    );
    this.configStoreService.presetUpdate$.subscribe(
      /**
       * @param {?} presetIndex
       * @return {?}
       */
      (presetIndex) => {
        if (typeof presetIndex === "number") {
          this._selectedPreset = presetIndex;
          this._updateRangeByPreset(presetIndex);
        }
      }
    );
  }
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    if (this.calendarWrappers.first) {
      this.calendarWrappers.first.focusInput();
    }
  }
  /**
   * @param {?=} date
   * @return {?}
   */
  _updateFromDate(date) {
    if (!this._skipRangeCheck) {
      this._fromDate = date;
      this._isRangePreset();
    }
    if (this._rangeIsInvalid) {
      this._validateRange();
    }
  }
  /**
   * @param {?=} date
   * @return {?}
   */
  _updateToDate(date) {
    if (!this._skipRangeCheck) {
      this._toDate = date;
      this._isRangePreset();
    }
    if (this._rangeIsInvalid) {
      this._validateRange();
    }
  }
  /**
   * @param {?} index
   * @return {?}
   */
  _updateRangeByPreset(index) {
    if (this._presetValues && index < this._presetValues.length && index >= 0) {
      // Prevent the system from assigning a preset if one has specifically been selected
      this._skipRangeCheck = true;
      this._fromDate = this._presetValues[index].range.fromDate;
      this._toDate = this._presetValues[index].range.toDate;
      setTimeout(
        /**
         * @return {?}
         */
        () => {
          if (this._fromDate) {
            this.calendarWrappers.first.hcCalendar.activeDate = this._fromDate;
          }
          if (this._toDate) {
            this.calendarWrappers.last.hcCalendar.activeDate = this._toDate;
          }
          this._skipRangeCheck = false;
        }
      );
    }
  }
  /**
   * @return {?}
   */
  _isRangePreset() {
    this._selectedPreset = null;
    if (this._presetValues) {
      for (let i = 0; i < this._presetValues.length; i++) {
        /** @type {?} */
        let radioRange = this._presetValues[i].range;
        if (
          this._fromDate &&
          radioRange.fromDate &&
          this._toDate &&
          radioRange.toDate
        ) {
          if (
            this._fromDate.toDateString() ===
              radioRange.fromDate.toDateString() &&
            this._toDate.toDateString() === radioRange.toDate.toDateString()
          ) {
            this._selectedPreset = i;
          }
        }
      }
    }
  }
  /**
   * @return {?}
   */
  _applyNewDates() {
    if (!!this._toDate && !!this._fromDate) {
      this._validateRange();
      if (this._rangeIsInvalid) {
        return;
      }
      this.configStoreService.updateRange({
        fromDate: this._fromDate,
        toDate: this._toDate,
      });
      if (this._selectedPreset !== null) {
        this.configStoreService.updatePreset(this._selectedPreset);
      } else {
        this.configStoreService.updatePreset({
          fromDate: this._fromDate,
          toDate: this._toDate,
        });
      }
    }
    this.overlayRef.dispose();
  }
  /**
   * @return {?}
   */
  _validateRange() {
    this._rangeIsInvalid =
      !!this._fromDate && !!this._toDate && this._fromDate > this._toDate;
  }
  /**
   * @return {?}
   */
  _discardNewDates() {
    this.overlayRef.dispose();
  }
}
PickerOverlayComponent.ɵfac = function PickerOverlayComponent_Factory(t) {
  return new (t || PickerOverlayComponent)(
    ɵngcc0.ɵɵdirectiveInject(ConfigStoreService),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc3.OverlayRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
PickerOverlayComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: PickerOverlayComponent,
  selectors: [["hc-date-range-picker-overlay"]],
  viewQuery: function PickerOverlayComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(CalendarWrapperComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.calendarWrappers = _t);
    }
  },
  decls: 2,
  vars: 3,
  consts: [
    ["class", "hc-date-range-calendar-container", 4, "ngIf"],
    [1, "hc-date-range-calendar-container"],
    [1, "hc-date-range-calendar-item", "hc-date-range-calendar-wrapper"],
    [
      3,
      "prefixLabel",
      "selectedDate",
      "minDate",
      "maxDate",
      "excludeWeekends",
      "dateFormat",
      "invalidDateLabel",
      "mode",
      "hourCycle",
      "selectedDateChange",
    ],
    [1, "hc-date-range-calendar-item", "hc-date-range"],
    [1, "hc-date-range-menu"],
    [1, "presets", 3, "ngModel", "ngModelChange"],
    [3, "value", "change", 4, "ngFor", "ngForOf"],
    [1, "hc-date-range-controls"],
    [
      "hc-button",
      "",
      "buttonStyle",
      "link",
      "type",
      "button",
      1,
      "hc-date-range-control",
      3,
      "click",
    ],
    [
      "hc-button",
      "",
      "buttonStyle",
      "primary",
      "type",
      "button",
      1,
      "hc-date-range-control",
      3,
      "disabled",
      "click",
    ],
    ["color", "red", 4, "ngIf"],
    [3, "value", "change"],
    ["color", "red"],
    [1, "hc-date-range-warning-icon"],
  ],
  template: function PickerOverlayComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵtemplate(
        0,
        PickerOverlayComponent_div_0_Template,
        15,
        24,
        "div",
        0
      );
      ɵngcc0.ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.options$));
    }
  },
  directives: function () {
    return [
      ɵngcc1.NgIf,
      CalendarWrapperComponent,
      RadioGroupDirective,
      ɵngcc7.NgControlStatus,
      ɵngcc7.NgModel,
      ɵngcc1.NgForOf,
      ButtonComponent,
      RadioButtonComponent,
      ChipComponent,
    ];
  },
  pipes: function () {
    return [ɵngcc1.AsyncPipe];
  },
  styles: [
    ".hc-date-range-calendar-container{display:-webkit-box;display:flex;justify-content:space-around;min-width:650px}.hc-date-range-calendar-item{font-size:14px;font-weight:400;min-width:210px;padding:1em}.hc-date-range-calendar-wrapper{width:338px}.hc-date-range-menu{height:100%;width:250px}.hc-date-range-controls{display:-webkit-box;display:flex;justify-content:space-around;margin:10% auto}.hc-date-range-control{min-width:120px!important}.hc-date-range-overlay{background:#fff;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.hc-date-range-overlay-backdrop{background-color:rgba(0,0,0,.2);opacity:.2}.presets{padding-left:21px}.hc-date-range-warning-icon{-webkit-box-flex:1;flex:1 0 auto;width:16px;height:16px;margin-right:10px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA3OS41IDcwLjEiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc5LjUgNzAuMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6Izk1MUMxRTt9DQo8L3N0eWxlPg0KPHRpdGxlPndhcm48L3RpdGxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTc4LjgsNjIuOEw0NCwyLjRjLTEuMy0yLjMtNC4zLTMuMS02LjctMS44Yy0wLjcsMC40LTEuNCwxLTEuOCwxLjhMMC43LDYyLjhjLTEuMywyLjMtMC41LDUuMywxLjgsNi43DQoJYzAuNywwLjQsMS42LDAuNywyLjQsMC43aDY5LjdjMi43LDAsNC45LTIuMiw0LjktNC45Qzc5LjUsNjQuNCw3OS4yLDYzLjUsNzguOCw2Mi44eiBNMzUuMiwyMC43aDkuMnYyNS43aC05LjJWMjAuN3ogTTM5LjcsNjAuOA0KCWMtMy4xLDAtNS42LTIuNS01LjYtNS42czIuNS01LjYsNS42LTUuNnM1LjYsMi41LDUuNiw1LjZDNDUuNCw1OC4yLDQyLjgsNjAuOCwzOS43LDYwLjh6Ii8+DQo8L3N2Zz4NCg==)}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
PickerOverlayComponent.ctorParameters = () => [
  { type: ConfigStoreService },
  { type: OverlayRef },
  { type: ChangeDetectorRef },
];
PickerOverlayComponent.propDecorators = {
  calendarWrappers: [{ type: ViewChildren, args: [CalendarWrapperComponent] }],
};
if (false) {
  /** @type {?} */
  PickerOverlayComponent.prototype.options$;
  /** @type {?} */
  PickerOverlayComponent.prototype._presetValues;
  /** @type {?} */
  PickerOverlayComponent.prototype._skipRangeCheck;
  /** @type {?} */
  PickerOverlayComponent.prototype.__fromDate;
  /** @type {?} */
  PickerOverlayComponent.prototype.__toDate;
  /** @type {?} */
  PickerOverlayComponent.prototype.__selectedPreset;
  /** @type {?} */
  PickerOverlayComponent.prototype.__rangeIsInvalid;
  /** @type {?} */
  PickerOverlayComponent.prototype.calendarWrappers;
  /** @type {?} */
  PickerOverlayComponent.prototype.configStoreService;
  /**
   * @type {?}
   * @private
   */
  PickerOverlayComponent.prototype.overlayRef;
  /**
   * @type {?}
   * @private
   */
  PickerOverlayComponent.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/services/calendar-overlay.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarOverlayService {
  /**
   * @param {?} overlay
   * @param {?} injector
   */
  constructor(overlay, injector) {
    this.overlay = overlay;
    this.injector = injector;
  }
  /**
   * @param {?} hostElemRef
   * @return {?}
   */
  open(hostElemRef) {
    this.hostElemRef = hostElemRef;
    /** @type {?} */
    const overlayRef = this._createOverlay();
    /** @type {?} */
    const portalInjector = this._createInjector(overlayRef);
    /** @type {?} */
    const calendarPortal = new ComponentPortal(
      PickerOverlayComponent,
      null,
      portalInjector
    );
    overlayRef.attach(calendarPortal);
    overlayRef.backdropClick().subscribe(
      /**
       * @return {?}
       */
      () => overlayRef.dispose()
    );
    return overlayRef;
  }
  /**
   * @private
   * @return {?}
   */
  _createOverlay() {
    /** @type {?} */
    const overlayConfig = this._getOverlayConfig();
    return this.overlay.create(overlayConfig);
  }
  /**
   * @private
   * @return {?}
   */
  _getOverlayConfig() {
    /** @type {?} */
    const positionStrategy = this.overlay
      .position()
      .flexibleConnectedTo(this.hostElemRef)
      .withFlexibleDimensions(false)
      .withViewportMargin(8)
      .withDefaultOffsetY(12)
      .withLockedPosition()
      .withPositions([
        {
          originX: "start",
          originY: "bottom",
          overlayX: "start",
          overlayY: "top",
        },
        {
          originX: "start",
          originY: "top",
          overlayX: "start",
          overlayY: "bottom",
        },
        {
          originX: "end",
          originY: "bottom",
          overlayX: "end",
          overlayY: "top",
        },
        {
          originX: "end",
          originY: "top",
          overlayX: "end",
          overlayY: "bottom",
        },
      ]);
    /** @type {?} */
    const overlayConfig = new OverlayConfig({
      hasBackdrop: true,
      backdropClass: "hc-overlay-transparent-backdrop",
      panelClass: "hc-date-range-overlay",
      scrollStrategy: this.overlay.scrollStrategies.block(),
      positionStrategy,
    });
    return overlayConfig;
  }
  /**
   * @private
   * @param {?} overlayRef
   * @return {?}
   */
  _createInjector(overlayRef) {
    /** @type {?} */
    const injectionTokens = new WeakMap();
    injectionTokens.set(OverlayRef, overlayRef);
    return new PortalInjector(this.injector, injectionTokens);
  }
}
CalendarOverlayService.ɵfac = function CalendarOverlayService_Factory(t) {
  return new (t || CalendarOverlayService)(
    ɵngcc0.ɵɵinject(ɵngcc3.Overlay),
    ɵngcc0.ɵɵinject(ɵngcc0.Injector)
  );
};
CalendarOverlayService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: CalendarOverlayService,
  factory: CalendarOverlayService.ɵfac,
});
/** @nocollapse */
CalendarOverlayService.ctorParameters = () => [
  { type: Overlay },
  { type: Injector },
];
if (false) {
  /**
   * @type {?}
   * @private
   */
  CalendarOverlayService.prototype.hostElemRef;
  /**
   * @type {?}
   * @private
   */
  CalendarOverlayService.prototype.overlay;
  /**
   * @type {?}
   * @private
   */
  CalendarOverlayService.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/date-range/date-range.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateRangeDirective {
  /**
   * @param {?} _elementRef
   * @param {?} calendarOverlayService
   * @param {?} configStoreService
   */
  constructor(_elementRef, calendarOverlayService, configStoreService) {
    this._elementRef = _elementRef;
    this.calendarOverlayService = calendarOverlayService;
    this.configStoreService = configStoreService;
    /**
     * Emits when date range is been changed.
     */
    this.selectedDateRangeChanged = new EventEmitter();
    /**
     * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
     */
    this.selectedPresetChanged = new EventEmitter();
    configStoreService.rangeUpdate$.subscribe(
      /**
       * @param {?} daterange
       * @return {?}
       */
      (daterange) => {
        this.selectedDateRangeChanged.emit(daterange);
      }
    );
    configStoreService.presetUpdate$.subscribe(
      /**
       * @param {?} preset
       * @return {?}
       */
      (preset) => {
        this.selectedPresetChanged.emit(preset);
      }
    );
  }
  /**
   * @return {?}
   */
  ngOnInit() {}
  /**
   * @return {?}
   */
  ngOnDestroy() {
    if (this._overlayRef) {
      this._overlayRef.detach();
    }
  }
  /**
   * @param {?} changes
   * @return {?}
   */
  ngOnChanges(changes) {
    if (changes["options"]) {
      /** @type {?} */
      const options = changes["options"].currentValue;
      this.configStoreService.updateDateRangeOptions(options);
    }
    if (changes["selectedDate"]) {
      /** @type {?} */
      const selectedDate = changes["selectedDate"].currentValue;
      if (typeof selectedDate === "number") {
        this.configStoreService.updatePreset(selectedDate);
      } else {
        this.configStoreService.updateRange(selectedDate);
      }
    }
  }
  /**
   * @return {?}
   */
  _onClick() {
    this._overlayRef = this.calendarOverlayService.open(this._elementRef);
  }
}
DateRangeDirective.ɵfac = function DateRangeDirective_Factory(t) {
  return new (t || DateRangeDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(CalendarOverlayService),
    ɵngcc0.ɵɵdirectiveInject(ConfigStoreService)
  );
};
DateRangeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: DateRangeDirective,
  selectors: [["", "hcDateRange", ""]],
  hostBindings: function DateRangeDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "click",
        function DateRangeDirective_click_HostBindingHandler() {
          return ctx._onClick();
        }
      );
    }
  },
  inputs: { selectedDate: "selectedDate", options: "options" },
  outputs: {
    selectedDateRangeChanged: "selectedDateRangeChanged",
    selectedPresetChanged: "selectedPresetChanged",
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      CalendarOverlayService,
      ConfigStoreService,
      DatePipe,
    ]),
    ɵngcc0.ɵɵNgOnChangesFeature,
  ],
});
/** @nocollapse */
DateRangeDirective.ctorParameters = () => [
  { type: ElementRef },
  { type: CalendarOverlayService },
  { type: ConfigStoreService },
];
DateRangeDirective.propDecorators = {
  selectedDateRangeChanged: [{ type: Output }],
  selectedDate: [{ type: Input }],
  selectedPresetChanged: [{ type: Output }],
  options: [{ type: Input }],
  _onClick: [{ type: HostListener, args: ["click"] }],
};
if (false) {
  /**
   * Emits when date range is been changed.
   * @type {?}
   */
  DateRangeDirective.prototype.selectedDateRangeChanged;
  /**
   * Sets the selected date range. Accepts either a `DateRange` or a numerical index for preset.
   * @type {?}
   */
  DateRangeDirective.prototype.selectedDate;
  /**
   * Emits either a numerical index for the selected preset, or a `DateRange` if the selected value is not a preset
   * @type {?}
   */
  DateRangeDirective.prototype.selectedPresetChanged;
  /**
   * Configuration to setup behavior of component.
   * @type {?}
   */
  DateRangeDirective.prototype.options;
  /**
   * @type {?}
   * @private
   */
  DateRangeDirective.prototype._overlayRef;
  /**
   * @type {?}
   * @private
   */
  DateRangeDirective.prototype._elementRef;
  /**
   * @type {?}
   * @private
   */
  DateRangeDirective.prototype.calendarOverlayService;
  /** @type {?} */
  DateRangeDirective.prototype.configStoreService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/radio-button/radio.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextUniqueId = 0;
/**
 * Groups single radio buttons together into a set for which only one can be selected
 */
class RadioGroupDirective extends HcFormControlComponent {
  /**
   * @param {?} _cdRef
   * @param {?} _parentForm
   * @param {?} _parentFormGroup
   * @param {?} _ngControl
   */
  constructor(_cdRef, _parentForm, _parentFormGroup, _ngControl) {
    super();
    this._cdRef = _cdRef;
    this._ngControl = _ngControl;
    this._verticalClass = true;
    this._horizontalClass = false;
    /**
     * Event emitted when the value of a radio button changes inside the group.
     */
    this.change = new EventEmitter();
    this._value = null;
    this._uniqueName = `hc-radio-group-${nextUniqueId++}`;
    this._name = this._uniqueName;
    this._inline = false;
    this._tight = false;
    this._initialized = false; // if value of radio group has been set to initial value
    // if value of radio group has been set to initial value
    this._selected = null; // the currently selected radio
    this._componentId = this._name;
    this._onChangeFn =
      /**
       * @return {?}
       */
      () => {};
    this._onTouchFn =
      /**
       * @return {?}
       */
      () => {};
    this._form = _parentForm || _parentFormGroup;
    if (this._ngControl != null) {
      this._ngControl.valueAccessor = this;
    }
  }
  /**
   * Name of radio group. Auto-generated name will be used if no name is set
   * @return {?}
   */
  get name() {
    return this._name;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set name(value) {
    this._name = value ? value : this._uniqueName;
    this._updateRadioButtonNames();
  }
  /**
   * Unique id for the radio group. If none is supplied, defaults to name.
   * @return {?}
   */
  get id() {
    return this._componentId || this._name;
  }
  /**
   * @param {?} idVal
   * @return {?}
   */
  set id(idVal) {
    this._componentId = idVal ? idVal : this._name;
  }
  /**
   * Value of radio buttons
   * @return {?}
   */
  get value() {
    return this._value;
  }
  /**
   * @param {?} newValue
   * @return {?}
   */
  set value(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this._updateSelectedRadio();
      this._checkSelectedRadio();
    }
  }
  /**
   * Boolean value that enables/disables the radio group
   * @return {?}
   */
  get disabled() {
    if (this._ngControl && this._ngControl.disabled) {
      return this._ngControl.disabled;
    }
    return this._isDisabled;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set disabled(value) {
    this._isDisabled = parseBooleanAttribute(value);
    this._markRadiosForCheck();
  }
  /**
   * Boolean value of whether the radio group is required on a form
   * @return {?}
   */
  get required() {
    return this._isRequired;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set required(value) {
    this._isRequired = parseBooleanAttribute(value);
    this._markRadiosForCheck();
  }
  /**
   * Gets and sets the currently selected value of the radio button group
   * @return {?}
   */
  get selected() {
    return this._selected;
  }
  /**
   * @param {?} button
   * @return {?}
   */
  set selected(button) {
    this._selected = button;
    this.value = button ? button.value : null;
    this._checkSelectedRadio();
  }
  /**
   * Sets the layout orientation of the radio button group; defaults to false
   * @return {?}
   */
  get inline() {
    return this._inline;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set inline(value) {
    this._inline = parseBooleanAttribute(value);
    this._verticalClass = !this._inline;
    this._horizontalClass = this._inline;
  }
  /**
   * If true, condense the default margin and reduce the font size on all contained radios. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
    if (this._initialized) {
      setTimeout(
        /**
         * @return {?}
         */
        () => this._markRadiosForCheck()
      );
    }
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._initialized = true;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  writeValue(value) {
    this.value = value;
    this._cdRef.markForCheck();
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnChange(fn) {
    this._onChangeFn = fn;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnTouched(fn) {
    this._onTouchFn = fn;
  }
  /**
   * @return {?}
   */
  _touch() {
    if (this._onTouchFn) {
      this._onTouchFn();
    }
  }
  /**
   * @return {?}
   */
  _emitChangeEvent() {
    if (this._initialized) {
      this.change.emit(new RadioButtonChangeEvent(this._selected, this.value));
    }
  }
  /**
   * @private
   * @return {?}
   */
  _markRadiosForCheck() {
    if (this.radios) {
      this.radios.forEach(
        /**
         * @param {?} radio
         * @return {?}
         */
        (radio) => radio._markForCheck()
      );
    }
  }
  /**
   * @private
   * @return {?}
   */
  _updateSelectedRadio() {
    /** @type {?} */
    let isAlreadySelected =
      this._selected !== null && this._selected.value === this._value;
    if (this.radios && !isAlreadySelected) {
      this._selected = null;
      this.radios.forEach(
        /**
         * @param {?} radio
         * @return {?}
         */
        (radio) => {
          radio.checked = this.value === radio.value;
          if (radio.checked) {
            this._selected = radio;
          }
        }
      );
    }
  }
  /**
   * @private
   * @return {?}
   */
  _checkSelectedRadio() {
    if (this._selected && !this._selected.checked) {
      this._selected.checked = true;
    }
  }
  /**
   * @private
   * @return {?}
   */
  _updateRadioButtonNames() {
    if (this.radios) {
      this.radios.forEach(
        /**
         * @param {?} radio
         * @return {?}
         */
        (radio) => {
          radio.name = this.name;
        }
      );
    }
  }
  /**
   * @return {?}
   */
  ngDoCheck() {
    // This needs to be checked every cycle because we can't subscribe to form submissions
    if (this._ngControl) {
      this._updateErrorState();
    }
  }
  /**
   * @private
   * @return {?}
   */
  _updateErrorState() {
    /** @type {?} */
    const oldState = this._errorState;
    // TODO: this could be abstracted out as an @Input() if we need this to be configurable
    /** @type {?} */
    const newState = !!(
      this._ngControl &&
      this._ngControl.invalid &&
      (this._ngControl.touched || (this._form && this._form.submitted))
    );
    if (oldState !== newState) {
      this._errorState = newState;
    }
  }
}
RadioGroupDirective.ɵfac = function RadioGroupDirective_Factory(t) {
  return new (t || RadioGroupDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgForm, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FormGroupDirective, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc7.NgControl, 10)
  );
};
RadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: RadioGroupDirective,
  selectors: [["hc-radio-group"]],
  contentQueries: function RadioGroupDirective_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, RadioButtonComponent, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx.radios = _t);
    }
  },
  hostVars: 4,
  hostBindings: function RadioGroupDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-radio-group-vertical", ctx._verticalClass)(
        "hc-radio-group-horizontal",
        ctx._horizontalClass
      );
    }
  },
  inputs: {
    name: "name",
    id: "id",
    value: "value",
    disabled: "disabled",
    required: "required",
    inline: "inline",
    tight: "tight",
  },
  outputs: { change: "change" },
  exportAs: ["hcRadioGroup"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: HcFormControlComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => RadioGroupDirective
        ),
        multi: true,
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/** @nocollapse */
RadioGroupDirective.ctorParameters = () => [
  { type: ChangeDetectorRef },
  { type: NgForm, decorators: [{ type: Optional }] },
  { type: FormGroupDirective, decorators: [{ type: Optional }] },
  { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
];
RadioGroupDirective.propDecorators = {
  _verticalClass: [
    { type: HostBinding, args: ["class.hc-radio-group-vertical"] },
  ],
  _horizontalClass: [
    { type: HostBinding, args: ["class.hc-radio-group-horizontal"] },
  ],
  change: [{ type: Output }],
  radios: [
    {
      type: ContentChildren,
      args: [
        forwardRef(
          /**
           * @return {?}
           */
          () => RadioButtonComponent
        ),
        { descendants: true },
      ],
    },
  ],
  name: [{ type: Input }],
  id: [{ type: Input }],
  value: [{ type: Input }],
  disabled: [{ type: Input }],
  required: [{ type: Input }],
  inline: [{ type: Input }],
  tight: [{ type: Input }],
};
if (false) {
  /** @type {?} */
  RadioGroupDirective.prototype._verticalClass;
  /** @type {?} */
  RadioGroupDirective.prototype._horizontalClass;
  /**
   * Event emitted when the value of a radio button changes inside the group.
   * @type {?}
   */
  RadioGroupDirective.prototype.change;
  /**
   * A list of all the radio buttons included in the group
   * @type {?}
   */
  RadioGroupDirective.prototype.radios;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._value;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._uniqueName;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._name;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._inline;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._initialized;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._selected;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._form;
  /** @type {?} */
  RadioGroupDirective.prototype._componentId;
  /** @type {?} */
  RadioGroupDirective.prototype._onChangeFn;
  /** @type {?} */
  RadioGroupDirective.prototype._onTouchFn;
  /**
   * @type {?}
   * @private
   */
  RadioGroupDirective.prototype._cdRef;
  /** @type {?} */
  RadioGroupDirective.prototype._ngControl;
}
/**
 * Event type that is emitted when a radio button or radio button group changes
 */
class RadioButtonChangeEvent {
  /**
   * @param {?} source the radio button that fired the event
   * @param {?} value the value of that radio button
   */
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
}
if (false) {
  /** @type {?} */
  RadioButtonChangeEvent.prototype.source;
  /** @type {?} */
  RadioButtonChangeEvent.prototype.value;
}
/**
 * Radio buttons allow the user to choose only one of a predefined set of mutually exclusive options.
 */
class RadioButtonComponent {
  /**
   * @param {?} radioGroup
   * @param {?} cdRef
   * @param {?} _elementRef
   */
  constructor(radioGroup, cdRef, _elementRef) {
    this.cdRef = cdRef;
    this._elementRef = _elementRef;
    this._uniqueId = `hc-radio-button-${nextUniqueId++}`;
    /**
     * Element id for the radio button. Auto-generated id will be used if none is set
     */
    this.id = this._uniqueId;
    /**
     * Event emitted when the value of the radio button changes
     */
    this.change = new EventEmitter();
    this._checked = false;
    this._value = null;
    this._required = false;
    this._disabled = false;
    this._tight = false;
    this.radioGroup = radioGroup;
  }
  /**
   * Value of radio buttons
   * @return {?}
   */
  get value() {
    return this._value;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set value(value) {
    if (this._value !== value) {
      this._value = value;
      if (this.radioGroup !== null && !this.checked) {
        this.checked = this.radioGroup.value === value;
      } else if (this.radioGroup !== null && this.checked) {
        this.radioGroup.selected = this;
      }
    }
  }
  /**
   * @return {?}
   */
  get _getHostId() {
    return this.id;
  }
  /**
   * Boolean value of whether the radio button is required
   * @return {?}
   */
  get required() {
    return (
      this._required || (this.radioGroup != null && this.radioGroup.required)
    );
  }
  /**
   * @param {?} required
   * @return {?}
   */
  set required(required) {
    this._required = parseBooleanAttribute(required);
  }
  /**
   * Boolean value that enables/disables the radio button
   * @return {?}
   */
  get disabled() {
    return (
      this._disabled || (this.radioGroup != null && this.radioGroup.disabled)
    );
  }
  /**
   * @param {?} isDisabled
   * @return {?}
   */
  set disabled(isDisabled) {
    this._disabled = parseBooleanAttribute(isDisabled);
  }
  /**
   * Boolean that returns whether the radio button is selected
   * @return {?}
   */
  get checked() {
    return this._checked;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set checked(value) {
    /** @type {?} */
    let newCheckedState = parseBooleanAttribute(value);
    if (this._checked !== newCheckedState) {
      this._checked = newCheckedState;
      if (
        newCheckedState &&
        this.radioGroup &&
        this.radioGroup.value !== this.value
      ) {
        this.radioGroup.selected = this;
      } else if (
        !newCheckedState &&
        this.radioGroup &&
        this.radioGroup.value === this.value
      ) {
        this.radioGroup.selected = null;
      }
      this.cdRef.markForCheck();
    }
  }
  /**
   * @return {?}
   */
  get _inlineGroup() {
    if (this.radioGroup !== null) {
      return this.radioGroup.inline;
    } else {
      return false;
    }
  }
  /**
   * If true, condense the default margin, reduce the font size, and decrease the circle size.
   * Inherits value from parent radio group if part of one. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    if (this.radioGroup !== null) {
      return this.radioGroup.tight;
    } else {
      return this._tight;
    }
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
  }
  /**
   * @return {?}
   */
  get _inputId() {
    return `${this.id || this._uniqueId}-input`;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    if (this.radioGroup !== null) {
      this.checked = this.radioGroup.value === this._value;
      this.name = this.radioGroup.name;
    }
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onInputClick(event) {
    event.stopPropagation();
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onInputChange(event) {
    event.stopPropagation();
    /** @type {?} */
    const valueChanged =
      this.radioGroup && this.value !== this.radioGroup.value;
    this._emitChangeEvent();
    if (this.radioGroup !== null) {
      this.radioGroup._onChangeFn(this.value);
      this.radioGroup._touch();
      if (valueChanged) {
        this.radioGroup._emitChangeEvent();
        this.radioGroup.value = this.value;
      }
    } else {
      this.checked = true;
    }
  }
  /**
   * @private
   * @return {?}
   */
  _emitChangeEvent() {
    this.change.emit(new RadioButtonChangeEvent(this, this.value));
  }
  /**
   * @return {?}
   */
  _markForCheck() {
    this.cdRef.markForCheck();
  }
}
RadioButtonComponent.ɵfac = function RadioButtonComponent_Factory(t) {
  return new (t || RadioButtonComponent)(
    ɵngcc0.ɵɵdirectiveInject(RadioGroupDirective, 8),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
RadioButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: RadioButtonComponent,
  selectors: [["hc-radio-button"]],
  hostVars: 1,
  hostBindings: function RadioButtonComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("id", ctx._getHostId);
    }
  },
  inputs: {
    id: "id",
    value: "value",
    checked: "checked",
    required: "required",
    disabled: "disabled",
    tight: "tight",
    name: "name",
  },
  outputs: { change: "change" },
  ngContentSelectors: _c3,
  decls: 5,
  vars: 16,
  consts: [
    [1, "hc-radio-container"],
    [
      "type",
      "radio",
      1,
      "hc-radio-input",
      3,
      "id",
      "disabled",
      "required",
      "checked",
      "change",
      "click",
    ],
    [1, "hc-radio-overlay"],
    [1, "hc-radio-content"],
  ],
  template: function RadioButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "label", 0);
      ɵngcc0.ɵɵelementStart(1, "input", 1);
      ɵngcc0.ɵɵlistener(
        "change",
        function RadioButtonComponent_Template_input_change_1_listener($event) {
          return ctx._onInputChange($event);
        }
      )("click", function RadioButtonComponent_Template_input_click_1_listener(
        $event
      ) {
        return ctx._onInputClick($event);
      });
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(2, "span", 2);
      ɵngcc0.ɵɵelementStart(3, "div", 3);
      ɵngcc0.ɵɵprojection(4);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("disabled", ctx.disabled)(
        "hc-radio-inline",
        ctx._inlineGroup
      )("hc-radio-tight", ctx.tight);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
      ɵngcc0.ɵɵproperty("id", ctx._inputId)("disabled", ctx.disabled)(
        "required",
        ctx.required
      )("checked", ctx.checked);
      ɵngcc0.ɵɵattribute("value", ctx.value)("name", ctx.name);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  styles: [
    ".hc-radio-container[_ngcontent-%COMP%]{cursor:pointer;display:block;line-height:1.5;margin:4px 0;padding-left:35px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.hc-radio-container.disabled[_ngcontent-%COMP%]{color:#ccc;cursor:not-allowed}.hc-radio-container.hc-radio-inline[_ngcontent-%COMP%]{padding-left:32px;margin-right:25px}.hc-radio-container.hc-radio-tight[_ngcontent-%COMP%]{margin:1px 15px 1px 0;padding-left:25px}.hc-radio-tight[_ngcontent-%COMP%]   .hc-radio-overlay[_ngcontent-%COMP%]{height:18px;width:18px;top:1px}.hc-radio-tight[_ngcontent-%COMP%]   .hc-radio-overlay[_ngcontent-%COMP%]:after{left:3px;top:3px}.hc-radio-tight[_ngcontent-%COMP%]   .hc-radio-content[_ngcontent-%COMP%]{font-size:.92857rem}.hc-radio-overlay[_ngcontent-%COMP%]{background-color:#fff;border:1px solid #c0c5cc;border-radius:50%;height:22px;left:0;position:absolute;top:0;width:22px}.hc-radio-overlay[_ngcontent-%COMP%]:after{background:#fff;border-radius:50%;content:'';display:none;height:8px;left:5px;position:absolute;top:5px;width:8px}.hc-radio-overlay.disabled[_ngcontent-%COMP%]{background-color:#e0e0e0;border-color:#ccc;cursor:not-allowed}.hc-radio-overlay.disabled[_ngcontent-%COMP%]:after{background:#e0e0e0}.hc-radio-container[_ngcontent-%COMP%]:hover   .hc-radio-overlay[_ngcontent-%COMP%]{border:1px solid #00aeff;background-color:#f2fbff}.hc-radio-container[_ngcontent-%COMP%]:hover   .hc-radio-overlay.disabled[_ngcontent-%COMP%]{background-color:#e0e0e0;border-color:#ccc;cursor:not-allowed}.hc-radio-container[_ngcontent-%COMP%]:hover   .hc-radio-overlay.disabled[_ngcontent-%COMP%]:after{background:#e0e0e0}.hc-radio-input[_ngcontent-%COMP%]:checked ~ .hc-radio-overlay[_ngcontent-%COMP%]{background-color:#00aeff;border:2px solid #00aeff}.hc-radio-input[_ngcontent-%COMP%]:checked ~ .hc-radio-overlay[_ngcontent-%COMP%]:after{display:block}.hc-radio-input[_ngcontent-%COMP%]:checked ~ .hc-radio-overlay.disabled[_ngcontent-%COMP%]{background-color:#e0e0e0;border:1px solid #ccc}.hc-radio-input[_ngcontent-%COMP%]{cursor:pointer;opacity:0;position:absolute}.hc-radio-input.disabled[_ngcontent-%COMP%]{cursor:not-allowed}.hc-radio-input[_ngcontent-%COMP%]:focus + .hc-radio-overlay[_ngcontent-%COMP%]{outline:0;box-shadow:0 0 5px #00aeff}.hc-radio-input[_ngcontent-%COMP%]:active + .hc-radio-overlay[_ngcontent-%COMP%]{outline:0}",
  ],
  changeDetection: 0,
});
/** @nocollapse */
RadioButtonComponent.ctorParameters = () => [
  { type: RadioGroupDirective, decorators: [{ type: Optional }] },
  { type: ChangeDetectorRef },
  { type: ElementRef },
];
RadioButtonComponent.propDecorators = {
  id: [{ type: Input }],
  name: [{ type: Input }],
  change: [{ type: Output }],
  value: [{ type: Input }],
  _getHostId: [{ type: HostBinding, args: ["attr.id"] }],
  required: [{ type: Input }],
  disabled: [{ type: Input }],
  checked: [{ type: Input }],
  tight: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._uniqueId;
  /**
   * Element id for the radio button. Auto-generated id will be used if none is set
   * @type {?}
   */
  RadioButtonComponent.prototype.id;
  /**
   * Name of radio button
   * @type {?}
   */
  RadioButtonComponent.prototype.name;
  /**
   * Event emitted when the value of the radio button changes
   * @type {?}
   */
  RadioButtonComponent.prototype.change;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._checked;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._value;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._required;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._disabled;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype.radioGroup;
  /**
   * @type {?}
   * @private
   */
  RadioButtonComponent.prototype.cdRef;
  /** @type {?} */
  RadioButtonComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/radio-button/radio-button.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioButtonModule {}
RadioButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RadioButtonModule });
RadioButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function RadioButtonModule_Factory(t) {
    return new (t || RadioButtonModule)();
  },
  providers: [],
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/date-range.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateRangeModule {}
DateRangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DateRangeModule });
DateRangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function DateRangeModule_Factory(t) {
    return new (t || DateRangeModule)();
  },
  imports: [
    [
      CommonModule,
      ChipModule,
      FormFieldModule,
      DatepickerModule,
      HcNativeDateModule,
      InputModule,
      ButtonModule,
      RadioButtonModule,
      OverlayModule,
      FormsModule,
    ],
  ],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-range/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/drawer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Result of opening or closing the drawer
 */
class DrawerPromiseResult {
  /**
   * @param {?} type
   */
  constructor(type) {
    this.type = type;
  }
}
if (false) {
  /** @type {?} */
  DrawerPromiseResult.prototype.type;
}
/** @type {?} */
const supportedModes = ["over", "push", "side"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateModeInput(inputStr) {
  if (supportedModes.indexOf(inputStr) < 0) {
    throw Error("Unsupported drawer mode value: " + inputStr);
  }
}
/** @type {?} */
const supportedAligns$1 = ["left", "right"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateAlignInput$1(inputStr) {
  if (supportedAligns$1.indexOf(inputStr) < 0) {
    throw Error("Unsupported drawer alignment value: " + inputStr);
  }
}
/** @type {?} */
const openStateAnimation = "400ms cubic-bezier(0.25, 0.8, 0.25, 1)";
/**
 * Drawer that can be opened or closed on the drawer container
 */
class Drawer {
  /**
   * @param {?} elementRef
   */
  constructor(elementRef) {
    this.elementRef = elementRef;
    this._openChange = new EventEmitter();
    this._mode = "push";
    this._align = "left";
    /**
     * Tabindex of the element
     */
    this.tabindex = -1;
    this._drawerClass = true;
    this._animationStarted = new EventEmitter();
    this._animationDisabled = true;
    this._drawerOpened = false;
    this._resolveAnimationPromise =
      /**
       * @return {?}
       */
      () => {};
  }
  /**
   * Mode of the drawer: `over`, `push` or `side`
   * @return {?}
   */
  get mode() {
    return this._mode;
  }
  /**
   * @param {?} modeType
   * @return {?}
   */
  set mode(modeType) {
    validateModeInput(modeType);
    this._mode = modeType;
  }
  /**
   * Side the drawer is attached to: `left` or `right`
   * @return {?}
   */
  get align() {
    return this._align;
  }
  /**
   * @param {?} alignType
   * @return {?}
   */
  set align(alignType) {
    validateAlignInput$1(alignType);
    this._align = alignType;
  }
  /**
   * Event emitted when drawer has started to open
   * @return {?}
   */
  get openStart() {
    return this._animationStarted.pipe(
      filter(
        /**
         * @param {?} event
         * @return {?}
         */
        (event) => event.fromState === "void" && event.toState === "open"
      ),
      map(
        /**
         * @return {?}
         */
        () => {}
      )
    );
  }
  /**
   * Event emitted when drawer has started to close
   * @return {?}
   */
  get closeStart() {
    return this._animationStarted.pipe(
      filter(
        /**
         * @param {?} event
         * @return {?}
         */
        (event) => event.fromState === "open" && event.toState === "void"
      ),
      map(
        /**
         * @return {?}
         */
        () => {}
      )
    );
  }
  /**
   * Event emitted when drawer has opened
   * @return {?}
   */
  get _openStream() {
    return this._openChange.pipe(
      filter(
        /**
         * @param {?} value
         * @return {?}
         */
        (value) => value
      ),
      map(
        /**
         * @return {?}
         */
        () => {}
      )
    );
  }
  /**
   * Event emitted when drawer has closed
   * @return {?}
   */
  get _closeStream() {
    return this._openChange.pipe(
      filter(
        /**
         * @param {?} value
         * @return {?}
         */
        (value) => !value
      ),
      map(
        /**
         * @return {?}
         */
        () => {}
      )
    );
  }
  /**
   * Whether the drawer is opened.
   * @return {?}
   */
  get opened() {
    return this._drawerOpened;
  }
  /**
   * @param {?} opened
   * @return {?}
   */
  set opened(opened) {
    this.toggle(parseBooleanAttribute(opened));
  }
  /**
   * @return {?}
   */
  get _width() {
    return this.elementRef.nativeElement.offsetWidth;
  }
  /**
   * @return {?}
   */
  get _isOpened() {
    return this._drawerOpened && !this._animationPromise;
  }
  /**
   * @return {?}
   */
  get _isOpening() {
    return this._drawerOpened && !!this._animationPromise;
  }
  /**
   * @return {?}
   */
  get _isClosed() {
    return !this._drawerOpened && !this._animationPromise;
  }
  /**
   * @return {?}
   */
  get _isClosing() {
    return !this._drawerOpened && !!this._animationPromise;
  }
  /**
   * @return {?}
   */
  get _isRight() {
    return this._align === "right";
  }
  /**
   * @return {?}
   */
  get _openState() {
    if (this._drawerOpened) {
      if (this._animationDisabled) {
        return "open-instant";
      }
      return this._align === "right" ? "open-right" : "open-left";
    }
    return "void";
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onAnimationStart(event) {
    this._animationStarted.emit(event);
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onAnimationEnd(event) {
    this._openChange.next(this.opened);
    if (this._animationPromise) {
      this._resolveAnimationPromise();
      this._resolveAnimationPromise =
        /**
         * @return {?}
         */
        () => {};
      this._animationPromise = null;
    }
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onKeyDown(event) {
    if (event.keyCode === 27) {
      this.toggleClose();
      event.stopPropagation();
    }
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    if (this._animationPromise) {
      this._resolveAnimationPromise();
      this._resolveAnimationPromise =
        /**
         * @return {?}
         */
        () => {};
      this._animationPromise = null;
    }
    this._animationDisabled = false;
  }
  /**
   * Toggles the drawer open
   * @return {?}
   */
  toggleOpen() {
    return this.toggle(true);
  }
  /**
   * Toggles the drawer closed
   * @return {?}
   */
  toggleClose() {
    return this.toggle(false);
  }
  /**
   * Toggles the drawer
   * @param {?=} isOpen
   * @return {?}
   */
  toggle(isOpen = !this.opened) {
    if (!this._animationPromise) {
      this._drawerOpened = isOpen;
      this._animationPromise = new Promise(
        /**
         * @param {?} resolve
         * @return {?}
         */ (resolve) => {
          this._resolveAnimationPromise =
            /**
             * @return {?}
             */
            () => resolve(new DrawerPromiseResult(isOpen ? "open" : "close"));
        }
      );
    }
    return this._animationPromise;
  }
}
Drawer.ɵfac = function Drawer_Factory(t) {
  return new (t || Drawer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));
};
Drawer.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: Drawer,
  selectors: [["hc-drawer"]],
  hostVars: 14,
  hostBindings: function Drawer_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵsyntheticHostListener(
        "@openState.start",
        function Drawer_animation_openState_start_HostBindingHandler($event) {
          return ctx._onAnimationStart($event);
        }
      )(
        "@openState.done",
        function Drawer_animation_openState_done_HostBindingHandler($event) {
          return ctx._onAnimationEnd($event);
        }
      );
      ɵngcc0.ɵɵlistener("keydown", function Drawer_keydown_HostBindingHandler(
        $event
      ) {
        return ctx._onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵngcc0.ɵɵhostProperty("tabindex", ctx.tabindex);
      ɵngcc0.ɵɵsyntheticHostProperty("@openState", ctx._openState);
      ɵngcc0.ɵɵclassProp("hc-drawer", ctx._drawerClass)(
        "hc-drawer-opened",
        ctx._isOpened
      )("hc-drawer-opening", ctx._isOpening)("hc-drawer-closed", ctx._isClosed)(
        "hc-drawer-closing",
        ctx._isClosing
      )("hc-drawer-right", ctx._isRight);
    }
  },
  inputs: { mode: "mode", align: "align", opened: "opened" },
  outputs: {
    openStart: "openStart",
    closeStart: "closeStart",
    _openStream: "opened",
    _closeStream: "closed",
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function Drawer_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  styles: [_c33],
  encapsulation: 2,
  data: {
    animation: [
      trigger("openState", [
        state(
          "open-left, open-right, open-instant",
          style({
            visibility: "visible",
          })
        ),
        state(
          "void",
          style({
            "box-shadow": "none",
            visibility: "hidden",
          })
        ),
        transition("void => open-instant", animate("0ms")),
        transition("open-instant => void", animate(openStateAnimation)),
        transition("void => open-left", [
          animate("0ms", style({ transform: "translate3d(-100%, 0, 0)" })),
          animate(openStateAnimation),
        ]),
        transition("open-left => void", [
          animate(
            openStateAnimation,
            style({ transform: "translate3d(-100%, 0, 0)" })
          ),
        ]),
        transition("void => open-right", [
          animate("0ms", style({ transform: "translate3d(100%, 0, 0)" })),
          animate(openStateAnimation),
        ]),
        transition("open-right => void", [
          animate(
            openStateAnimation,
            style({ transform: "translate3d(100%, 0, 0)" })
          ),
        ]),
      ]),
    ],
  },
  changeDetection: 0,
});
/** @nocollapse */
Drawer.ctorParameters = () => [{ type: ElementRef }];
Drawer.propDecorators = {
  mode: [{ type: Input }],
  align: [{ type: Input }],
  openStart: [{ type: Output }],
  closeStart: [{ type: Output }],
  _openStream: [{ type: Output, args: ["opened"] }],
  _closeStream: [{ type: Output, args: ["closed"] }],
  tabindex: [{ type: HostBinding }],
  _drawerClass: [{ type: HostBinding, args: ["class.hc-drawer"] }],
  opened: [{ type: Input }],
  _isOpened: [{ type: HostBinding, args: ["class.hc-drawer-opened"] }],
  _isOpening: [{ type: HostBinding, args: ["class.hc-drawer-opening"] }],
  _isClosed: [{ type: HostBinding, args: ["class.hc-drawer-closed"] }],
  _isClosing: [{ type: HostBinding, args: ["class.hc-drawer-closing"] }],
  _isRight: [{ type: HostBinding, args: ["class.hc-drawer-right"] }],
  _openState: [{ type: HostBinding, args: ["@openState"] }],
  _onAnimationStart: [
    { type: HostListener, args: ["@openState.start", ["$event"]] },
  ],
  _onAnimationEnd: [
    { type: HostListener, args: ["@openState.done", ["$event"]] },
  ],
  _onKeyDown: [{ type: HostListener, args: ["keydown", ["$event"]] }],
};
if (false) {
  /** @type {?} */
  Drawer.prototype._openChange;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._mode;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._align;
  /**
   * Tabindex of the element
   * @type {?}
   */
  Drawer.prototype.tabindex;
  /** @type {?} */
  Drawer.prototype._drawerClass;
  /** @type {?} */
  Drawer.prototype._animationStarted;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._animationDisabled;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._drawerOpened;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._animationPromise;
  /**
   * @type {?}
   * @private
   */
  Drawer.prototype._resolveAnimationPromise;
  /**
   * @type {?}
   * @protected
   */
  Drawer.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/drawer-container.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} align
 * @return {?}
 */
function throwDrawerContainerError(align) {
  throw new Error(`A drawer was already declared for 'align="${align}"'`);
}
/**
 * Parent component that houses one or two `<hc-drawer>` that applies content styling
 */
class DrawerContainer {
  /**
   * @param {?} _elementRef
   * @param {?} _renderer
   * @param {?} _ngZone
   * @param {?} _changeDetector
   */
  constructor(_elementRef, _renderer, _ngZone, _changeDetector) {
    this._elementRef = _elementRef;
    this._renderer = _renderer;
    this._ngZone = _ngZone;
    this._changeDetector = _changeDetector;
    this._contentMargins = { left: 0, right: 0 };
    this._doCheckSubject = new Subject();
    this._destroyed = new Subject();
    this._hostClass = true;
  }
  // If drawer size changes through some async action this will cause it to resize the margins
  /**
   * @return {?}
   */
  ngDoCheck() {
    // Run outside of angular's scope because debounceTime will cause infinite loop
    this._ngZone.runOutsideAngular(
      /**
       * @return {?}
       */
      () => this._doCheckSubject.next()
    );
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    // debounceTime allows the component to render before the margins are calculated
    this._doCheckSubject
      .pipe(
        debounceTime(10), // arbitrarily small value is used to quickly render the component so incorrect margins aren't shown
        takeUntil(this._destroyed)
      )
      .subscribe(
        /**
         * @return {?}
         */
        () => this._calculateContentMargins()
      );
    // startWith used to cause first iteration
    this._drawers.changes.pipe(startWith(null)).subscribe(
      /**
       * @return {?}
       */
      () => {
        this._validateDrawers();
        this._drawers.forEach(
          /**
           * @param {?} drawer
           * @return {?}
           */
          (drawer) => {
            drawer._animationStarted
              .pipe(
                takeUntil(this._drawers.changes),
                filter(
                  /**
                   * @param {?} event
                   * @return {?}
                   */
                  (event) => event.fromState !== event.toState
                )
              )
              .subscribe(
                /**
                 * @return {?}
                 */
                () => {
                  this._calculateContentMargins();
                }
              );
            drawer._openChange.pipe(takeUntil(this._drawers.changes)).subscribe(
              /**
               * @param {?} isOpen
               * @return {?}
               */
              (isOpen) => {
                if (isOpen) {
                  this._setContainerClass(true);
                } else {
                  this._setContainerClass(false);
                }
              }
            );
          }
        );
        if (
          !this._drawers.length ||
          this._isDrawerOpen(this._leftDrawer) ||
          this._isDrawerOpen(this._rightDrawer)
        ) {
          this._calculateContentMargins();
        }
      }
    );
  }
  /**
   * @private
   * @param {?} drawer
   * @return {?}
   */
  _isDrawerOpen(drawer) {
    return drawer != null && drawer.opened;
  }
  /**
   * Open all drawers
   * @return {?}
   */
  open() {
    return Promise.all(
      [this._leftDrawer, this._rightDrawer].map(
        /**
         * @param {?} drawer
         * @return {?}
         */
        (drawer) => drawer && drawer.toggleOpen()
      )
    );
  }
  /**
   * Close all drawers
   * @return {?}
   */
  close() {
    return Promise.all(
      [this._leftDrawer, this._rightDrawer].map(
        /**
         * @param {?} drawer
         * @return {?}
         */
        (drawer) => drawer && drawer.toggleClose()
      )
    );
  }
  /**
   * @private
   * @return {?}
   */
  _calculateContentMargins() {
    /** @type {?} */
    let left = 0;
    /** @type {?} */
    let right = 0;
    if (this._leftDrawer && this._leftDrawer.opened) {
      if (this._leftDrawer.mode === "side") {
        left += this._leftDrawer._width;
      } else if (this._leftDrawer.mode === "push") {
        left += this._leftDrawer._width;
        right -= this._leftDrawer._width;
      }
    }
    if (this._rightDrawer && this._rightDrawer.opened) {
      if (this._rightDrawer.mode === "side") {
        right += this._rightDrawer._width;
      } else if (this._rightDrawer.mode === "push") {
        right += this._rightDrawer._width;
        left -= this._rightDrawer._width;
      }
    }
    if (
      left !== this._contentMargins.left ||
      right !== this._contentMargins.right
    ) {
      this._contentMargins = { left, right };
      this._ngZone.run(
        /**
         * @return {?}
         */
        () => this._changeDetector.markForCheck()
      );
    }
  }
  /**
   * @private
   * @return {?}
   */
  _validateDrawers() {
    for (let drawer of this._drawers.toArray()) {
      if (drawer.align === "right") {
        if (this._rightDrawer != null) {
          throwDrawerContainerError("right");
        }
        this._rightDrawer = drawer;
      } else {
        if (this._leftDrawer != null) {
          throwDrawerContainerError("left");
        }
        this._leftDrawer = drawer;
      }
    }
  }
  /**
   * @private
   * @param {?} isOpen
   * @return {?}
   */
  _setContainerClass(isOpen) {
    if (isOpen) {
      this._renderer.addClass(
        this._elementRef.nativeElement,
        "hc-drawer-opened"
      );
    } else {
      this._renderer.removeClass(
        this._elementRef.nativeElement,
        "hc-drawer-opened"
      );
    }
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
    this._doCheckSubject.complete();
  }
}
DrawerContainer.ɵfac = function DrawerContainer_Factory(t) {
  return new (t || DrawerContainer)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
DrawerContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: DrawerContainer,
  selectors: [["hc-drawer-container"]],
  contentQueries: function DrawerContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, Drawer, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx._drawers = _t);
    }
  },
  hostVars: 2,
  hostBindings: function DrawerContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-drawer-container", ctx._hostClass);
    }
  },
  ngContentSelectors: _c32,
  decls: 3,
  vars: 4,
  consts: [[1, "hc-drawer-content"]],
  template: function DrawerContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c31);
      ɵngcc0.ɵɵprojection(0);
      ɵngcc0.ɵɵelementStart(1, "div", 0);
      ɵngcc0.ɵɵprojection(2, 1);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵstyleProp("margin-left", ctx._contentMargins.left, "px")(
        "margin-right",
        ctx._contentMargins.right,
        "px"
      );
    }
  },
  styles: [_c33],
  encapsulation: 2,
});
/** @nocollapse */
DrawerContainer.ctorParameters = () => [
  { type: ElementRef },
  { type: Renderer2 },
  { type: NgZone },
  { type: ChangeDetectorRef },
];
DrawerContainer.propDecorators = {
  _drawers: [{ type: ContentChildren, args: [Drawer] }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-drawer-container"] }],
};
if (false) {
  /** @type {?} */
  DrawerContainer.prototype._drawers;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._leftDrawer;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._rightDrawer;
  /** @type {?} */
  DrawerContainer.prototype._contentMargins;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._doCheckSubject;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._destroyed;
  /** @type {?} */
  DrawerContainer.prototype._hostClass;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._elementRef;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._renderer;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._ngZone;
  /**
   * @type {?}
   * @private
   */
  DrawerContainer.prototype._changeDetector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/menu-drawer/drawer-header.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* MenuDrawer toolbar that is fixed to the top */
class DrawerToolbar {
  constructor() {
    this._hostClass = true;
  }
}
DrawerToolbar.ɵfac = function DrawerToolbar_Factory(t) {
  return new (t || DrawerToolbar)();
};
DrawerToolbar.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: DrawerToolbar,
  selectors: [["", "hcDrawerToolbar", ""]],
  hostVars: 2,
  hostBindings: function DrawerToolbar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-drawer-toolbar", ctx._hostClass);
    }
  },
});
DrawerToolbar.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-drawer-toolbar"] }],
};
if (false) {
  /** @type {?} */
  DrawerToolbar.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/menu-drawer/menu-drawer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const drawerThemes = ["dark-theme"];
/**
 * @param {?} menuTheme
 * @return {?}
 */
function validateMenuDrawerTheme(menuTheme) {
  if (
    !drawerThemes.some(
      /**
       * @param {?} theme
       * @return {?}
       */
      (theme) => theme === menuTheme
    )
  ) {
    throw new Error("Unsupported menuTheme: " + menuTheme);
  }
}
/** @type {?} */
const openStateAnimation$1 = "400ms cubic-bezier(0.25, 0.8, 0.25, 1)";
/**
 * Menu drawer that provides default themes
 */
class MenuDrawer extends Drawer {
  /**
   * @param {?} elementRef
   * @param {?} renderer
   */
  constructor(elementRef, renderer) {
    super(elementRef);
    this.renderer = renderer;
    this._previousTheme = null;
    this._hostClass = true;
    this.menuTheme = "dark-theme";
  }
  /**
   * Sets menu style of the drawer. Choose from: `'dark-theme'`
   * @return {?}
   */
  get menuTheme() {
    return this._menuTheme;
  }
  /**
   * @param {?} menuStyle
   * @return {?}
   */
  set menuTheme(menuStyle) {
    validateMenuDrawerTheme(menuStyle);
    this._setThemeClass(this._themeClass(menuStyle));
    this._previousTheme = this._menuTheme;
    this._menuTheme = menuStyle;
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    super.ngAfterContentInit();
    if (this.toolbar != null) {
      this.renderer.addClass(
        this.elementRef.nativeElement,
        "hc-drawer-toolbar-visible"
      );
    } else {
      this.renderer.removeClass(
        this.elementRef.nativeElement,
        "hc-drawer-toolbar-visible"
      );
    }
  }
  /**
   * @private
   * @param {?} menuStyle
   * @return {?}
   */
  _themeClass(menuStyle) {
    return `hc-menu-drawer-${menuStyle}`;
  }
  /**
   * @private
   * @param {?} className
   * @return {?}
   */
  _setThemeClass(className) {
    if (this._previousTheme !== className) {
      if (this._previousTheme || this._menuTheme) {
        this.renderer.removeClass(
          this.elementRef.nativeElement,
          this._previousTheme || this.menuTheme
        );
      }
      this.renderer.addClass(this.elementRef.nativeElement, className);
    }
  }
}
MenuDrawer.ɵfac = function MenuDrawer_Factory(t) {
  return new (t || MenuDrawer)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)
  );
};
MenuDrawer.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: MenuDrawer,
  selectors: [["hc-menu-drawer"]],
  contentQueries: function MenuDrawer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, DrawerToolbar, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.toolbar = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function MenuDrawer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-menu-drawer", ctx._hostClass);
    }
  },
  inputs: { menuTheme: "menuTheme" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: Drawer,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => MenuDrawer
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  ngContentSelectors: _c35,
  decls: 5,
  vars: 0,
  consts: [
    [1, "hc-menu-drawer-toolbar-container"],
    [1, "hc-menu-drawer-item-container"],
    [1, "drawer-menu"],
  ],
  template: function MenuDrawer_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c34);
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(2, "div", 1);
      ɵngcc0.ɵɵelementStart(3, "div", 2);
      ɵngcc0.ɵɵprojection(4, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
  },
  styles: [
    _c33,
    ".hc-menu-drawer{display:block;overflow:hidden}.hc-menu-drawer-item-container{background-color:#384655;height:100%;overflow-y:auto}.hc-drawer-toolbar-visible .hc-menu-drawer-item-container{height:calc(100% - 52px)}.hc-menu-drawer-toolbar-container{background-color:#2e3946;color:#00aeff;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;font-size:18px}.hc-drawer-toolbar{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:52px;max-height:52px;overflow:hidden;padding:15px 28px 15px 15px}.hc-drawer-item{color:#fff;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-webkit-box-align:center;align-items:center;padding:15px 28px 15px 15px;cursor:pointer;width:100%}.hc-drawer-item:last-child hr{display:none}.hc-drawer-item:hover{background-color:#323f4d}.hc-drawer-divider{border:none;background-color:#6b737b;height:1px;margin:0 28px 0 0}.hc-drawer-right .hc-drawer-divider{margin:0 0 0 15px}",
  ],
  encapsulation: 2,
  data: {
    animation: [
      trigger("openState", [
        state(
          "open-left, open-right, open-instant",
          style({
            transform: "translate3d(0, 0, 0)",
            visibility: "visible",
          })
        ),
        state(
          "void",
          style({
            "box-shadow": "none",
            visibility: "hidden",
          })
        ),
        transition("void => open-instant", animate("0ms")),
        transition("open-instant => void", animate(openStateAnimation$1)),
        transition("void => open-left", [
          animate("0ms", style({ transform: "translate3d(-100%, 0, 0)" })),
          animate(openStateAnimation$1),
        ]),
        transition("open-left => void", [
          animate(
            openStateAnimation$1,
            style({ transform: "translate3d(-100%, 0, 0)" })
          ),
        ]),
        transition("void => open-right", [
          animate("0ms", style({ transform: "translate3d(100%, 0, 0)" })),
          animate(openStateAnimation$1),
        ]),
        transition("open-right => void", [
          animate(
            openStateAnimation$1,
            style({ transform: "translate3d(100%, 0, 0)" })
          ),
        ]),
      ]),
    ],
  },
  changeDetection: 0,
});
/** @nocollapse */
MenuDrawer.ctorParameters = () => [{ type: ElementRef }, { type: Renderer2 }];
MenuDrawer.propDecorators = {
  toolbar: [{ type: ContentChild, args: [DrawerToolbar, { static: false }] }],
  menuTheme: [{ type: Input }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-menu-drawer"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  MenuDrawer.prototype._previousTheme;
  /** @type {?} */
  MenuDrawer.prototype.toolbar;
  /**
   * @type {?}
   * @private
   */
  MenuDrawer.prototype._menuTheme;
  /** @type {?} */
  MenuDrawer.prototype._hostClass;
  /**
   * @type {?}
   * @private
   */
  MenuDrawer.prototype.renderer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/menu-drawer/drawer-item.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* Represents a menu item for the MenuDrawer component */
class DrawerItem {}
DrawerItem.ɵfac = function DrawerItem_Factory(t) {
  return new (t || DrawerItem)();
};
DrawerItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: DrawerItem,
  selectors: [["hc-drawer-item"]],
  ngContentSelectors: _c3,
  decls: 3,
  vars: 0,
  consts: [
    [1, "hc-drawer-item"],
    [1, "hc-drawer-divider"],
  ],
  template: function DrawerItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(2, "hr", 1);
    }
  },
  encapsulation: 2,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/drawer.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const exportedComponents = [
  Drawer,
  DrawerContainer,
  MenuDrawer,
  DrawerItem,
  DrawerToolbar,
];
class DrawerModule {}
DrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DrawerModule });
DrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function DrawerModule_Factory(t) {
    return new (t || DrawerModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/drawer/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-field/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/icon/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/input/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Parent component that can house multiple `<hc-list-item>` and applies Cashmere list styling
 */
class ListComponent {
  constructor() {
    this._hostClass = true;
  }
}
ListComponent.ɵfac = function ListComponent_Factory(t) {
  return new (t || ListComponent)();
};
ListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ListComponent,
  selectors: [["hc-list"]],
  hostVars: 2,
  hostBindings: function ListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-list", ctx._hostClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  styles: [".hc-list{display:block}"],
  encapsulation: 2,
});
ListComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-list"] }],
};
if (false) {
  /** @type {?} */
  ListComponent.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list-item/list-item.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Represents a row within a `<hc-list>`. Multiple `[hcListLine]` can be used
 * per `<hc-list-item>`. You can also prefix a `[hcListAvatar]` or `[hcListIcon]`
 * to the beginning of the `<hc-list-item>`.
 */
class ListItemComponent {
  constructor() {
    this._hostClass = true;
  }
}
ListItemComponent.ɵfac = function ListItemComponent_Factory(t) {
  return new (t || ListItemComponent)();
};
ListItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ListItemComponent,
  selectors: [["hc-list-item"]],
  hostVars: 2,
  hostBindings: function ListItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-list-item", ctx._hostClass);
    }
  },
  ngContentSelectors: _c37,
  decls: 5,
  vars: 0,
  consts: [
    [1, "hc-list-content"],
    [1, "hc-list-text"],
  ],
  template: function ListItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c36);
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵelementStart(2, "div", 1);
      ɵngcc0.ɵɵprojection(3, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵprojection(4, 2);
      ɵngcc0.ɵɵelementEnd();
    }
  },
  styles: [
    ".hc-list-item{color:rgba(0,0,0,.87);display:block;font-size:16px;height:56px}.hc-list-content{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:inherit;padding:0 12px}.hc-list-text{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding-left:16px;width:100%}.hc-list-avatar,.hc-list-icon{font-size:24px;height:24px;padding:4px;width:24px}.hc-list-avatar{border-radius:50%}.hc-list-line{display:block;font-size:inherit;font-weight:400;margin:0;overflow:hidden;padding:0;text-overflow:ellipsis;white-space:nowrap}",
  ],
  encapsulation: 2,
});
ListItemComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-list-item"] }],
};
if (false) {
  /** @type {?} */
  ListItemComponent.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list-item/directives/list-avatar.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prepends an avatar styled element to the beginning of a `<hc-list-item>`.
 */
class ListAvatarDirective {
  /**
   * @return {?}
   */
  get _hostClass() {
    return true;
  }
}
ListAvatarDirective.ɵfac = function ListAvatarDirective_Factory(t) {
  return new (t || ListAvatarDirective)();
};
ListAvatarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: ListAvatarDirective,
  selectors: [["", "hcListAvatar", ""]],
  hostVars: 2,
  hostBindings: function ListAvatarDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-list-avatar", ctx._hostClass);
    }
  },
});
ListAvatarDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-list-avatar"] }],
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list-item/directives/list-icon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prefixes an icon to the beginning of a `<hc-list-item>`.
 */
class ListIconDirective {
  constructor() {
    this._hostClass = true;
  }
}
ListIconDirective.ɵfac = function ListIconDirective_Factory(t) {
  return new (t || ListIconDirective)();
};
ListIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: ListIconDirective,
  selectors: [["", "hcListIcon", ""]],
  hostVars: 2,
  hostBindings: function ListIconDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-list-icon", ctx._hostClass);
    }
  },
});
ListIconDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-list-icon"] }],
};
if (false) {
  /** @type {?} */
  ListIconDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list-item/directives/list-line.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Represents a line within a `hc-list-item` row. Multiple can be used within `hc-list-item`.
 */
class ListLineDirective {}
ListLineDirective.ɵfac = function ListLineDirective_Factory(t) {
  return new (t || ListLineDirective)();
};
ListLineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: ListLineDirective,
  selectors: [["", "hcListLine", ""]],
  hostVars: 2,
  hostBindings: function ListLineDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-list-line", ctx._hostClass);
    }
  },
});
ListLineDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-list-line"] }],
};
if (false) {
  /** @type {?} */
  ListLineDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/list.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ListModule {}
ListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ListModule });
ListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ListModule_Factory(t) {
    return new (t || ListModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/list/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/active-modal.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, U
 */
class ActiveModal {
  /**
   * Closes the modal with an optional result.
   * Use this close method when opening a modal using a component. When doing so,
   * ActiveModal must be injected in order to get access to the close method.
   * To dismiss a modal that was created from a TemplateRef, use the dismiss method
   * on HcModal
   * @param {?=} result
   * @return {?}
   */
  close(result) {}
  /**
   * Dismisses the modal with no result.
   * Use this dismiss method when opening a modal using a component. When doing so,
   * ActiveModal must be injected in order to get access to the dismiss method.
   * To dismiss a modal that was created from a TemplateRef, use the dismiss method
   * on HcModal
   * @return {?}
   */
  dismiss() {}
}
if (false) {
  /**
   * Data that was passed in through ModalOptions
   * @type {?}
   */
  ActiveModal.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalComponent {
  constructor() {
    this._modalWrapperClass = true;
  }
}
ModalComponent.ɵfac = function ModalComponent_Factory(t) {
  return new (t || ModalComponent)();
};
ModalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalComponent,
  selectors: [["hc-modal"]],
  hostVars: 2,
  hostBindings: function ModalComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-modal-content", ctx._modalWrapperClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ModalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
ModalComponent.propDecorators = {
  _modalWrapperClass: [{ type: HostBinding, args: ["class.hc-modal-content"] }],
};
if (false) {
  /** @type {?} */
  ModalComponent.prototype._modalWrapperClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal-footer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalFooterComponent {
  constructor() {
    this._modalFooterClass = true;
  }
}
ModalFooterComponent.ɵfac = function ModalFooterComponent_Factory(t) {
  return new (t || ModalFooterComponent)();
};
ModalFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalFooterComponent,
  selectors: [["hc-modal-footer"]],
  hostVars: 2,
  hostBindings: function ModalFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-modal-footer", ctx._modalFooterClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ModalFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
ModalFooterComponent.propDecorators = {
  _modalFooterClass: [{ type: HostBinding, args: ["class.hc-modal-footer"] }],
};
if (false) {
  /** @type {?} */
  ModalFooterComponent.prototype._modalFooterClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal-window.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalWindowComponent {
  /**
   * @param {?} activeModal
   * @param {?} el
   */
  constructor(activeModal, el) {
    this.activeModal = activeModal;
    this.el = el;
    this._ignoreOverlayClick = false;
    this._size = "auto";
  }
  /**
   * @return {?}
   */
  _fadeInOut() {
    return state;
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _overlayClick(event) {
    /** @type {?} */
    let modalContentNotPresent = true;
    /** @type {?} */
    let path = this._eventPath(event);
    /** @type {?} */
    let modalWindowTargetIncluded =
      path.findIndex(
        /**
         * @param {?} p
         * @return {?}
         */
        (p) => p === this.el.nativeElement
      ) > -1;
    /** @type {?} */
    let classList = path.map(
      /**
       * @param {?} p
       * @return {?}
       */
      (p) => p.classList
    );
    for (let cl of classList) {
      if (cl) {
        if (cl.contains("hc-modal-content")) {
          modalContentNotPresent = false;
        }
      }
    }
    /* The hc-modal has 100% height (although not completely visible).
            To enable closing the modal while clicking above or below the modal (in
            addition to the sides) this function will check to see if the click
            event includes:
                1. This window element
                2. Not the hc-modal-content and
                3. the overlay click option is disabled. */
    if (
      !this._ignoreOverlayClick &&
      modalContentNotPresent &&
      modalWindowTargetIncluded
    ) {
      this.activeModal.dismiss();
    }
  }
  // Serves as a polyfill for Event.composedPath() or Event.Path
  /**
   * @param {?} evt
   * @return {?}
   */
  _eventPath(evt) {
    /** @type {?} */
    let path = (evt.composedPath && evt.composedPath()) || evt.path;
    /** @type {?} */
    let target = evt.target;
    if (path != null) {
      // Safari doesn't include Window, but it should.
      return path.indexOf(window) < 0 ? path.concat(window) : path;
    }
    if (target === window) {
      return [window];
    }
    /**
     * @param {?} node
     * @param {?=} memo
     * @return {?}
     */
    function _getParents(node, memo) {
      memo = memo || [];
      /** @type {?} */
      let parentNode = node.parentNode;
      if (!parentNode) {
        return memo;
      } else {
        return _getParents(parentNode, memo.concat(parentNode));
      }
    }
    return [target].concat(_getParents(target), window);
  }
}
ModalWindowComponent.ɵfac = function ModalWindowComponent_Factory(t) {
  return new (t || ModalWindowComponent)(
    ɵngcc0.ɵɵdirectiveInject(ActiveModal),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
ModalWindowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalWindowComponent,
  selectors: [["hc-modal-window"]],
  hostAttrs: [1, "hc-modal-window"],
  hostVars: 1,
  hostBindings: function ModalWindowComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "mousedown",
        function ModalWindowComponent_mousedown_HostBindingHandler($event) {
          return ctx._overlayClick($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵsyntheticHostProperty("@fadeInOut", ctx._fadeInOut);
    }
  },
  inputs: { _ignoreOverlayClick: "_ignoreOverlayClick", _size: "_size" },
  ngContentSelectors: _c3,
  decls: 2,
  vars: 2,
  template: function ModalWindowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div");
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassMap("hc-modal hc-modal-" + ctx._size);
    }
  },
  styles: [
    ".hc-modal-window{-webkit-box-align:center;align-items:center;bottom:0;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;left:0;position:fixed;right:0;top:0}.hc-modal{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;height:calc(100% - 50px);-webkit-box-pack:center;justify-content:center;max-height:calc(100% - 50px);min-height:135px}.hc-modal-auto{width:auto}.hc-modal-sm{width:300px}.hc-modal-md{width:500px}.hc-modal-lg{width:800px}.hc-modal-xl{width:992px}",
  ],
  encapsulation: 2,
  data: {
    animation: [
      trigger("fadeInOut", [
        state("in", style({ opacity: 1 })),
        transition("void <=> *", [
          style({
            opacity: 0,
          }),
          animate("0.2s ease-in-out"),
        ]),
      ]),
    ],
  },
});
/** @nocollapse */
ModalWindowComponent.ctorParameters = () => [
  { type: ActiveModal },
  { type: ElementRef },
];
ModalWindowComponent.propDecorators = {
  _ignoreOverlayClick: [{ type: Input }],
  _size: [{ type: Input }],
  _fadeInOut: [{ type: HostBinding, args: ["@fadeInOut"] }],
  _overlayClick: [{ type: HostListener, args: ["mousedown", ["$event"]] }],
};
if (false) {
  /** @type {?} */
  ModalWindowComponent.prototype._ignoreOverlayClick;
  /** @type {?} */
  ModalWindowComponent.prototype._size;
  /**
   * @type {?}
   * @private
   */
  ModalWindowComponent.prototype.activeModal;
  /**
   * @type {?}
   * @private
   */
  ModalWindowComponent.prototype.el;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal-overlay.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalOverlayComponent {
  /**
   * @param {?} activeModal
   */
  constructor(activeModal) {
    this.activeModal = activeModal;
    this._ignoreEscapeKey = false;
  }
  /**
   * @return {?}
   */
  _fadeInOut() {
    return state;
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _escapeKey(event) {
    if (!this._ignoreEscapeKey) {
      this.activeModal.dismiss();
    }
  }
}
ModalOverlayComponent.ɵfac = function ModalOverlayComponent_Factory(t) {
  return new (t || ModalOverlayComponent)(
    ɵngcc0.ɵɵdirectiveInject(ActiveModal)
  );
};
ModalOverlayComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalOverlayComponent,
  selectors: [["hc-modal-overlay"]],
  hostAttrs: [1, "hc-modal-overlay"],
  hostVars: 1,
  hostBindings: function ModalOverlayComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "keyup.escape",
        function ModalOverlayComponent_keyup_escape_HostBindingHandler($event) {
          return ctx._escapeKey($event);
        },
        false,
        ɵngcc0.ɵɵresolveDocument
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵsyntheticHostProperty("@fadeInOut", ctx._fadeInOut);
    }
  },
  inputs: { _ignoreEscapeKey: "_ignoreEscapeKey" },
  decls: 0,
  vars: 0,
  template: function ModalOverlayComponent_Template(rf, ctx) {},
  styles: [
    "\n            .hc-modal-overlay {\n                background-color: #000;\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                opacity: 0.5;\n                display: block;\n            }\n        ",
  ],
  encapsulation: 2,
  data: {
    animation: [
      trigger("fadeInOut", [
        state("in", style({ opacity: 0.5 })),
        transition("void <=> *", [
          style({
            opacity: 0,
          }),
          animate("0.2s ease-in-out"),
        ]),
      ]),
    ],
  },
});
/** @nocollapse */
ModalOverlayComponent.ctorParameters = () => [{ type: ActiveModal }];
ModalOverlayComponent.propDecorators = {
  _ignoreEscapeKey: [{ type: Input }],
  _fadeInOut: [{ type: HostBinding, args: ["@fadeInOut"] }],
  _escapeKey: [
    { type: HostListener, args: ["document:keyup.escape", ["$event"]] },
  ],
};
if (false) {
  /** @type {?} */
  ModalOverlayComponent.prototype._ignoreEscapeKey;
  /**
   * @type {?}
   * @private
   */
  ModalOverlayComponent.prototype.activeModal;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class HcModal {
  constructor() {
    this._result = new Subject();
    this._modalClose = new EventEmitter();
  }
  /**
   * Subscribe to result in order to get access to modal result values passed in ActiveModal.close()
   * @return {?}
   */
  get result() {
    return this._result.asObservable();
  }
  /**
   * Closes the modal with a result.
   * Use this close method when opening a modal using a TemplateRef.
   * To close a modal that was created from a Component, inject ActiveModal and use the close method
   * on ActiveModal
   * @param {?=} result
   * @return {?}
   */
  close(result) {
    this.removeModalElements();
    this._result.next(result);
  }
  /**
   * Dismisses the modal with no result.
   * Use this dismiss method when opening a modal using a TemplateRef.
   * To dismiss a modal that was created from a Component, inject ActiveModal and use the dismiss method
   * on ActiveModal
   * @return {?}
   */
  dismiss() {
    this.removeModalElements();
  }
  /**
   * @private
   * @return {?}
   */
  removeModalElements() {
    if (this.window) {
      /** @type {?} */
      const windowNativeElement = this.window.location.nativeElement;
      windowNativeElement.parentNode.removeChild(windowNativeElement);
      this.window.destroy();
    }
    if (this.overlay) {
      /** @type {?} */
      const overlayNativeElement = this.overlay.location.nativeElement;
      overlayNativeElement.parentNode.removeChild(overlayNativeElement);
      this.overlay.destroy();
    }
    if (this.componentRef) {
      /** @type {?} */
      const componentNativeElement = this.componentRef.location.nativeElement;
      componentNativeElement.parentNode.removeChild(componentNativeElement);
      this.componentRef.destroy();
    }
    if (this._removeOpenClass) {
      this._removeOpenClass();
    }
    this._modalClose.emit();
    this.window = null;
    this.overlay = null;
    this.componentRef = null;
    this._removeOpenClass = null;
  }
}
if (false) {
  /**
   * Allows direct access to the component used to create the modal. Null when TemplateRef is used
   * @type {?}
   */
  HcModal.prototype.componentRef;
  /**
   * Allows direct access to overlay component which holds the component/template
   * @type {?}
   */
  HcModal.prototype.overlay;
  /**
   * Allows direct access to window component which holds the component/template
   * @type {?}
   */
  HcModal.prototype.window;
  /**
   * @type {?}
   * @private
   */
  HcModal.prototype._result;
  /** @type {?} */
  HcModal.prototype._removeOpenClass;
  /** @type {?} */
  HcModal.prototype._modalClose;
  /**
   * Data that was passed in through ModalOptions
   * @type {?}
   */
  HcModal.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalService {
  /**
   * @param {?} _componentFactory
   * @param {?} _injector
   * @param {?} _applicationRef
   * @param {?} _rendererFactory
   */
  constructor(_componentFactory, _injector, _applicationRef, _rendererFactory) {
    this._componentFactory = _componentFactory;
    this._injector = _injector;
    this._applicationRef = _applicationRef;
    /**
     * Defaults to false. Restricts multiple modals from being opened on top of each other
     * (an error will be thrown if attempted). It's generally considered bad practice to open multiple
     * models at once, so only change this with good reason.
     */
    this.allowMultiple = false;
    // start at 2000 (reserved range for modals, see _variables.scss)
    this._zIndexCounter = 2000;
    this._modalsOpen = 0;
    this._renderer = _rendererFactory.createRenderer(null, null);
  }
  /**
   * Opens a new modal either from a Component or a TemplateRef with the options specified in ModalOptions
   * In order to use a component, it must be specified in your module's EntryComponents.
   * @template T
   * @param {?} modalContent
   * @param {?=} modalOptions
   * @return {?}
   */
  open(modalContent, modalOptions) {
    if (!this.allowMultiple && this._modalsOpen !== 0) {
      throw new Error(`Multiple modals may not be opened at the same time
                when the allowMultiple property on ModalService is set to false.`);
    }
    /** @type {?} */
    let container = /** @type {?} */ (document.querySelector("body"));
    /** @type {?} */
    const defaultOptions = {
      container,
      data: {},
      ignoreEscapeKey: false,
      size: "auto",
      ignoreOverlayClick: false,
    };
    /** @type {?} */
    const options = Object.assign({}, defaultOptions, modalOptions);
    if (options.container) {
      container = options.container;
    }
    if (!container) {
      throw new Error(
        "Modal requires that a container be set in the modal options"
      );
    }
    // TODO: HcModal and ActiveModal essentially are the same object with HcModal having refs. Might as well merge them to simplify
    /** @type {?} */
    let modal = new HcModal();
    /** @type {?} */
    let activeModalRef = new ActiveModal();
    modal.data = options.data;
    activeModalRef.data = options.data;
    /** @type {?} */
    const modalInjector = Injector.create({
      providers: [{ provide: ActiveModal, useValue: activeModalRef }],
      parent: this._injector,
    });
    // disable scrolling when overlay is present
    this._renderer.addClass(container, "hc-modal-open");
    modal._removeOpenClass =
      /**
       * @return {?}
       */
      () => this._renderer.removeClass(container, "hc-modal-open");
    // Create, attach, and append overlay to container
    /** @type {?} */
    let overlay = this._componentFactory
      .resolveComponentFactory(ModalOverlayComponent)
      .create(modalInjector);
    this._renderer.setStyle(
      overlay.location.nativeElement,
      "z-index",
      this._zIndexCounter
    );
    overlay.instance._ignoreEscapeKey = options.ignoreEscapeKey;
    this._applicationRef.attachView(overlay.hostView);
    container.appendChild(overlay.location.nativeElement);
    modal.overlay = overlay;
    // Create and attach content views; prepare nodes to be
    // transcluded with the window ComponentRef
    /** @type {?} */
    let projectableNodes;
    if (modalContent instanceof TemplateRef) {
      /** @type {?} */
      const embeddedViewRef = modalContent.createEmbeddedView(activeModalRef);
      this._applicationRef.attachView(embeddedViewRef);
      projectableNodes = [embeddedViewRef.rootNodes];
    } else {
      /** @type {?} */
      const componentRef = this._componentFactory
        .resolveComponentFactory(modalContent)
        .create(modalInjector);
      // Set host component style to 100% to allow collapsing of body but not header/footer
      this._renderer.addClass(
        componentRef.location.nativeElement,
        "hc-modal-center-component"
      );
      this._applicationRef.attachView(componentRef.hostView);
      modal.componentRef = /** @type {?} */ (componentRef);
      projectableNodes = [[componentRef.location.nativeElement]];
    }
    // Create, attach, and append Window to container
    // Apply options
    /** @type {?} */
    let window = this._componentFactory
      .resolveComponentFactory(ModalWindowComponent)
      .create(modalInjector, projectableNodes);
    this._renderer.setStyle(
      window.location.nativeElement,
      "z-index",
      this._zIndexCounter + 1
    );
    window.instance._size = /** @type {?} */ (options.size);
    window.instance._ignoreOverlayClick = options.ignoreOverlayClick;
    this._applicationRef.attachView(window.hostView);
    container.appendChild(window.location.nativeElement);
    modal.window = window;
    activeModalRef.close =
      /**
       * @param {?} result
       * @return {?}
       */
      (result) => {
        modal.close(result);
      };
    activeModalRef.dismiss =
      /**
       * @return {?}
       */
      () => modal.dismiss();
    this._modalsOpen++;
    modal._modalClose.subscribe(
      /**
       * @return {?}
       */
      () => {
        this._modalsOpen--;
        modal._modalClose.unsubscribe();
      }
    );
    this._zIndexCounter += 2;
    return modal;
  }
}
ModalService.ɵfac = function ModalService_Factory(t) {
  return new (t || ModalService)(
    ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver),
    ɵngcc0.ɵɵinject(ɵngcc0.Injector),
    ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef),
    ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2)
  );
};
ModalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: ModalService,
  factory: ModalService.ɵfac,
});
/** @nocollapse */
ModalService.ctorParameters = () => [
  { type: ComponentFactoryResolver },
  { type: Injector },
  { type: ApplicationRef },
  { type: RendererFactory2 },
];
if (false) {
  /**
   * Defaults to false. Restricts multiple modals from being opened on top of each other
   * (an error will be thrown if attempted). It's generally considered bad practice to open multiple
   * models at once, so only change this with good reason.
   * @type {?}
   */
  ModalService.prototype.allowMultiple;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._zIndexCounter;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._renderer;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._modalsOpen;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._componentFactory;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._injector;
  /**
   * @type {?}
   * @private
   */
  ModalService.prototype._applicationRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal-header.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalHeaderComponent {
  constructor() {
    this._modalHeaderClass = true;
  }
}
ModalHeaderComponent.ɵfac = function ModalHeaderComponent_Factory(t) {
  return new (t || ModalHeaderComponent)();
};
ModalHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalHeaderComponent,
  selectors: [["hc-modal-header"]],
  hostVars: 2,
  hostBindings: function ModalHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-modal-header", ctx._modalHeaderClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ModalHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
ModalHeaderComponent.propDecorators = {
  _modalHeaderClass: [{ type: HostBinding, args: ["class.hc-modal-header"] }],
};
if (false) {
  /** @type {?} */
  ModalHeaderComponent.prototype._modalHeaderClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal-body.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalBodyComponent {
  constructor() {
    this._modalBodyClass = true;
  }
}
ModalBodyComponent.ɵfac = function ModalBodyComponent_Factory(t) {
  return new (t || ModalBodyComponent)();
};
ModalBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: ModalBodyComponent,
  selectors: [["hc-modal-body"]],
  hostVars: 2,
  hostBindings: function ModalBodyComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-modal-body", ctx._modalBodyClass);
    }
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function ModalBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
ModalBodyComponent.propDecorators = {
  _modalBodyClass: [{ type: HostBinding, args: ["class.hc-modal-body"] }],
};
if (false) {
  /** @type {?} */
  ModalBodyComponent.prototype._modalBodyClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/modal.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalModule {}
ModalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ModalModule });
ModalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ModalModule_Factory(t) {
    return new (t || ModalModule)();
  },
  providers: [ModalService],
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/modal/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/navbar-link/navbar-link.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Primary navigation links
 */
class NavbarLinkComponent {
  /**
   * @param {?} el
   * @param {?} ref
   */
  constructor(el, ref) {
    this.el = el;
    this.ref = ref;
    /**
     * Sets the RouterLinkActive options to match the url exactly to set active state. *Default is false.*
     * See https://angular.io/api/router/RouterLinkActive#description
     */
    this.exact = false;
    this._hidden = false;
  }
  /**
   * Disable visibility of component from view
   * @return {?}
   */
  hide() {
    this._hidden = true;
    this.ref.detectChanges();
  }
  /**
   * Enable visibility of component from view
   * @return {?}
   */
  show() {
    this._hidden = false;
    this.ref.detectChanges();
  }
  /**
   * @return {?}
   */
  _getWidth() {
    return this.el.nativeElement.scrollWidth;
  }
}
NavbarLinkComponent.ɵfac = function NavbarLinkComponent_Factory(t) {
  return new (t || NavbarLinkComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
NavbarLinkComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: NavbarLinkComponent,
  selectors: [["hc-navbar-link"]],
  inputs: {
    exact: "exact",
    active: "active",
    uri: "uri",
    linkText: "linkText",
  },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 1,
  consts: [
    [
      "routerLinkActive",
      "active",
      "class",
      "navbar-link",
      3,
      "title",
      "routerLink",
      "ngClass",
      "routerLinkActiveOptions",
      4,
      "ngIf",
    ],
    [
      "routerLinkActive",
      "active",
      1,
      "navbar-link",
      3,
      "title",
      "routerLink",
      "ngClass",
      "routerLinkActiveOptions",
    ],
  ],
  template: function NavbarLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(0, NavbarLinkComponent_a_0_Template, 3, 10, "a", 0);
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", !ctx._hidden);
    }
  },
  directives: [
    ɵngcc1.NgIf,
    ɵngcc6.RouterLinkWithHref,
    ɵngcc6.RouterLinkActive,
    ɵngcc1.NgClass,
  ],
  encapsulation: 2,
});
/** @nocollapse */
NavbarLinkComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: ChangeDetectorRef },
];
NavbarLinkComponent.propDecorators = {
  active: [{ type: Input }],
  uri: [{ type: Input }],
  linkText: [{ type: Input }],
  exact: [{ type: Input }],
};
if (false) {
  /**
   * (optional) forces active state *Default is `null`.*
   * @type {?}
   */
  NavbarLinkComponent.prototype.active;
  /**
   * RouterLink uri. See https://angular.io/api/router/RouterLink
   * @type {?}
   */
  NavbarLinkComponent.prototype.uri;
  /**
   * The text to display. This can also optionally be the contents within the element
   * @type {?}
   */
  NavbarLinkComponent.prototype.linkText;
  /**
   * Sets the RouterLinkActive options to match the url exactly to set active state. *Default is false.*
   * See https://angular.io/api/router/RouterLinkActive#description
   * @type {?}
   */
  NavbarLinkComponent.prototype.exact;
  /** @type {?} */
  NavbarLinkComponent.prototype._hidden;
  /**
   * @type {?}
   * @private
   */
  NavbarLinkComponent.prototype.el;
  /**
   * @type {?}
   * @private
   */
  NavbarLinkComponent.prototype.ref;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/navbar-mobile-menu/navbar-mobile-menu.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Navigation dropdown for small screen sizes
 */
class NavbarMobileMenuComponent {
  /**
   * @param {?} ref
   */
  constructor(ref) {
    this.ref = ref;
  }
  /**
   * Sets the actual position of the mobile menu to the hight of its self
   * @return {?}
   */
  ngAfterViewInit() {
    this.hide();
    this.ref.detectChanges();
  }
  /**
   * Show the component from view
   * @return {?}
   */
  show() {
    this._yPos = 0;
  }
  /**
   * Hide the component from view
   * @return {?}
   */
  hide() {
    this._yPos = -this.mobileMenu.nativeElement.offsetHeight;
  }
}
NavbarMobileMenuComponent.ɵfac = function NavbarMobileMenuComponent_Factory(t) {
  return new (t || NavbarMobileMenuComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
NavbarMobileMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: NavbarMobileMenuComponent,
  selectors: [["hc-navbar-mobile-menu"]],
  viewQuery: function NavbarMobileMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c40, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.mobileMenu = _t.first);
    }
  },
  ngContentSelectors: _c3,
  decls: 3,
  vars: 2,
  consts: [
    [1, "hc-navbar-mobile-menu-dropdown"],
    ["navbarMobile", ""],
  ],
  template: function NavbarMobileMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵstyleProp("top", ctx._yPos, "px");
    }
  },
  styles: [
    ".hc-navbar-mobile-menu-dropdown{background-color:#262f34;visibility:hidden;margin-top:53px;padding-top:15px;position:fixed;-webkit-transition:top .7s;transition:top .7s;width:100%;z-index:960}@media (max-width:768px){.hc-navbar-mobile-menu-dropdown{display:inline;visibility:visible}}.hc-navbar-mobile-menu-dropdown hr{background-color:#51646f;border:0;height:1px;margin:0 0 0 5%!important}.hc-navbar-mobile-menu-dropdown hc-list a{text-decoration:none}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item{color:#d7dde4;cursor:pointer;display:block;visibility:inherit;padding-left:2%;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item:hover{background-color:#1b2225}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item:focus{outline:0}.hc-navbar-mobile-menu-dropdown hc-list .active-link{background-color:#1b2225;border-left:8px solid #00aeff;color:#fff;font-weight:700}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item.active-link .hc-list-content{padding-left:4px}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
NavbarMobileMenuComponent.ctorParameters = () => [{ type: ChangeDetectorRef }];
NavbarMobileMenuComponent.propDecorators = {
  mobileMenu: [{ type: ViewChild, args: ["navbarMobile", { static: false }] }],
};
if (false) {
  /** @type {?} */
  NavbarMobileMenuComponent.prototype.mobileMenu;
  /**
   * Base value, should be enough to not show
   * @type {?}
   */
  NavbarMobileMenuComponent.prototype._yPos;
  /**
   * @type {?}
   * @private
   */
  NavbarMobileMenuComponent.prototype.ref;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/navbar.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The navbar is a wrapper that positions branding, navigation, and other elements in a concise header.
 */
class NavbarComponent {
  /**
   * @param {?} ref
   */
  constructor(ref) {
    this.ref = ref;
    /**
     * Display name of current user
     */
    this.user = "";
    /**
     * Url to application logo image file
     */
    this.appIcon = "";
    /**
     * Either url to brand icon image file or HcIcon object for a font glyph
     */
    this.brandIcon = "";
    /**
     * Router link triggered when home icon is clicked
     */
    this.homeUri = "";
    /**
     * Fixes the position of navbar to the top of the page. *Default is false.*
     */
    this.fixedTop = false;
    this.unsubscribe$ = new Subject();
    this._menuOpen = false;
    this._linkWidths = [];
    this._linksTotalWidth = 0;
    this._collapse = false;
    this._moreList = [];
  }
  /**
   * @return {?}
   */
  _navResize() {
    if (this._navbarMore) {
      this._navbarMore.closePopover();
    }
    this._moreList = [];
    this._collapse = false;
    // If links is zero the page is smaller than the first responsive breakpoint
    if (this.navbarContent.nativeElement.clientWidth <= 0) {
      return;
    }
    /** @type {?} */
    let linksContainerWidth = this.navContent.nativeElement.offsetWidth;
    /** @type {?} */
    let curLinks = 0;
    // Step through the links until we hit the end of the container, then collapse the
    // remaining into a more menu
    this._navLinks.forEach(
      /**
       * @param {?} t
       * @param {?} i
       * @return {?}
       */
      (t, i) => {
        curLinks += this._linkWidths[i];
        /** @type {?} */
        let moreWidth = this._linksTotalWidth > linksContainerWidth ? 116 : 0;
        if (curLinks + moreWidth < linksContainerWidth) {
          t.show();
          // Reset the parent and positioning of any dropdown popovers that aren't in the More menu
          /** @type {?} */
          const tempDrop = /** @type {?} */ (t);
          if (tempDrop._menuPop) {
            tempDrop._menuPop.horizontalAlign = "start";
            tempDrop._menuPop.verticalAlign = "below";
            tempDrop._menuPop.parent = null;
          }
        } else {
          t.hide();
          this._collapse = true;
          /** @type {?} */
          const tempDrop = /** @type {?} */ (t);
          // Translate any navbar dropdown menus into secondary menus in the More dropdown
          if (tempDrop._menuPop) {
            tempDrop._menuPop.horizontalAlign = "after";
            tempDrop._menuPop.verticalAlign = "start";
            tempDrop._menuPop.parent = this._morePop;
            this._moreList.push({
              name: t.linkText,
              uri: t.uri,
              dropdown: tempDrop._menuPop,
            });
          } else {
            this._moreList.push({ name: t.linkText, uri: t.uri });
          }
        }
      }
    );
    this.ref.detectChanges();
  }
  /**
   * Forces a recalculation of the navbar links to determine how many should be rolling into a More menu.
   * Call this if you've updated the contents of any navbar links.
   * @return {?}
   */
  refreshNavLinks() {
    this._collectNavLinkWidths();
    this._navResize();
  }
  /**
   * @private
   * @return {?}
   */
  _collectNavLinkWidths() {
    this._linkWidths = [];
    this._linksTotalWidth = 0;
    this._navLinks.forEach(
      /**
       * @param {?} t
       * @return {?}
       */
      (t) => {
        /** @type {?} */
        const isHidden = t._hidden;
        t.show();
        this._linksTotalWidth += t._getWidth();
        this._linkWidths.push(t._getWidth());
        if (isHidden) {
          t.hide();
        }
      }
    );
  }
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    setTimeout(
      /**
       * @return {?}
       */
      () => {
        this.refreshNavLinks();
      },
      100
    );
    // If links are added dynamically, recheck the navbar link sizing
    this._navLinks.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(
      /**
       * @return {?}
       */
      () => this.refreshNavLinks()
    );
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  /**
   * @return {?}
   */
  _toggleMobileMenu() {
    if (this._menuOpen) {
      this._mobileMenu.first.hide();
      this._menuOpen = false;
    } else {
      this._mobileMenu.first.show();
      this._menuOpen = true;
    }
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _menuClick(event) {
    /** @type {?} */
    let clickTarget = event.target.outerHTML;
    // Verify that the click in the mobile menu came from a navigation item
    if (
      clickTarget.indexOf("hclistline") >= 0 &&
      clickTarget.indexOf("menu-dropdown") === -1
    ) {
      this._toggleMobileMenu();
    }
  }
  /**
   * @return {?}
   */
  get _mobileMenuIcon() {
    return this._menuOpen ? "fa-times" : "fa-bars";
  }
  /**
   * @return {?}
   */
  _moreClick() {
    if (this._navbarMore) {
      this._navbarMore.closePopover();
    }
  }
  /**
   * @return {?}
   */
  _brandIconType() {
    return typeof this.brandIcon;
  }
  /**
   * @return {?}
   */
  _brandIconSet() {
    if (this.brandIcon && typeof this.brandIcon !== "string") {
      return this.brandIcon.fontSet;
    } else {
      return "";
    }
  }
  /**
   * @return {?}
   */
  _brandIconGlyph() {
    if (this.brandIcon && typeof this.brandIcon !== "string") {
      return this.brandIcon.fontIcon;
    } else {
      return "";
    }
  }
  /**
   * @return {?}
   */
  _brandIconSize() {
    if (
      this.brandIcon &&
      typeof this.brandIcon !== "string" &&
      this.brandIcon.fontSize
    ) {
      return this.brandIcon.fontSize + "px";
    }
    return "37px";
  }
}
NavbarComponent.ɵfac = function NavbarComponent_Factory(t) {
  return new (t || NavbarComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
NavbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: NavbarComponent,
  selectors: [["hc-navbar"]],
  contentQueries: function NavbarComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, NavbarMobileMenuComponent, false);
      ɵngcc0.ɵɵcontentQuery(dirIndex, NavbarLinkComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._mobileMenu = _t);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._navLinks = _t);
    }
  },
  viewQuery: function NavbarComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c41, true);
      ɵngcc0.ɵɵviewQuery(_c42, true);
      ɵngcc0.ɵɵviewQuery(_c43, true);
      ɵngcc0.ɵɵviewQuery(_c44, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.navbarContent = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.navContent = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._navbarMore = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._morePop = _t.first);
    }
  },
  hostBindings: function NavbarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "resize",
        function NavbarComponent_resize_HostBindingHandler() {
          return ctx._navResize();
        },
        false,
        ɵngcc0.ɵɵresolveWindow
      );
    }
  },
  inputs: {
    user: "user",
    appIcon: "appIcon",
    brandIcon: "brandIcon",
    homeUri: "homeUri",
    fixedTop: "fixedTop",
  },
  ngContentSelectors: _c48,
  decls: 22,
  vars: 12,
  consts: [
    [1, "hc-navbar", 3, "ngClass"],
    ["navbar", ""],
    [1, "navbar-brand"],
    ["tabIndex", "-1", 1, "brand", 3, "routerLink"],
    [3, "src", 4, "ngIf"],
    [3, "fontSet", "fontIcon", "ngStyle", 4, "ngIf"],
    [1, "navbar-app"],
    ["class", "app", 3, "routerLink", 4, "ngIf"],
    [1, "hc-navbar-link-container"],
    ["navlinks", ""],
    [
      "class",
      "hc-navbar-more-links",
      "tabindex",
      "0",
      "title",
      "More",
      3,
      "hcPop",
      4,
      "ngIf",
    ],
    [1, "hc-navbar-right-container"],
    ["rightcontainer", ""],
    ["class", "hc-navbar-mobile-menu", 3, "click", 4, "ngIf"],
    [3, "click"],
    ["horizontalAlign", "end", 3, "autoCloseOnContentClick", "showArrow"],
    ["navbarMore", ""],
    ["hcMenu", ""],
    [4, "ngFor", "ngForOf"],
    [3, "src"],
    [3, "fontSet", "fontIcon", "ngStyle"],
    [1, "app", 3, "routerLink"],
    ["tabindex", "0", "title", "More", 1, "hc-navbar-more-links", 3, "hcPop"],
    ["moreLink", "hcPopAnchor"],
    ["fontSet", "fa", "fontIcon", "fa-chevron-down", "hcIconSm", ""],
    [1, "hc-navbar-mobile-menu", 3, "click"],
    ["fontSet", "fa", "hcIconMd", "", 3, "fontIcon"],
    [4, "ngIf"],
    ["hcMenuItem", "", "hcDivider", "", 4, "ngIf"],
    ["hcMenuItem", "", "routerLinkActive", "active", 3, "routerLink", "click"],
    ["hcMenuText", ""],
    ["hcMenuItem", "", 3, "hcPop"],
    ["hcMenuItem", "", "hcDivider", ""],
  ],
  template: function NavbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c46);
      ɵngcc0.ɵɵelementStart(0, "nav", 0, 1);
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵelementStart(3, "a", 3);
      ɵngcc0.ɵɵtemplate(4, NavbarComponent_img_4_Template, 1, 1, "img", 4);
      ɵngcc0.ɵɵtemplate(
        5,
        NavbarComponent_hc_icon_5_Template,
        1,
        6,
        "hc-icon",
        5
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(6, "div", 6);
      ɵngcc0.ɵɵtemplate(7, NavbarComponent_a_7_Template, 2, 2, "a", 7);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(8, "div", 8, 9);
      ɵngcc0.ɵɵprojection(10);
      ɵngcc0.ɵɵtemplate(11, NavbarComponent_div_11_Template, 4, 1, "div", 10);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(12, "div", 11, 12);
      ɵngcc0.ɵɵprojection(14, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(15, NavbarComponent_div_15_Template, 2, 1, "div", 13);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(16, "div", 14);
      ɵngcc0.ɵɵlistener(
        "click",
        function NavbarComponent_Template_div_click_16_listener($event) {
          return ctx._menuClick($event);
        }
      );
      ɵngcc0.ɵɵprojection(17, 2);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(18, "hc-pop", 15, 16);
      ɵngcc0.ɵɵelementStart(20, "div", 17);
      ɵngcc0.ɵɵtemplate(
        21,
        NavbarComponent_ng_container_21_Template,
        4,
        3,
        "ng-container",
        18
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(10, _c47, ctx.fixedTop)
      );
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("routerLink", ctx.homeUri);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._brandIconType() == "string");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._brandIconType() != "string");
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("ngIf", ctx.appIcon);
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("ngIf", ctx._collapse);
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("ngIf", ctx._mobileMenu.first);
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("autoCloseOnContentClick", true)("showArrow", false);
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngForOf", ctx._moreList);
    }
  },
  directives: [
    ɵngcc1.NgClass,
    ɵngcc6.RouterLinkWithHref,
    ɵngcc1.NgIf,
    HcPopComponent,
    MenuDirective,
    ɵngcc1.NgForOf,
    IconComponent,
    ɵngcc1.NgStyle,
    HcPopoverAnchorDirective,
    HcIconSmallDirective,
    HcIconMediumDirective,
    MenuItemDirective,
    ɵngcc6.RouterLinkActive,
    MenuTextDirective,
    DividerDirective,
  ],
  styles: [
    '.hc-navbar{height:53px;background-color:#384655;display:-webkit-box;display:flex;font-size:15px;line-height:1}.hc-navbar.fixed-top{top:0;position:fixed;right:0;left:0;z-index:970;box-shadow:0 2px 6px rgba(0,0,0,.15)}.hc-navbar .navbar-brand{background-color:#00aeff;flex-basis:auto;height:100%;width:55px;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center}.hc-navbar .navbar-brand .brand{-webkit-transition:background-color .25s;transition:background-color .25s;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center;height:100%;cursor:default;min-width:55px}.hc-navbar .navbar-brand .brand>img{height:37px;width:100%}.hc-navbar .navbar-brand .brand>hc-icon{width:100%;color:#fff}.hc-navbar .navbar-app{height:100%}.hc-navbar .navbar-app a{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;padding-left:25px;padding-right:50px;height:100%}.hc-navbar .navbar-app a img{height:30px;width:auto;padding-top:2px}.hc-navbar .navbar-app a:focus{outline-offset:-8px}@media (max-width:576px){.hc-navbar .navbar-brand{display:none}.hc-navbar .navbar-app{padding:0 0 0 5%}}.hc-navbar .hc-navbar-link-container{display:-webkit-box;display:flex;list-style-type:none;margin:0;padding:0;overflow:hidden;width:100%}@media (max-width:768px){.hc-navbar .hc-navbar-link-container{display:none}}.hc-navbar .navbar-link{display:inline-block;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;white-space:nowrap;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s;outline:0}.hc-navbar .navbar-link.inactive:hover,.hc-navbar .navbar-link:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .navbar-link:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .navbar-link.active:not(.inactive),.hc-navbar .navbar-link:active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .navbar-link:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .navbar-dropdown{display:inline-block;white-space:nowrap;cursor:pointer;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar .navbar-dropdown hc-icon{margin-left:5px;vertical-align:top;margin-top:1px;margin-right:-10px;font-size:13px!important}.hc-navbar .navbar-dropdown.inactive:hover,.hc-navbar .navbar-dropdown:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .navbar-dropdown:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .navbar-dropdown.active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .navbar-dropdown:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .hc-navbar-right-container{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;-webkit-box-align:center;align-items:center;position:relative;margin-left:auto}@media (max-width:768px){.hc-navbar .hc-navbar-right-container{display:none}}.hc-navbar .hc-navbar-icon{height:53px;color:#fff;cursor:pointer;-webkit-transition:background-color .25s;transition:background-color .25s;min-width:53px!important;padding:18px 0}.hc-navbar .hc-navbar-icon.inactive:hover,.hc-navbar .hc-navbar-icon:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-icon:focus{outline:0;background-color:#28323c}.hc-navbar .hc-navbar-username{height:53px;color:#fff;cursor:pointer;-webkit-transition:background-color .25s;transition:background-color .25s;padding:2px 15px 0;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;white-space:nowrap}.hc-navbar .hc-navbar-username.inactive:hover,.hc-navbar .hc-navbar-username:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-username:focus{outline:0;background-color:#28323c}.hc-navbar .hc-navbar-username>hc-icon{font-size:12pt;padding-top:2px}.hc-navbar .hc-navbar-username-subtext{color:#c0c5cc}.hc-navbar .hc-navbar-vertical-separator{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-navbar .hc-navbar-vertical-separator::after{content:"|";font-size:18px;color:#fff}.hc-navbar .hc-navbar-more-links{display:inline-block;white-space:nowrap;cursor:pointer;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar .hc-navbar-more-links hc-icon{margin-left:5px;vertical-align:top;margin-top:1px;margin-right:-10px;font-size:13px!important}.hc-navbar .hc-navbar-more-links.inactive:hover,.hc-navbar .hc-navbar-more-links:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-more-links:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .hc-navbar-more-links.active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .hc-navbar-more-links:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .hc-navbar-mobile-menu{background-color:#262f34;color:#d7dde4;width:55px;flex-basis:auto;height:100%;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center;margin-left:auto;cursor:pointer;display:none}.hc-navbar .hc-navbar-mobile-menu hc-icon{font-size:25px!important;height:25px!important;width:25px!important}@media (max-width:768px){.hc-navbar .hc-navbar-mobile-menu{display:-webkit-box;display:flex}}',
  ],
  encapsulation: 2,
});
/** @nocollapse */
NavbarComponent.ctorParameters = () => [{ type: ChangeDetectorRef }];
NavbarComponent.propDecorators = {
  user: [{ type: Input }],
  appIcon: [{ type: Input }],
  brandIcon: [{ type: Input }],
  homeUri: [{ type: Input }],
  fixedTop: [{ type: Input }],
  _mobileMenu: [{ type: ContentChildren, args: [NavbarMobileMenuComponent] }],
  _navLinks: [{ type: ContentChildren, args: [NavbarLinkComponent] }],
  navbarContent: [{ type: ViewChild, args: ["navbar", { static: false }] }],
  navContent: [{ type: ViewChild, args: ["navlinks", { static: false }] }],
  _navbarMore: [{ type: ViewChild, args: ["moreLink", { static: false }] }],
  _morePop: [{ type: ViewChild, args: ["navbarMore", { static: false }] }],
  _navResize: [{ type: HostListener, args: ["window:resize"] }],
};
if (false) {
  /**
   * Display name of current user
   * @type {?}
   */
  NavbarComponent.prototype.user;
  /**
   * Url to application logo image file
   * @type {?}
   */
  NavbarComponent.prototype.appIcon;
  /**
   * Either url to brand icon image file or HcIcon object for a font glyph
   * @type {?}
   */
  NavbarComponent.prototype.brandIcon;
  /**
   * Router link triggered when home icon is clicked
   * @type {?}
   */
  NavbarComponent.prototype.homeUri;
  /**
   * Fixes the position of navbar to the top of the page. *Default is false.*
   * @type {?}
   */
  NavbarComponent.prototype.fixedTop;
  /** @type {?} */
  NavbarComponent.prototype._mobileMenu;
  /** @type {?} */
  NavbarComponent.prototype._navLinks;
  /** @type {?} */
  NavbarComponent.prototype.navbarContent;
  /** @type {?} */
  NavbarComponent.prototype.navContent;
  /** @type {?} */
  NavbarComponent.prototype._navbarMore;
  /** @type {?} */
  NavbarComponent.prototype._morePop;
  /**
   * @type {?}
   * @private
   */
  NavbarComponent.prototype.unsubscribe$;
  /**
   * @type {?}
   * @private
   */
  NavbarComponent.prototype._menuOpen;
  /**
   * @type {?}
   * @private
   */
  NavbarComponent.prototype._linkWidths;
  /**
   * @type {?}
   * @private
   */
  NavbarComponent.prototype._linksTotalWidth;
  /** @type {?} */
  NavbarComponent.prototype._collapse;
  /** @type {?} */
  NavbarComponent.prototype._moreList;
  /**
   * @type {?}
   * @private
   */
  NavbarComponent.prototype.ref;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/navbar-dropdown/navbar-dropdown.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A dropdown menu in a `hc-navbar`
 */
class NavbarDropdownComponent extends NavbarLinkComponent {
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    // Update the popover's reference to menu items included in this component's content
    this._menuPop._menuItems = this._menuItems;
  }
}
NavbarDropdownComponent.ɵfac = function NavbarDropdownComponent_Factory(t) {
  return ɵNavbarDropdownComponent_BaseFactory(t || NavbarDropdownComponent);
};
NavbarDropdownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: NavbarDropdownComponent,
  selectors: [["hc-navbar-dropdown"]],
  contentQueries: function NavbarDropdownComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, MenuItemDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._menuItems = _t);
    }
  },
  viewQuery: function NavbarDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c49, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._menuPop = _t.first);
    }
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: NavbarLinkComponent,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => NavbarDropdownComponent
        ),
      },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  ngContentSelectors: _c3,
  decls: 4,
  vars: 3,
  consts: [
    [
      "routerLinkActive",
      "active",
      "class",
      "navbar-dropdown",
      "tabindex",
      "0",
      3,
      "title",
      "ngClass",
      "hcPop",
      4,
      "ngIf",
    ],
    [3, "autoCloseOnContentClick", "showArrow"],
    ["menuPop", ""],
    [
      "routerLinkActive",
      "active",
      "tabindex",
      "0",
      1,
      "navbar-dropdown",
      3,
      "title",
      "ngClass",
      "hcPop",
    ],
    ["fontSet", "fa", "fontIcon", "fa-chevron-down", "hcIconSm", ""],
  ],
  template: function NavbarDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(0, NavbarDropdownComponent_a_0_Template, 3, 7, "a", 0);
      ɵngcc0.ɵɵelementStart(1, "hc-pop", 1, 2);
      ɵngcc0.ɵɵprojection(3);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", !ctx._hidden);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("autoCloseOnContentClick", true)("showArrow", false);
    }
  },
  directives: [
    ɵngcc1.NgIf,
    HcPopComponent,
    ɵngcc6.RouterLinkActive,
    ɵngcc1.NgClass,
    HcPopoverAnchorDirective,
    IconComponent,
    HcIconSmallDirective,
  ],
  encapsulation: 2,
});
NavbarDropdownComponent.propDecorators = {
  _menuPop: [{ type: ViewChild, args: ["menuPop", { static: false }] }],
  _menuItems: [
    { type: ContentChildren, args: [MenuItemDirective, { descendants: true }] },
  ],
};
if (false) {
  /** @type {?} */
  NavbarDropdownComponent.prototype._menuPop;
  /**
   * Reference to hcMenuItems (if the content contains them)
   * @type {?}
   */
  NavbarDropdownComponent.prototype._menuItems;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/navbar.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavbarModule {}
NavbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NavbarModule });
NavbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function NavbarModule_Factory(t) {
    return new (t || NavbarModule)();
  },
  imports: [[CommonModule, RouterModule, IconModule, PopModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/navbar/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/shared/initializable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract class for common initialization functionality
 * @abstract
 */
class Initializable {
  constructor() {
    /**
     * Whether this directive has been marked as initialized.
     */
    this._isInitialized = false;
    /**
     * List of subscribers that subscribed before the directive was initialized. Should be notified
     * during _markInitialized. Set to null after pending subscribers are notified, and should
     * not expect to be populated after.
     */
    this._pendingSubscribers = [];
    /**
     * Observable stream that emits when the directive initializes. If already initialized, the
     * subscriber is stored to be notified once _markInitialized is called.
     * \@docs-private
     */
    this.initialized = new Observable(
      /**
       * @param {?} subscriber
       * @return {?}
       */ (subscriber) => {
        // If initialized, immediately notify the subscriber. Otherwise store the subscriber to notify
        // when _markInitialized is called.
        if (this._isInitialized) {
          this._notifySubscriber(subscriber);
        } else {
          /** @type {?} */ (this._pendingSubscribers).push(subscriber);
        }
      }
    );
  }
  /**
   * Marks the state as initialized and notifies pending subscribers. Should be called at the end
   * of ngOnInit.
   * \@docs-private
   * @return {?}
   */
  _markInitialized() {
    if (this._isInitialized) {
      throw Error(
        "This directive has already been marked as initialized and should not be called twice."
      );
    }
    this._isInitialized = true;
    /** @type {?} */ (this._pendingSubscribers).forEach(this._notifySubscriber);
    this._pendingSubscribers = null;
  }
  /**
   * Emits and completes the subscriber stream (should only emit once).
   * @param {?} subscriber
   * @return {?}
   */
  _notifySubscriber(subscriber) {
    subscriber.next();
    subscriber.complete();
  }
}
Initializable.ɵfac = function Initializable_Factory(t) {
  return new (t || Initializable)();
};
Initializable.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Initializable });
if (false) {
  /**
   * Whether this directive has been marked as initialized.
   * @type {?}
   */
  Initializable.prototype._isInitialized;
  /**
   * List of subscribers that subscribed before the directive was initialized. Should be notified
   * during _markInitialized. Set to null after pending subscribers are notified, and should
   * not expect to be populated after.
   * @type {?}
   */
  Initializable.prototype._pendingSubscribers;
  /**
   * Observable stream that emits when the directive initializes. If already initialized, the
   * subscriber is stored to be notified once _markInitialized is called.
   * \@docs-private
   * @type {?}
   */
  Initializable.prototype.initialized;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/base-pagination.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Base Pagination class for shared functionality
 *
 */
class BasePaginationComponent extends Initializable {
  constructor() {
    super(...arguments);
    this._inputCheckTimeoutSet = false;
    this._length = 0;
    this._pageNumber = 1;
    this._pageSize = BasePaginationComponent._DEFAULT_PAGE_SIZE;
    /**
     * Event emitted when the paginator changes the page size or page index.
     */
    this.page = new EventEmitter();
    /**
     * Emits the new page number when the page number changes.
     */
    this.pageNumberChange = new EventEmitter();
    /**
     * Emits the new page size when the page size changes.
     */
    this.pageSizeChange = new EventEmitter();
  }
  /**
   * The total number of items to be paged through
   * @return {?}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set length(value) {
    this._length = coerceNumberProperty(value);
    this.ensureInputCheckTimeoutSet();
  }
  /**
   * The currently displayed page. *Defaults to 1.*
   * @return {?}
   */
  get pageNumber() {
    return this._pageNumber;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set pageNumber(value) {
    this._pageNumber = coerceNumberProperty(value);
    this.ensureInputCheckTimeoutSet();
  }
  /**
   * Number of items to display on a page. *Defaults to 20.*
   * @return {?}
   */
  get pageSize() {
    return this._pageSize;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set pageSize(value) {
    this._pageSize = coerceNumberProperty(value);
    this._pageSizeUpdated();
    this.ensureInputCheckTimeoutSet();
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this._markInitialized();
  }
  /**
   * @private
   * @return {?}
   */
  ensureInputCheckTimeoutSet() {
    if (this._inputCheckTimeoutSet) {
      return;
    }
    this._inputCheckTimeoutSet = true;
    setTimeout(
      /**
       * @return {?}
       */
      () => {
        this._pageNumber = this._sanitizePageNumber(this._pageNumber);
        /** @type {?} */
        const hasPageNumberChanges = this.shouldEmitPageNumberChangeEvent();
        /** @type {?} */
        const hasPageSizeChanges = this.shouldEmitPageSizeChangeEvent();
        if (hasPageNumberChanges) {
          this.pageNumberChange.emit(this._pageNumber);
        }
        if (hasPageSizeChanges) {
          this.pageSizeChange.emit(this.pageSize);
        }
        if (hasPageNumberChanges || hasPageSizeChanges) {
          this._emitPageEvent(/** @type {?} */ (this._prevPageNumber));
        }
        this._prevPageNumber = this._pageNumber;
        this._prevPageSize = this._pageSize;
        this._inputCheckTimeoutSet = false;
      }
    );
  }
  /**
   * @private
   * @return {?}
   */
  shouldEmitPageNumberChangeEvent() {
    /** @type {?} */
    const firstPageNumberToBeSet = this._prevPageNumber === undefined;
    /** @type {?} */
    const pageNumberHasChanged = this._prevPageNumber !== this._pageNumber;
    return !firstPageNumberToBeSet && pageNumberHasChanged;
  }
  /**
   * @private
   * @return {?}
   */
  shouldEmitPageSizeChangeEvent() {
    /** @type {?} */
    const firstPageSizeToBeSet = this._prevPageSize === undefined;
    /** @type {?} */
    const pageSizeHasChanged = this._prevPageSize !== this._pageSize;
    return !firstPageSizeToBeSet && pageSizeHasChanged;
  }
  /**
   * The computed total number of pages
   * @return {?}
   */
  get totalPages() {
    return Math.ceil(this._length / this._pageSize);
  }
  /**
   * @return {?}
   */
  get _isFirstPage() {
    return this._pageNumber === 1;
  }
  /**
   * @return {?}
   */
  get _isLastPage() {
    return !!(this.totalPages && this._pageNumber === this.totalPages);
  }
  /**
   * Changes the page size so that the first item displayed on the page will still be
   * displayed using the new page size.
   *
   * For example, if the page size is 10 and on the second page (items indexed 11-20) then
   * switching so that the page size is 5 will set the third page as the current page so
   * that the 11th item will still be displayed.
   * @param {?} pageSize
   * @return {?}
   */
  _changePageSize(pageSize) {
    // Current page needs to be updated to reflect the new page size. Navigate to the page
    // containing the previous page's first item.
    /** @type {?} */
    const startIndex = (this.pageNumber - 1) * this.pageSize;
    this.pageSize = pageSize;
    this.pageNumber = Math.ceil(startIndex / pageSize) + 1;
  }
  /**
   * @return {?}
   */
  _pageSizeUpdated() {}
  /**
   * @private
   * @param {?} pageNumber
   * @return {?}
   */
  _sanitizePageNumber(pageNumber) {
    /** @type {?} */
    const positivePageNumber = Math.max(pageNumber, 1);
    /** @type {?} */
    const upperBound = Math.max(this.totalPages, 1);
    return positivePageNumber > upperBound ? upperBound : positivePageNumber;
  }
  /**
   * @private
   * @param {?} previousPageNumber
   * @return {?}
   */
  _emitPageEvent(previousPageNumber) {
    this.page.emit({
      previousPageNumber,
      pageNumber: this.pageNumber,
      pageSize: this.pageSize,
      length: this.length,
    });
  }
}
BasePaginationComponent.ɵfac = function BasePaginationComponent_Factory(t) {
  return ɵBasePaginationComponent_BaseFactory(t || BasePaginationComponent);
};
BasePaginationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: BasePaginationComponent,
  selectors: [["ng-component"]],
  inputs: { length: "length", pageNumber: "pageNumber", pageSize: "pageSize" },
  outputs: {
    page: "page",
    pageNumberChange: "pageNumberChange",
    pageSizeChange: "pageSizeChange",
  },
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function BasePaginationComponent_Template(rf, ctx) {},
  encapsulation: 2,
});
BasePaginationComponent._DEFAULT_PAGE_SIZE = 20;
BasePaginationComponent.propDecorators = {
  length: [{ type: Input }],
  pageNumber: [{ type: Input }],
  pageSize: [{ type: Input }],
  page: [{ type: Output }],
  pageNumberChange: [{ type: Output }],
  pageSizeChange: [{ type: Output }],
};
if (false) {
  /** @type {?} */
  BasePaginationComponent._DEFAULT_PAGE_SIZE;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._inputCheckTimeoutSet;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._length;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._prevPageNumber;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._pageNumber;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._prevPageSize;
  /**
   * @type {?}
   * @private
   */
  BasePaginationComponent.prototype._pageSize;
  /**
   * Event emitted when the paginator changes the page size or page index.
   * @type {?}
   */
  BasePaginationComponent.prototype.page;
  /**
   * Emits the new page number when the page number changes.
   * @type {?}
   */
  BasePaginationComponent.prototype.pageNumberChange;
  /**
   * Emits the new page size when the page size changes.
   * @type {?}
   */
  BasePaginationComponent.prototype.pageSizeChange;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/pagination.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The pagination control enables the user to navigate across paged content.
 * Although commonly used with tables and data grids, this control may be used any place where paged data is used.
 * \@inheritdoc
 *
 */
class PaginationComponent extends BasePaginationComponent {
  constructor() {
    super(...arguments);
    this._pageSizeOptions = [10, 20, 50];
    this.isFocused = false;
    /**
     * Displayed set of page size options. Will be sorted and include current page size.
     */
    this._displayedPageSizeOptions = [];
    /**
     * Sets the controller to a specific width type - `lg`, `md`, or `sm`. Typically adjusted in a window
     * resize listener for responsive layouts. *Defaults to lg.*
     */
    this.displayWidth = "lg";
    this._hidePageSize = false;
  }
  /**
   * The set of provided page size options to display to the user. *Defaults to [10, 20, 50].*
   * @return {?}
   */
  get pageSizeOptions() {
    return this._pageSizeOptions;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set pageSizeOptions(value) {
    this._pageSizeOptions = (value || []).map(
      /**
       * @param {?} p
       * @return {?}
       */
      (p) => coerceNumberProperty(p)
    );
    this._updateDisplayedPageSizeOptions();
  }
  /**
   * Whether to hide the page size selection UI from the user. *Defaults to false.*
   * @return {?}
   */
  get hidePageSize() {
    return this._hidePageSize;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set hidePageSize(value) {
    this._hidePageSize = !!value;
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this._updateDisplayedPageSizeOptions();
    super.ngOnInit();
  }
  /**
   * @return {?}
   */
  get _visiblePages() {
    /*
     * if there aren't any pages, don't display any
     */
    if (!this.totalPages) {
      return [];
    }
    /*
     * if there are less than nine pages, display them all
     */
    if (this.totalPages <= 9) {
      /** @type {?} */
      const visiblePages = [];
      for (let i = 1; i <= this.totalPages; i++) {
        visiblePages.push(i);
      }
      return visiblePages;
    }
    /*
     * There should always be exactly nine elements in the paging control.
     * Let n = total pages, p = current page, ... are non-clickable ellipses
     * If the current page number is less than 6, display 1, 2, 3, 4, 5, 6, ..., n-1, n
     * If the current page number within is within 4 of the max, display 1, 2, ..., n-5, n-4, n-3, n-2, n-1, n
     * Otherwise, display 1, 2, ..., p-1, p, p+1, ..., n-1, n
     */
    /** @type {?} */
    const n = this.totalPages;
    /** @type {?} */
    const p = this.pageNumber || 1;
    if (p < 6) {
      return [1, 2, 3, 4, 5, 6, null, n - 1, n];
    } else if (p >= n - 4) {
      return [1, 2, null, n - 5, n - 4, n - 3, n - 2, n - 1, n];
    } else {
      return [1, 2, null, p - 1, p, p + 1, null, n - 1, n];
    }
  }
  /**
   * @return {?}
   */
  get _collapsedVisiblePages() {
    /*
     * if there aren't any pages, don't display any
     */
    if (!this.totalPages) {
      return [];
    }
    /*
     * if there are less than five pages, display them all
     */
    if (this.totalPages <= 5) {
      /** @type {?} */
      const visiblePages = [];
      for (let i = 1; i <= this.totalPages; i++) {
        visiblePages.push(i);
      }
      return visiblePages;
    }
    /*
     * There should always be exactly five elements in the paging control when collapsed.
     * Let n = total pages, p = current page, ... are non-clickable ellipses
     * If the current page number is less than 4, display 1, 2, 3, ..., n
     * If the current page number within is within 2 of the max, display 1, ..., n-2, n-1, n
     * Otherwise, display 1, ..., p, ..., n
     */
    /** @type {?} */
    const n = this.totalPages;
    /** @type {?} */
    const p = this.pageNumber || 1;
    if (p < 4) {
      return [1, 2, 3, null, n];
    } else if (p >= n - 2) {
      return [1, null, n - 2, n - 1, n];
    } else {
      return [1, null, p, null, n];
    }
  }
  /**
   * @return {?}
   */
  _pageSizeUpdated() {
    this._updateDisplayedPageSizeOptions();
  }
  /**
   * @return {?}
   */
  _previousPage() {
    if (this._isFirstPage) {
      return;
    }
    this._goToPage((this.pageNumber || 1) - 1);
  }
  /**
   * @param {?} pageNum
   * @return {?}
   */
  _goToPage(pageNum) {
    this.pageNumber = pageNum;
  }
  /**
   * @return {?}
   */
  _nextPage() {
    if (this._isLastPage) {
      return;
    }
    this._goToPage((this.pageNumber || 1) + 1);
  }
  /**
   * Changes the page size so that the first item displayed on the page will still be
   * displayed using the new page size.
   *
   * For example, if the page size is 10 and on the second page (items indexed 11-20) then
   * switching so that the page size is 5 will set the third page as the current page so
   * that the 11th item will still be displayed.
   * @param {?} pageSize
   * @return {?}
   */
  _changePageSize(pageSize) {
    // Current page needs to be updated to reflect the new page size. Navigate to the page
    // containing the previous page's first item.
    /** @type {?} */
    const startIndex = (this.pageNumber - 1) * this.pageSize + 1;
    this.pageSize = pageSize;
    this.pageNumber = Math.ceil(startIndex / pageSize) || 1;
  }
  /**
   * Updates the list of page size options to display to the user. Includes making sure that
   * the page size is an option and that the list is sorted.
   * @private
   * @return {?}
   */
  _updateDisplayedPageSizeOptions() {
    // If no page size is provided, use the first page size option or the default page size.
    if (!this.pageSize) {
      this.pageSize =
        this.pageSizeOptions.length !== 0
          ? this.pageSizeOptions[0]
          : BasePaginationComponent._DEFAULT_PAGE_SIZE;
    }
    this._displayedPageSizeOptions = this.pageSizeOptions.slice();
    if (this._displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
      this._displayedPageSizeOptions.push(this.pageSize);
    }
    // Sort the numbers using a number-specific sort function.
    this._displayedPageSizeOptions.sort(
      /**
       * @param {?} a
       * @param {?} b
       * @return {?}
       */
      (a, b) => a - b
    );
  }
}
PaginationComponent.ɵfac = function PaginationComponent_Factory(t) {
  return ɵPaginationComponent_BaseFactory(t || PaginationComponent);
};
PaginationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: PaginationComponent,
  selectors: [["hc-pagination"]],
  inputs: {
    displayWidth: "displayWidth",
    pageSizeOptions: "pageSizeOptions",
    hidePageSize: "hidePageSize",
  },
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  decls: 13,
  vars: 5,
  consts: [
    [1, "hc-pagination-container"],
    ["class", "hc-font-sm hc-page-detail-container", 4, "ngIf"],
    [1, "hc-page-btns-container"],
    [
      "hc-button",
      "",
      "color",
      "secondary",
      1,
      "hc-page-button",
      "hc-page-left-button",
      3,
      "disabled",
      "click",
    ],
    [1, "hc-page-button-chevron", "hc-page-button-chevron-left"],
    [4, "ngIf"],
    [
      "hc-button",
      "",
      "color",
      "secondary",
      1,
      "hc-page-button",
      "hc-page-right-button",
      3,
      "disabled",
      "click",
    ],
    [1, "hc-page-button-chevron"],
    [1, "hc-font-sm", "hc-page-detail-container"],
    [1, "hc-page-detail-label"],
    [1, "hc-page-detail-select", 3, "value", "change", "focus", "blur"],
    [3, "value", 4, "ngFor", "ngForOf"],
    [1, "hc-page-detail-entries"],
    [3, "value"],
    [
      "hc-button",
      "",
      "color",
      "secondary",
      "class",
      "hc-page-button hc-page-inner-button",
      3,
      "disabled",
      "hc-page-button-current",
      "click",
      4,
      "ngFor",
      "ngForOf",
    ],
    [
      "hc-button",
      "",
      "color",
      "secondary",
      1,
      "hc-page-button",
      "hc-page-inner-button",
      3,
      "disabled",
      "click",
    ],
    ["class", "hc-page-button-ellipsis", 4, "ngIf"],
    [1, "hc-page-button-ellipsis"],
  ],
  template: function PaginationComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵtemplate(1, PaginationComponent_div_1_Template, 10, 3, "div", 1);
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵelementStart(3, "button", 3);
      ɵngcc0.ɵɵlistener(
        "click",
        function PaginationComponent_Template_button_click_3_listener() {
          return ctx._previousPage();
        }
      );
      ɵngcc0.ɵɵelement(4, "span", 4);
      ɵngcc0.ɵɵelementStart(5, "span");
      ɵngcc0.ɵɵtext(6, "PREV");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(
        7,
        PaginationComponent_ng_container_7_Template,
        2,
        1,
        "ng-container",
        5
      );
      ɵngcc0.ɵɵtemplate(
        8,
        PaginationComponent_ng_container_8_Template,
        2,
        1,
        "ng-container",
        5
      );
      ɵngcc0.ɵɵelementStart(9, "button", 6);
      ɵngcc0.ɵɵlistener(
        "click",
        function PaginationComponent_Template_button_click_9_listener() {
          return ctx._nextPage();
        }
      );
      ɵngcc0.ɵɵelementStart(10, "span");
      ɵngcc0.ɵɵtext(11, "NEXT");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(12, "span", 7);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", !ctx.hidePageSize);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("disabled", !ctx.totalPages || ctx._isFirstPage);
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("ngIf", ctx.displayWidth === "lg");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx.displayWidth === "md");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("disabled", !ctx.totalPages || ctx._isLastPage);
    }
  },
  directives: [ɵngcc1.NgIf, ButtonComponent, SelectComponent, ɵngcc1.NgForOf],
  styles: [
    ".hc-pagination-container{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;flex-wrap:wrap;-webkit-box-pack:justify;justify-content:space-between;margin-top:15px;width:100%}.hc-page-detail-container{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;margin-right:10px;padding:5px 0}.hc-page-detail-label{color:#6d6e70;-webkit-box-flex:0;flex:0 0 auto}.hc-page-detail-select{-webkit-box-flex:1;flex:1 0 65px;margin:0 7px}.hc-page-detail-entries{white-space:nowrap}.hc-range-label{-webkit-box-flex:0;flex:0 0 auto;margin-right:10px;padding:12px 0}.hc-page-btns-container{display:-webkit-inline-box;display:inline-flex;padding:5px 0}.hc-pagination-container .hc-page-btns-container .hc-page-button{background-color:#fff;border:2px solid #e0e0e0;color:#00aeff;font-weight:700;margin-right:0;min-width:40px}.hc-pagination-container .hc-page-btns-container .hc-page-button:hover{color:#008bcc}.hc-pagination-container .hc-page-btns-container .hc-page-button:focus{outline:0}.hc-pagination-container .hc-page-btns-container .hc-page-button.hc-page-button-current{background-color:#00aeff;color:#fff}.hc-pagination-container .hc-page-btns-container .hc-page-left-button{border-bottom-right-radius:0;border-top-right-radius:0;padding:0 15px}.hc-pagination-container .hc-page-btns-container .hc-page-right-button{border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0;padding:0 15px}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button{border-left-width:0;padding:0 5px;border-radius:0}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button[disabled]{border-bottom-color:rgba(204,204,204,.35);border-top-color:rgba(204,204,204,.35);color:rgba(0,174,255,.35);opacity:1}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button[disabled]:hover{background-color:#fff}.hc-pagination-container .hc-page-btns-container .hc-page-button-chevron{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI3LjM4NSIgaGVpZ2h0PSIxMiIgdmlld0JveD0iMCAwIDcuMzg1IDEyIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTMuMzcxLTE0LjgyNmEuNDQ4LjQ0OCwwLDAsMCwwLS42NWwtMS4yMzYtMS4xNzhhLjQ4Ni40ODYsMCwwLDAtLjY3LDBsLTMuOTU0LDMuNzktMy45NTQtMy43OWEuNDg2LjQ4NiwwLDAsMC0uNjcsMEwxLjY1MS0xNS40NzVhLjQ0OC40NDgsMCwwLDAsMCwuNjVsNS41MjUsNS4yOWEuNDg2LjQ4NiwwLDAsMCwuNjcsMFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2Ljc4NyAxMy41MTEpIHJvdGF0ZSgtOTApIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;background-size:contain;display:inline-block;height:12px;margin:1px 3px 0 7px;width:7px}.hc-pagination-container .hc-page-btns-container .hc-page-button-chevron-left{margin:1px 7px 0 3px;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-pagination-container .hc-page-btns-container .hc-page-button-ellipsis{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSI1IiB2aWV3Qm94PSIwIDAgMjAgNSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNiIgZGF0YS1uYW1lPSJQYXRoIDYiIGNsYXNzPSJjbHMtMSIgZD0iTTUuNDU1LTEzLjc1QTEuMzExLDEuMzExLDAsMCwwLDQuMDkxLTE1SDEuMzY0QTEuMzExLDEuMzExLDAsMCwwLDAtMTMuNzV2Mi41QTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEwSDQuMDkxYTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEuMjVabTcuMjczLDBBMS4zMTEsMS4zMTEsMCwwLDAsMTEuMzY0LTE1SDguNjM2YTEuMzExLDEuMzExLDAsMCwwLTEuMzY0LDEuMjV2Mi41QTEuMzExLDEuMzExLDAsMCwwLDguNjM2LTEwaDIuNzI3YTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEuMjVabTcuMjczLDBBMS4zMTEsMS4zMTEsMCwwLDAsMTguNjM2LTE1SDE1LjkwOWExLjMxMSwxLjMxMSwwLDAsMC0xLjM2NCwxLjI1djIuNUExLjMxMSwxLjMxMSwwLDAsMCwxNS45MDktMTBoMi43MjdBMS4zMTEsMS4zMTEsMCwwLDAsMjAtMTEuMjVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDE1KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;display:inline-block;height:3px;margin-bottom:1px;opacity:.4;width:11px}",
  ],
  encapsulation: 2,
});
PaginationComponent.propDecorators = {
  pageSizeOptions: [{ type: Input }],
  displayWidth: [{ type: Input }],
  hidePageSize: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  PaginationComponent.prototype._pageSizeOptions;
  /** @type {?} */
  PaginationComponent.prototype.isFocused;
  /**
   * Displayed set of page size options. Will be sorted and include current page size.
   * @type {?}
   */
  PaginationComponent.prototype._displayedPageSizeOptions;
  /**
   * Sets the controller to a specific width type - `lg`, `md`, or `sm`. Typically adjusted in a window
   * resize listener for responsive layouts. *Defaults to lg.*
   * @type {?}
   */
  PaginationComponent.prototype.displayWidth;
  /**
   * @type {?}
   * @private
   */
  PaginationComponent.prototype._hidePageSize;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/load-more-pagination.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A simple "load more" pagination button.
 * \@inheritdoc
 *
 */
class LoadMorePaginationComponent extends BasePaginationComponent {
  constructor() {
    super(...arguments);
    /**
     * Text to show on the button. *Defaults to 'Load more'.*
     */
    this.buttonText = "Load more";
    this._style = "secondary";
  }
  /**
   * Sets style of button. Choose from: `'primary' | 'primary-alt' | 'destructive' | 'neutral' | 'secondary' | 'link' | 'link-inline'`.
   * *Defaults to `'secondary'`.*
   * @return {?}
   */
  get buttonStyle() {
    return this._style;
  }
  /**
   * @param {?} btnStyle
   * @return {?}
   */
  set buttonStyle(btnStyle) {
    validateStyleInput(btnStyle);
    this._style = btnStyle;
  }
  /**
   * @return {?}
   */
  _loadNextPage() {
    if (this._isLastPage) {
      return;
    }
    this.pageNumber = this.pageNumber + 1;
  }
}
LoadMorePaginationComponent.ɵfac = function LoadMorePaginationComponent_Factory(
  t
) {
  return ɵLoadMorePaginationComponent_BaseFactory(
    t || LoadMorePaginationComponent
  );
};
LoadMorePaginationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: LoadMorePaginationComponent,
  selectors: [["hc-load-more-pagination"]],
  inputs: { buttonText: "buttonText", buttonStyle: "buttonStyle" },
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [
    [
      "hc-button",
      "",
      1,
      "hc-page-load-more-button",
      3,
      "buttonStyle",
      "disabled",
      "click",
    ],
  ],
  template: function LoadMorePaginationComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "button", 0);
      ɵngcc0.ɵɵlistener(
        "click",
        function LoadMorePaginationComponent_Template_button_click_0_listener() {
          return ctx._loadNextPage();
        }
      );
      ɵngcc0.ɵɵtext(1);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("buttonStyle", ctx.buttonStyle)(
        "disabled",
        ctx._isLastPage
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵtextInterpolate1(" ", ctx.buttonText, "\n");
    }
  },
  directives: [ButtonComponent],
  styles: [
    ".hc-page-load-more-button{display:block;margin:20px auto;min-width:30%}",
  ],
  encapsulation: 2,
});
LoadMorePaginationComponent.propDecorators = {
  buttonText: [{ type: Input }],
  buttonStyle: [{ type: Input }],
};
if (false) {
  /**
   * Text to show on the button. *Defaults to 'Load more'.*
   * @type {?}
   */
  LoadMorePaginationComponent.prototype.buttonText;
  /**
   * @type {?}
   * @private
   */
  LoadMorePaginationComponent.prototype._style;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/page-event.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Change event object that is emitted when the user selects a
 * different page size or navigates to another page.
 */
class PageEvent {}
if (false) {
  /**
   * The current page index
   * @type {?}
   */
  PageEvent.prototype.pageNumber;
  /**
   * Index of the page that was selected previously
   * @type {?}
   */
  PageEvent.prototype.previousPageNumber;
  /**
   * The current page size
   * @type {?}
   */
  PageEvent.prototype.pageSize;
  /**
   * The current total number of items being paged
   * @type {?}
   */
  PageEvent.prototype.length;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/pagination.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModule {}
PaginationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PaginationModule });
PaginationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function PaginationModule_Factory(t) {
    return new (t || PaginationModule)();
  },
  imports: [[CommonModule, ButtonModule, IconModule, SelectModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pagination/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/picklist.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Represents a simple picklist option.
 * @record
 */
function IValueOption() {}
if (false) {
  /**
   * Any unique string identifier.
   * @type {?}
   */
  IValueOption.prototype.code;
  /**
   * The name of the option that will be displayed in the UI.
   * @type {?}
   */
  IValueOption.prototype.title;
}
/**
 * Represents a collection or bundle of picklist options.
 * @record
 */
function IValueSetOption() {}
if (false) {
  /**
   * Number of subvalues. Required because of the fact that `subValues` isn't always preloaded.
   * @type {?}
   */
  IValueSetOption.prototype.subValueCount;
  /**
   * Collection of values in this value set. The code and title of each subvalue should match what
   * is used by the value when used outside of a valueset. Note: The `subValues` array can initially be
   * empty if the `getValuesForValueset` callback function is provided.
   * @type {?}
   */
  IValueSetOption.prototype.subValues;
}
/**
 * @record
 */
function IPicklistOptions() {}
if (false) {
  /**
   * A collection of values.
   * @type {?}
   */
  IPicklistOptions.prototype.values;
  /**
   * A collection of value sets, which may or may not be pre-seeded with its subvalues.
   * @type {?}
   */
  IPicklistOptions.prototype.valueSets;
}
/**
 * @record
 */
function IPicklistSettings() {}
if (false) {
  /**
   * True if code is considered important. If so, search and sorting will use the code. *Defaults to false.*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.codeIsSignificant;
  /**
   * Set to true to use valuesets. *Defaults to false.*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.useValuesets;
  /**
   * Set to true to show text in the header. *Defaults to true.*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.showHeaderText;
  /**
   * Text for left header. *Defaults to "Available".*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.leftHeaderText;
  /**
   * Text for right header. *Defaults to "Selected".*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.rightHeaderText;
  /**
   * How to sort options in the pane. Options: `asc` | `desc` | `none`; *Defaults to `none`.*
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.sort;
  /**
   * Pre-seed the modal with selected options.
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.selected;
  /**
   * Available options in the picklist. Set with local values or callbacks to retrieve remote values.
   * @type {?|undefined}
   */
  IPicklistSettings.prototype.options;
}
/**
 * @record
 */
function IPicklistOptionsSource() {}
if (false) {
  /**
   * Collection of values to select from.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.values;
  /**
   * Collection of value sets to select from.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.valueSets;
  /**
   * Will the results from the server be paged? *Defaults to false.* Not used without `getOptions` callback.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.isPaged;
  /**
   * What size results will be returned from the server? *Defaults to 100.* Not used without `getOptions` callback.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.pageSize;
  /**
   * Callback function retrieve values.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.getOptions;
  /**
   * Callback function to retrieve values for a value set.
   * @type {?|undefined}
   */
  IPicklistOptionsSource.prototype.getValuesForValueset;
}
/**
 * @ignore
 */
class PicklistOptionsSource {
  constructor() {
    this.values = new Array();
    this.valueSets = new Array();
    this.isPaged = false;
    this.pageSize = 100;
  }
  /**
   * @return {?}
   */
  optionsAreLocal() {
    return !this.getOptions;
  }
}
if (false) {
  /** @type {?} */
  PicklistOptionsSource.prototype.values;
  /** @type {?} */
  PicklistOptionsSource.prototype.valueSets;
  /** @type {?} */
  PicklistOptionsSource.prototype.isPaged;
  /** @type {?} */
  PicklistOptionsSource.prototype.pageSize;
  /** @type {?} */
  PicklistOptionsSource.prototype.getOptions;
  /** @type {?} */
  PicklistOptionsSource.prototype.getValuesForValueset;
}
/**
 * @ignore
 */
class PicklistSettings {
  constructor() {
    this.codeIsSignificant = false;
    this.useValuesets = false;
    this.showHeaderText = true;
    this.leftHeaderText = "Available";
    this.rightHeaderText = "Selected";
    this.sort = "none";
    this.selected = { values: new Array(), valueSets: new Array() }; // options selected in modal
    // options selected in modal
    this.options = new PicklistOptionsSource(); // options available for choosing
  }
}
if (false) {
  /** @type {?} */
  PicklistSettings.prototype.codeIsSignificant;
  /** @type {?} */
  PicklistSettings.prototype.useValuesets;
  /** @type {?} */
  PicklistSettings.prototype.showHeaderText;
  /** @type {?} */
  PicklistSettings.prototype.leftHeaderText;
  /** @type {?} */
  PicklistSettings.prototype.rightHeaderText;
  /** @type {?} */
  PicklistSettings.prototype.sort;
  /** @type {?} */
  PicklistSettings.prototype.selected;
  /** @type {?} */
  PicklistSettings.prototype.options;
}
/**
 * Interface to be used as part of the response when loading values over HTTP.
 * @record
 * @template IT
 */
function IPagedCollection() {}
if (false) {
  /**
   * Page being returned in the response, and the number of items per page.
   * @type {?}
   */
  IPagedCollection.prototype.pagerSettings;
  /**
   * Total number of items, including those already on the client or included in this response.
   * @type {?}
   */
  IPagedCollection.prototype.totalItems;
  /**
   * Total number of pages.
   * @type {?}
   */
  IPagedCollection.prototype.totalPages;
  /**
   * An array of `IValueOption` or `IValuesetOption`.
   * @type {?}
   */
  IPagedCollection.prototype.values;
}
/**
 * @record
 */
function IPageSettings() {}
if (false) {
  /**
   * Current page of the request or response.
   * @type {?}
   */
  IPageSettings.prototype.currentPage;
  /**
   * Total number of items on a page
   * @type {?}
   */
  IPageSettings.prototype.itemsPerPage;
}
/**
 * Interface to be used for the response when loading values over HTTP. This the type your `getOptions()` callback should return.
 * @record
 */
function IPicklistRemoteQueryResponse() {}
if (false) {
  /**
   * Paged collection of `IValueOptions`. Only used if this picklist has `optionSource.isPaged` set to true.
   * @type {?|undefined}
   */
  IPicklistRemoteQueryResponse.prototype.pagedValues;
  /**
   * Paged collection of `IValueSetOptions`. Only used if this picklist has `optionSource.isPaged` set to true.
   * @type {?|undefined}
   */
  IPicklistRemoteQueryResponse.prototype.pagedValueSets;
  /**
   * An array of `{ code: string, title: string}`. Only used if this picklist has `optionSource.isPaged` set to false.
   * @type {?|undefined}
   */
  IPicklistRemoteQueryResponse.prototype.values;
  /**
   * An array of `{ code: string, title: string, subValueCount: number, subValues: IValueOption[]}`.
   * Only used if this picklist has `optionSource.isPaged` set to false. Note: The `subValues` array can
   * initially be empty if the `getValuesForValueset` callback function is provided.
   * @type {?|undefined}
   */
  IPicklistRemoteQueryResponse.prototype.valueSets;
}
/**
 * An instance of this class will be sent to the `getOptions()` callback if loading values over HTTP.
 */
class PicklistRemoteQueryOptions {
  /**
   * @param {?} picklist
   * @param {?} searchTerm
   * @param {?} valueTypeToQuery
   */
  constructor(picklist, searchTerm, valueTypeToQuery) {
    this.picklist = picklist;
    this.searchTerm = searchTerm;
    this.valueTypeToQuery = valueTypeToQuery;
  }
}
if (false) {
  /**
   * Page and number of items per page requested for values.
   * @type {?}
   */
  PicklistRemoteQueryOptions.prototype.valuePageSettings;
  /**
   * Page and number of items per page requested for value sets.
   * @type {?}
   */
  PicklistRemoteQueryOptions.prototype.valueSetPageSettings;
  /**
   * The settings for this picklist. Particularly, `codeIsSignificant`, `useValuesets`,
   * and selected values will be useful in obtaining the needed values & value sets.
   * @type {?}
   */
  PicklistRemoteQueryOptions.prototype.picklist;
  /**
   * Search term entered by the user that triggered the request.
   * @type {?}
   */
  PicklistRemoteQueryOptions.prototype.searchTerm;
  /**
   * Which types of values should we be getting?
   * @type {?}
   */
  PicklistRemoteQueryOptions.prototype.valueTypeToQuery;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/picklist.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const supportedSortModes = ["asc", "desc", "none"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateSortInput(inputStr) {
  if (supportedSortModes.indexOf(inputStr) < 0) {
    throw Error("Unsupported sort input value: " + inputStr);
  }
}
class PicklistComponent {
  constructor() {
    /**
     * Fired when a change is made to the picklist selection.
     */
    this.changed = new EventEmitter();
    this.picklistSettings = new PicklistSettings();
    this.stringOptions = null;
    this.onChange =
      /**
       * @return {?}
       */
      () => {};
    this.onTouched =
      /**
       * @return {?}
       */
      () => {};
  }
  /**
   * Settings for the picklist. Internally, this will trigger a call to `reset()`.
   * @param {?} settings
   * @return {?}
   */
  set settings(settings) {
    this.reset(settings);
  }
  /**
   * @return {?}
   */
  get settings() {
    return this.picklistSettings;
  }
  /**
   * An array of unique strings to be used as the picklist options.
   * @param {?} options
   * @return {?}
   */
  set simpleOptions(options) {
    this.updateStateFromStringOptions(options);
  }
  /**
   * @return {?}
   */
  get simpleOptions() {
    return this.stringOptions;
  }
  /**
   * Set to true to show text in the header. *Defaults to true.*
   * @param {?} shouldShow
   * @return {?}
   */
  set showHeaderText(shouldShow) {
    this.update({ showHeaderText: shouldShow });
  }
  /**
   * @return {?}
   */
  get showHeaderText() {
    return this.picklistSettings.showHeaderText;
  }
  /**
   * Text for left header. *Defaults to "Available".*
   * @param {?} text
   * @return {?}
   */
  set leftHeaderText(text) {
    this.update({ leftHeaderText: text });
  }
  /**
   * @return {?}
   */
  get leftHeaderText() {
    return this.picklistSettings.leftHeaderText;
  }
  /**
   * Text for right header. *Defaults to "Selected".*
   * @param {?} text
   * @return {?}
   */
  set rightHeaderText(text) {
    this.update({ rightHeaderText: text });
  }
  /**
   * @return {?}
   */
  get rightHeaderText() {
    return this.picklistSettings.rightHeaderText;
  }
  /**
   * How to sort options in the pane. Options: `asc` | `desc` | `none`; *Defaults to `none`.*
   * @param {?} sort
   * @return {?}
   */
  set sort(sort) {
    validateSortInput(sort);
    this.update({ sort: sort });
  }
  /**
   * @return {?}
   */
  get sort() {
    return this.picklistSettings.sort;
  }
  /**
   * @return {?}
   */
  get _leftToRightMoveBtnIsDisabled() {
    return this._available ? !this._available.isAnySelected() : false;
  }
  /**
   * Current selected value of the picklist. Will be either `IPicklistOptions` or `string[]` depending on the type of options provided.
   * @param {?} model
   * @return {?}
   */
  set value(model) {
    /** @type {?} */
    const selectedValues = { values: [], valueSets: [] };
    if (this.picklistModelisArray(model)) {
      /** @type {?} */
      const selected = this.convertStringsToValueOptions(model);
      selectedValues.values = selected || [];
    } else {
      selectedValues.values = model.values || [];
      selectedValues.valueSets = model.valueSets || [];
    }
    this.update({ selected: selectedValues });
  }
  /**
   * @return {?}
   */
  get value() {
    if (this.stringOptions) {
      return this.picklistSettings.selected.values.map(
        /**
         * @param {?} v
         * @return {?}
         */
        (v) => v.title
      );
    } else {
      return this.picklistSettings.selected;
    }
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  writeValue(value) {
    if (value) {
      this.value = value;
    }
  }
  /**
   * Will update the picklist with the given settings, maintaining any previous settings that have not been overridden.
   * @param {?} settings
   * @return {?}
   */
  update(settings) {
    /** @type {?} */
    const updatedSettings = Object.assign(this.picklistSettings, settings);
    this.reset(updatedSettings);
  }
  /**
   * Will reset the picklist settings with the given settings. (Clears out any previous settings.)
   * @param {?=} settings
   * @return {?}
   */
  reset(settings = new PicklistSettings()) {
    this.picklistSettings = Object.assign(new PicklistSettings(), settings);
    this.resetPanes(this.picklistSettings);
    this.setActiveValueType(
      this.picklistSettings.useValuesets ? "valueSets" : "values"
    );
    this.applyChangeToModel();
  }
  /**
   * Will change the active tab. (Will do nothing if `settings.useValuesets` is false.)
   * @param {?} type
   * @return {?}
   */
  setActiveValueType(type) {
    if (!this._available) {
      console.warn("Available picklist pane not available yet.");
      return;
    }
    if (!this.settings.useValuesets) {
      type = "values";
    }
    this._available.valueList.isActive = type === "values";
    this._available.valueSetList.isActive = type === "valueSets";
    this._available.selectNone();
    this._available.scrollToTop();
  }
  /**
   * Will move all selected items from the given pane into its companion pane. Used internally by the left and right arrow buttons.
   * @param {?} pane the pane from which we are moving items out of
   * @return {?}
   */
  moveSelectedItems(pane) {
    /** @type {?} */
    const shouldBreakValuesets = pane === this._confirmed;
    /** @type {?} */
    const selectedOptions = pane.listService.moveOutSelectedOptions(
      shouldBreakValuesets
    );
    if (pane.companion) {
      pane.companion.listService.addOptions(selectedOptions);
    } else {
      console.warn(
        "This pane does not have a companion pane to move the select options in to."
      );
    }
    pane.filterService.reloadIfEmpty();
    this.applyChangeToModel();
  }
  /**
   * @private
   * @param {?} options
   * @return {?}
   */
  updateStateFromStringOptions(options) {
    /** @type {?} */
    const valueOptions = this.convertStringsToValueOptions(options);
    this.stringOptions = options;
    this.update({ options: { values: valueOptions || [] } });
  }
  /**
   * @private
   * @param {?} settings
   * @return {?}
   */
  resetPanes(settings) {
    if (!(this._available && this._confirmed)) {
      console.warn("Picklist panes not available yet.");
      return;
    }
    /** @type {?} */
    const confirmedSource = new PicklistOptionsSource();
    confirmedSource.values = this.picklistSettings.selected.values.slice(0);
    confirmedSource.valueSets = this.picklistSettings.selected.valueSets.slice(
      0
    );
    confirmedSource.getValuesForValueset = this.picklistSettings.options.getValuesForValueset;
    this._confirmed.reset(
      confirmedSource,
      this.picklistSettings,
      this._available,
      false
    );
    /** @type {?} */
    const availableSource = Object.assign(
      new PicklistOptionsSource(),
      this.picklistSettings.options
    );
    this._available.reset(
      availableSource,
      this.picklistSettings,
      this._confirmed,
      true
    );
  }
  /**
   * @private
   * @return {?}
   */
  applyChangeToModel() {
    if (!(this._available && this._confirmed)) {
      console.warn("Picklist panes not available yet.");
      return;
    }
    this.picklistSettings.selected.values.length = 0;
    this.picklistSettings.selected.valueSets.length = 0;
    this._confirmed.valueList.options.forEach(
      /**
       * @param {?} e
       * @return {?}
       */
      (e) => this.picklistSettings.selected.values.push(e.option)
    );
    this._confirmed.valueSetList.options.forEach(
      /**
       * @param {?} e
       * @return {?}
       */
      (e) => this.picklistSettings.selected.valueSets.push(e.option)
    );
    this.changed.emit();
    this.onChange(this.value);
    this.onTouched();
  }
  /**
   * @private
   * @param {?} vals
   * @return {?}
   */
  convertStringsToValueOptions(vals) {
    return vals
      ? vals.map(
          /**
           * @param {?} o
           * @return {?}
           */
          (o) => ({ code: `${o}`, title: `${o}` })
        )
      : null;
  }
  /**
   * @private
   * @param {?} model
   * @return {?}
   */
  picklistModelisArray(model) {
    /** @type {?} */
    const array = /** @type {?} */ (model);
    return array && array.length !== undefined;
  }
}
PicklistComponent.ɵfac = function PicklistComponent_Factory(t) {
  return new (t || PicklistComponent)();
};
PicklistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: PicklistComponent,
  selectors: [["hc-picklist"]],
  viewQuery: function PicklistComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵstaticViewQuery(_c51, true);
      ɵngcc0.ɵɵstaticViewQuery(_c52, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._available = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._confirmed = _t.first);
    }
  },
  inputs: {
    settings: "settings",
    simpleOptions: "simpleOptions",
    showHeaderText: "showHeaderText",
    leftHeaderText: "leftHeaderText",
    rightHeaderText: "rightHeaderText",
    sort: "sort",
  },
  outputs: { changed: "changed" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(
          /**
           * @return {?}
           */ () => PicklistComponent
        ),
        multi: true,
      },
    ]),
  ],
  decls: 17,
  vars: 5,
  consts: [
    [1, "hc-picklist"],
    [1, "pane-wrap"],
    [1, "pane-header"],
    [4, "ngIf"],
    ["class", "pane-tabs hc-tab-bar-horizontal", 4, "ngIf"],
    ["emptyMsg", "No options available.", 3, "moveSelectedItems"],
    ["availableList", ""],
    [1, "move-btns-wrap"],
    [
      "hc-button",
      "",
      "color",
      "primary-alt",
      "type",
      "button",
      "name",
      "addBtn",
      3,
      "disabled",
      "click",
    ],
    ["hcIconSm", "", "fontSet", "fa", "fontIcon", "fa-arrow-right"],
    [
      "hc-button",
      "",
      "color",
      "primary-alt",
      "type",
      "button",
      "name",
      "removeBtn",
      3,
      "disabled",
      "click",
    ],
    ["hcIconSm", "", "fontSet", "fa", "fontIcon", "fa-arrow-left"],
    ["emptyMsg", "No options selected.", 3, "moveSelectedItems"],
    ["confirmedList", ""],
    [1, "pane-tabs", "hc-tab-bar-horizontal"],
    [
      "title",
      "Search for Value Sets",
      1,
      "hc-tab-horizontal",
      3,
      "ngClass",
      "click",
    ],
    [
      "title",
      "Search for Values",
      1,
      "hc-tab-horizontal",
      3,
      "ngClass",
      "click",
    ],
  ],
  template: function PicklistComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r8 = ɵngcc0.ɵɵgetCurrentView();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵelementStart(2, "div", 2);
      ɵngcc0.ɵɵtemplate(3, PicklistComponent_h2_3_Template, 2, 1, "h2", 3);
      ɵngcc0.ɵɵtemplate(4, PicklistComponent_div_4_Template, 5, 6, "div", 4);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(5, "hc-picklist-pane", 5, 6);
      ɵngcc0.ɵɵlistener(
        "moveSelectedItems",
        function PicklistComponent_Template_hc_picklist_pane_moveSelectedItems_5_listener(
          $event
        ) {
          return ctx.moveSelectedItems($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(7, "div", 7);
      ɵngcc0.ɵɵelementStart(8, "button", 8);
      ɵngcc0.ɵɵlistener(
        "click",
        function PicklistComponent_Template_button_click_8_listener() {
          ɵngcc0.ɵɵrestoreView(_r8);
          const _r2 = ɵngcc0.ɵɵreference(6);
          return ctx.moveSelectedItems(_r2);
        }
      );
      ɵngcc0.ɵɵelement(9, "hc-icon", 9);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(10, "button", 10);
      ɵngcc0.ɵɵlistener(
        "click",
        function PicklistComponent_Template_button_click_10_listener() {
          ɵngcc0.ɵɵrestoreView(_r8);
          const _r4 = ɵngcc0.ɵɵreference(16);
          return ctx.moveSelectedItems(_r4);
        }
      );
      ɵngcc0.ɵɵelement(11, "hc-icon", 11);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(12, "div", 1);
      ɵngcc0.ɵɵelementStart(13, "div", 2);
      ɵngcc0.ɵɵtemplate(14, PicklistComponent_h2_14_Template, 2, 1, "h2", 3);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(15, "hc-picklist-pane", 12, 13);
      ɵngcc0.ɵɵlistener(
        "moveSelectedItems",
        function PicklistComponent_Template_hc_picklist_pane_moveSelectedItems_15_listener(
          $event
        ) {
          return ctx.moveSelectedItems($event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngIf", ctx.settings.showHeaderText);
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx.settings.useValuesets);
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("disabled", ctx._leftToRightMoveBtnIsDisabled);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "disabled",
        !(ctx._confirmed == null ? null : ctx._confirmed.isAnySelected())
      );
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty("ngIf", ctx.settings.showHeaderText);
    }
  },
  directives: function () {
    return [
      ɵngcc1.NgIf,
      PicklistPaneComponent,
      ButtonComponent,
      IconComponent,
      HcIconSmallDirective,
      ɵngcc1.NgClass,
    ];
  },
  styles: [
    ".hc-picklist{-webkit-box-align:stretch;align-items:stretch;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row;height:100%;-webkit-box-pack:justify;justify-content:space-between;min-width:650px}.hc-picklist .pane-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;width:45%}.hc-picklist .pane-header{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 30px;-webkit-box-pack:justify;justify-content:space-between}.hc-picklist .pane-header h2{font-size:16px;font-weight:700;margin:3px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-picklist .pane-tabs{border-bottom:none;-webkit-box-flex:0;flex:0 0 auto}.hc-picklist .pane-tabs a{font-size:13px}.hc-picklist hc-picklist-pane{display:block;-webkit-box-flex:1;flex:1 1 auto;height:calc(100% - 30px)}.hc-picklist hc-picklist-pane.hide{display:none}.hc-picklist .move-btns-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;-webkit-box-pack:center;justify-content:center;padding-top:100px;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.hc-picklist .move-btns-wrap button{height:60px;margin-top:12px;min-width:0;padding:0;width:30px}.hc-picklist .move-btns-wrap button[disabled],.hc-picklist .move-btns-wrap button[disabled]:hover{background-color:#ccc;border-color:#ccc}.hc-picklist .move-btns-wrap .hc-icon{color:#fff}",
  ],
  encapsulation: 2,
});
PicklistComponent.propDecorators = {
  settings: [{ type: Input }],
  simpleOptions: [{ type: Input }],
  showHeaderText: [{ type: Input }],
  leftHeaderText: [{ type: Input }],
  rightHeaderText: [{ type: Input }],
  sort: [{ type: Input }],
  _available: [{ type: ViewChild, args: ["availableList", { static: true }] }],
  _confirmed: [{ type: ViewChild, args: ["confirmedList", { static: true }] }],
  changed: [{ type: Output }],
};
if (false) {
  /** @type {?} */
  PicklistComponent.prototype._available;
  /** @type {?} */
  PicklistComponent.prototype._confirmed;
  /**
   * Fired when a change is made to the picklist selection.
   * @type {?}
   */
  PicklistComponent.prototype.changed;
  /**
   * @type {?}
   * @private
   */
  PicklistComponent.prototype.picklistSettings;
  /**
   * @type {?}
   * @private
   */
  PicklistComponent.prototype.stringOptions;
  /** @type {?} */
  PicklistComponent.prototype.onChange;
  /** @type {?} */
  PicklistComponent.prototype.onTouched;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/pane/picklist-pane.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FilterableSelectList {
  /**
   * @param {?=} options
   */
  constructor(options = new Map()) {
    this.options = options;
    this.selectedOptions = new Map();
    this.lastClickedOption = null;
    this.filteredOptions = new Array();
    this.isActive = true;
    this.additionalRemoteOptions = 0;
    this.loadingOptions = from([]);
    this.appendingOptions = from([]);
    this.codeIsSignificant = false;
  }
}
if (false) {
  /** @type {?} */
  FilterableSelectList.prototype.selectedOptions;
  /** @type {?} */
  FilterableSelectList.prototype.lastClickedOption;
  /** @type {?} */
  FilterableSelectList.prototype.filteredOptions;
  /** @type {?} */
  FilterableSelectList.prototype.isActive;
  /** @type {?} */
  FilterableSelectList.prototype.additionalRemoteOptions;
  /** @type {?} */
  FilterableSelectList.prototype.loadingOptions;
  /** @type {?} */
  FilterableSelectList.prototype.appendingOptions;
  /** @type {?} */
  FilterableSelectList.prototype.codeIsSignificant;
  /** @type {?} */
  FilterableSelectList.prototype.sort;
  /** @type {?} */
  FilterableSelectList.prototype.options;
}
class SubSelectList extends FilterableSelectList {
  /**
   * @param {?} parentValueSet
   * @param {?=} options
   */
  constructor(parentValueSet, options = new Map()) {
    super(options);
    this.parentValueSet = parentValueSet;
    this.options = options;
  }
}
if (false) {
  /** @type {?} */
  SubSelectList.prototype.parentValueSet;
  /** @type {?} */
  SubSelectList.prototype.options;
}
/**
 * @param {?} model
 * @return {?}
 */
function isSubList(model) {
  /** @type {?} */
  const subList = /** @type {?} */ (model);
  return subList && subList.parentValueSet !== undefined;
}
class SelectListOption {
  /**
   * @param {?} option
   * @param {?} code
   */
  constructor(option, code) {
    this.option = option;
    this.code = code;
    this.selected = false;
  }
}
if (false) {
  /** @type {?} */
  SelectListOption.prototype.selected;
  /** @type {?} */
  SelectListOption.prototype.option;
  /** @type {?} */
  SelectListOption.prototype.code;
}
class ValueListOption extends SelectListOption {
  /**
   * @param {?} option
   * @param {?} code
   */
  constructor(option, code) {
    super(option, code);
  }
}
class ValueSetListOption extends SelectListOption {
  /**
   * @param {?} option
   * @param {?} code
   */
  constructor(option, code) {
    super(option, code);
    this.showValues = false;
    this.loadingValues = false;
    this.subValuesSelectList = new SubSelectList(this);
  }
}
if (false) {
  /** @type {?} */
  ValueSetListOption.prototype.subValuesSelectList;
  /** @type {?} */
  ValueSetListOption.prototype.showValues;
  /** @type {?} */
  ValueSetListOption.prototype.loadingValues;
}
class PicklistValueOptions {
  constructor() {
    this.values = new Map();
    this.valueSets = new Map();
  }
}
if (false) {
  /** @type {?} */
  PicklistValueOptions.prototype.values;
  /** @type {?} */
  PicklistValueOptions.prototype.valueSets;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-filter-local.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistFilterLocalService {
  /**
   * @template T
   * @param {?} list
   * @param {?} searchTokens
   * @return {?}
   */
  filter(list, searchTokens) {
    list.filteredOptions = [];
    list.options.forEach(
      /**
       * @param {?} item
       * @return {?}
       */
      (item) => {
        if (this.itemHasSearchTokens(list, item, searchTokens)) {
          list.filteredOptions.push(item);
        }
      }
    );
    if (list.sort !== "none") {
      list.filteredOptions.sort(this.getSortFunc(list));
    }
  }
  /**
   * @template T
   * @param {?} list
   * @param {?} item
   * @param {?} searchTokens
   * @return {?}
   */
  itemHasSearchTokens(list, item, searchTokens) {
    /** @type {?} */
    const valuesToSearchIn = [
      item.option.title,
      list.codeIsSignificant ? item.option.code : "",
    ];
    valuesToSearchIn.filter(
      /**
       * @param {?} val
       * @return {?}
       */
      (val) => !!val
    );
    return searchTokens.every(
      /**
       * @param {?} token
       * @return {?}
       */
      (token) =>
        valuesToSearchIn.some(
          /**
           * @param {?} value
           * @return {?}
           */
          (value) => value.toLocaleLowerCase().indexOf(token) > -1
        )
    );
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @return {?}
   */
  getSortFunc(list) {
    /** @type {?} */
    const sortField = list.codeIsSignificant ? "code" : "title";
    return (
      /**
       * @param {?} a
       * @param {?} b
       * @return {?}
       */
      (a, b) =>
        a.option[sortField].localeCompare(b.option[sortField]) *
        (list.sort === "asc" ? -1 : 1)
    );
  }
}
PicklistFilterLocalService.ɵfac = function PicklistFilterLocalService_Factory(
  t
) {
  return new (t || PicklistFilterLocalService)();
};
PicklistFilterLocalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistFilterLocalService,
  factory: PicklistFilterLocalService.ɵfac,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-state.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistStateService {
  /**
   * @param {?} localFilterService
   */
  constructor(localFilterService) {
    this.localFilterService = localFilterService;
    this.picklist = new PicklistSettings();
    this.optionsSource = new PicklistOptionsSource();
    this.valueList = new FilterableSelectList();
    this.valueSetList = new FilterableSelectList();
  }
  /**
   * @param {?} settings
   * @param {?} optionsSource
   * @param {?} pane
   * @return {?}
   */
  reset(settings, optionsSource, pane) {
    this.picklist = settings;
    this.pane = pane;
    this.optionsSource = optionsSource;
    this.clearList(this.valueList);
    this.clearList(this.valueSetList);
  }
  /**
   * @param {?} options
   * @param {?=} searchTokens
   * @return {?}
   */
  updateValueList(options, searchTokens = []) {
    /** @type {?} */
    const listOptions = options.map(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => new ValueListOption(v, v.code)
    );
    /** @type {?} */
    const companionList = this.pane.companion
      ? this.pane.companion.valueList
      : null;
    this.valueList.sort = this.picklist.sort;
    this.updateList(listOptions, this.valueList, companionList, searchTokens);
  }
  /**
   * @param {?} options
   * @param {?=} searchTokens
   * @return {?}
   */
  updateValueSetList(options, searchTokens = []) {
    /** @type {?} */
    const listOptions = new Array();
    /** @type {?} */
    const companionList = this.pane.companion
      ? this.pane.companion.valueSetList
      : null;
    options.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        /** @type {?} */
        const listOption = new ValueSetListOption(v, v.code);
        if (v.subValues && v.subValues.length > 0) {
          /** @type {?} */
          const subValueListOptions = v.subValues.map(
            /**
             * @param {?} sv
             * @return {?}
             */
            (sv) => new ValueListOption(sv, sv.code)
          );
          this.updateList(
            subValueListOptions,
            listOption.subValuesSelectList,
            null,
            searchTokens
          );
        }
        listOptions.push(listOption);
      }
    );
    this.updateList(
      listOptions,
      this.valueSetList,
      companionList,
      searchTokens
    );
  }
  /**
   * @template T
   * @param {?} list
   * @return {?}
   */
  clearList(list) {
    list.options.clear();
    list.filteredOptions.length = 0;
    list.selectedOptions.clear();
    list.lastClickedOption = null;
    list.additionalRemoteOptions = 0;
  }
  /**
   * @private
   * @template T
   * @param {?} options
   * @param {?} list
   * @param {?=} companionList
   * @param {?=} searchTokens
   * @return {?}
   */
  updateList(options, list, companionList = null, searchTokens = []) {
    if (
      !this.optionsSource.isPaged &&
      this.pane.shouldExcludeCompanion &&
      companionList
    ) {
      options = options.filter(
        /**
         * @param {?} o
         * @return {?}
         */
        (o) => !companionList.options.get(o.code)
      );
    }
    options.forEach(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => {
        list.options.set(o.code, o);
        list.filteredOptions.push(o);
      }
    );
    this.localFilterService.filter(list, searchTokens);
  }
}
PicklistStateService.ɵfac = function PicklistStateService_Factory(t) {
  return new (t || PicklistStateService)(
    ɵngcc0.ɵɵinject(PicklistFilterLocalService)
  );
};
PicklistStateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistStateService,
  factory: PicklistStateService.ɵfac,
});
/** @nocollapse */
PicklistStateService.ctorParameters = () => [
  { type: PicklistFilterLocalService },
];
if (false) {
  /** @type {?} */
  PicklistStateService.prototype.pane;
  /** @type {?} */
  PicklistStateService.prototype.picklist;
  /** @type {?} */
  PicklistStateService.prototype.optionsSource;
  /** @type {?} */
  PicklistStateService.prototype.valueList;
  /** @type {?} */
  PicklistStateService.prototype.valueSetList;
  /**
   * @type {?}
   * @private
   */
  PicklistStateService.prototype.localFilterService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-filter-remote.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistFilterRemoteService {
  /**
   * @param {?} stateService
   */
  constructor(stateService) {
    this.stateService = stateService;
    this.currentValuePage = 1;
    this.currentValueSetPage = 1;
    this.cancelSearch = new Subject();
    this.options$ = from([]);
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.stateService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.stateService.valueSetList;
  }
  /**
   * @return {?}
   */
  get searchTerm() {
    return this.filterService ? this.filterService.searchTerm : "";
  }
  /**
   * @private
   * @return {?}
   */
  get cancelSearch$() {
    return this.cancelSearch.asObservable();
  }
  /**
   * @param {?} filterService
   * @return {?}
   */
  reset(filterService) {
    this.filterService = filterService;
    this.currentValuePage = 1;
    this.currentValueSetPage = 1;
  }
  /**
   * @param {?=} type
   * @param {?=} shouldAppend
   * @param {?=} selectAllCount
   * @return {?}
   */
  filter(type = "both", shouldAppend = false, selectAllCount = null) {
    if (!this.stateService.optionsSource.getOptions) {
      console.warn("Remote query callback not provided for this picklist.");
      return from([]).subscribe();
    }
    if (this.options$) {
      this.cancelSearch.next();
    }
    /** @type {?} */
    const params = this.buildRemoteQueryParams(type, selectAllCount);
    if (!shouldAppend) {
      this.clearFilteredOptions(type);
    }
    this.resetPagingForSelectAllIfNeeded(selectAllCount);
    this.options$ = this.stateService.optionsSource
      .getOptions(params)
      .pipe(takeUntil(this.cancelSearch$));
    return this.options$.subscribe(
      /**
       * @param {?} options
       * @return {?}
       */
      (options) => {
        this.processIncomingRemoteOptions(options, type, shouldAppend);
      },
      /**
       * @return {?}
       */ () => {
        console.warn("Unable to filter options");
        this.clearLists("both");
        return of({});
      },
      /**
       * @return {?}
       */ () => {
        this.options$ = of({});
      }
    );
  }
  /**
   * @private
   * @param {?} options
   * @param {?=} type
   * @param {?=} shouldAppend
   * @return {?}
   */
  processIncomingRemoteOptions(options, type = "both", shouldAppend = false) {
    if (!shouldAppend) {
      this.clearLists(type);
    }
    if (this.stateService.optionsSource.isPaged) {
      if (options.pagedValues) {
        this.processPagedValues(options.pagedValues);
      }
      if (options.pagedValueSets) {
        this.processPagedValueSets(options.pagedValueSets);
      }
    } else {
      if (options.values) {
        this.stateService.updateValueList(options.values);
      }
      if (options.valueSets) {
        this.stateService.updateValueSetList(options.valueSets);
      }
      this.valueList.additionalRemoteOptions = 0;
      this.valueSetList.additionalRemoteOptions = 0;
    }
  }
  /**
   * @private
   * @param {?} pagedValues
   * @return {?}
   */
  processPagedValues(pagedValues) {
    this.stateService.updateValueList(pagedValues.values);
    this.valueList.additionalRemoteOptions =
      pagedValues.totalItems - this.valueList.options.size;
  }
  /**
   * @private
   * @param {?} pagedValueSets
   * @return {?}
   */
  processPagedValueSets(pagedValueSets) {
    this.stateService.updateValueSetList(pagedValueSets.values);
    this.valueSetList.additionalRemoteOptions =
      pagedValueSets.totalItems - this.valueSetList.options.size;
  }
  /**
   * @private
   * @param {?} type
   * @param {?=} selectAllCount
   * @return {?}
   */
  buildRemoteQueryParams(type, selectAllCount = null) {
    /** @type {?} */
    const params = new PicklistRemoteQueryOptions(
      this.stateService.picklist,
      this.searchTerm,
      type
    );
    if (type === "values" || type === "both") {
      params.valuePageSettings = this.buildPageSettings(
        this.currentValuePage,
        selectAllCount
      );
    }
    if (type === "valuesets" || type === "both") {
      params.valueSetPageSettings = this.buildPageSettings(
        this.currentValueSetPage,
        selectAllCount
      );
    }
    return params;
  }
  /**
   * @private
   * @param {?} currentPage
   * @param {?} selectAllCount
   * @return {?}
   */
  buildPageSettings(currentPage, selectAllCount) {
    /** @type {?} */
    const pagerSettings = {
      currentPage: 1,
      itemsPerPage: this.stateService.optionsSource.pageSize,
    };
    pagerSettings.currentPage = selectAllCount ? 1 : currentPage;
    pagerSettings.itemsPerPage = selectAllCount || pagerSettings.itemsPerPage;
    return pagerSettings;
  }
  /**
   * @private
   * @param {?=} selectAllCount
   * @return {?}
   */
  resetPagingForSelectAllIfNeeded(selectAllCount = null) {
    if (selectAllCount) {
      this.currentValuePage = Math.floor(
        selectAllCount / this.stateService.optionsSource.pageSize
      );
    }
  }
  /**
   * @private
   * @param {?} type
   * @return {?}
   */
  clearLists(type) {
    if (type === "both" || type === "values") {
      this.stateService.clearList(this.valueList);
    }
    if (type === "both" || type === "valuesets") {
      this.stateService.clearList(this.valueSetList);
    }
  }
  /**
   * @private
   * @param {?} type
   * @return {?}
   */
  clearFilteredOptions(type) {
    if (type === "both" || type === "values") {
      this.valueList.filteredOptions.length = 0;
    }
    if (type === "both" || type === "valuesets") {
      this.valueSetList.filteredOptions.length = 0;
    }
  }
}
PicklistFilterRemoteService.ɵfac = function PicklistFilterRemoteService_Factory(
  t
) {
  return new (t || PicklistFilterRemoteService)(
    ɵngcc0.ɵɵinject(PicklistStateService)
  );
};
PicklistFilterRemoteService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistFilterRemoteService,
  factory: PicklistFilterRemoteService.ɵfac,
});
/** @nocollapse */
PicklistFilterRemoteService.ctorParameters = () => [
  { type: PicklistStateService },
];
if (false) {
  /** @type {?} */
  PicklistFilterRemoteService.prototype.filterService;
  /** @type {?} */
  PicklistFilterRemoteService.prototype.currentValuePage;
  /** @type {?} */
  PicklistFilterRemoteService.prototype.currentValueSetPage;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterRemoteService.prototype.cancelSearch;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterRemoteService.prototype.options$;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterRemoteService.prototype.stateService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-filter.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistFilterService {
  /**
   * @param {?} workTracker
   * @param {?} stateService
   * @param {?} remoteFilterService
   * @param {?} localFilterService
   */
  constructor(
    workTracker,
    stateService,
    remoteFilterService,
    localFilterService
  ) {
    this.workTracker = workTracker;
    this.stateService = stateService;
    this.remoteFilterService = remoteFilterService;
    this.localFilterService = localFilterService;
    this.searchTerm = "";
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.stateService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.stateService.valueSetList;
  }
  /**
   * @return {?}
   */
  get searchTokens() {
    return this.searchTerm.toLocaleLowerCase().replace(/\s+/g, " ").split(" ");
  }
  /**
   * @return {?}
   */
  reset() {
    this.remoteFilterService.reset(this);
    this.searchTerm = "";
  }
  /**
   * @param {?} searchTerm
   * @return {?}
   */
  runFilter(searchTerm) {
    this.searchTerm = searchTerm;
    if (!this.stateService.optionsSource.isPaged) {
      this.localFilterService.filter(this.valueList, this.searchTokens);
      this.localFilterService.filter(this.valueSetList, this.searchTokens);
    } else {
      this.remoteFilterService.currentValuePage = 1;
      this.remoteFilterService.currentValueSetPage = 1;
      /** @type {?} */
      const workTracker = this.workTracker.startObservable(
        /**
         * @return {?}
         */
        () => this.remoteFilterService.filter()
      );
      this.showListLoadingIndicators(workTracker, "both");
    }
  }
  /**
   * @param {?=} type
   * @param {?=} shouldAppend
   * @param {?=} selectAllCount
   * @return {?}
   */
  filterOptionsRemote(
    type = "both",
    shouldAppend = false,
    selectAllCount = null
  ) {
    return this.remoteFilterService.filter(type, shouldAppend, selectAllCount);
  }
  /**
   * @param {?=} type
   * @param {?=} autoLoadMore
   * @return {?}
   */
  loadMore(type = "both", autoLoadMore = false) {
    if (type === "both" || type === "values") {
      this.remoteFilterService.currentValuePage++;
    }
    if (type === "both" || type === "valuesets") {
      this.remoteFilterService.currentValueSetPage++;
    }
    /** @type {?} */
    const loading$ = this.workTracker.startObservable(
      /**
       * @return {?}
       */
      () => this.filterOptionsRemote(type, true)
    );
    this.showListLoadingIndicators(loading$, type, !autoLoadMore);
  }
  /**
   * @param {?} numberToLoad
   * @return {?}
   */
  loadForSelectAll(numberToLoad) {
    /** @type {?} */
    const loading$ = this.workTracker.startObservable(
      /**
       * @return {?}
       */
      () => this.filterOptionsRemote("values", false, numberToLoad)
    );
    this.showListLoadingIndicators(loading$, "values");
    return loading$;
  }
  /**
   * @return {?}
   */
  reloadIfEmpty() {
    /** @type {?} */
    const valuesNeedReload =
      this.valueList.options.size === 0 &&
      this.valueList.additionalRemoteOptions > 0;
    /** @type {?} */
    const valueSetsNeedReload =
      this.valueSetList.options.size === 0 &&
      this.valueSetList.additionalRemoteOptions > 0;
    if (valuesNeedReload || valueSetsNeedReload) {
      this.runFilter(this.searchTerm);
    }
  }
  /**
   * @param {?} valuesMap
   * @param {?} list
   * @return {?}
   */
  preFilterOptionsForRemoteMode(valuesMap, list) {
    // if server is handling filtering, but I want to avoid the round trip to the server when moving options
    // I need to double check that those options belong before adding them, or risk errant option counts
    valuesMap.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        if (
          !this.localFilterService.itemHasSearchTokens(
            list,
            v,
            this.searchTokens
          )
        ) {
          valuesMap.delete(v.code);
        }
      }
    );
  }
  /**
   * @param {?} workTracker
   * @param {?=} type
   * @param {?=} isAppending
   * @return {?}
   */
  showListLoadingIndicators(workTracker, type = "both", isAppending = false) {
    if (type === "both" || type === "values") {
      this.showLoadingIndicatorForList(
        this.valueList,
        workTracker,
        isAppending
      );
    }
    if (type === "both" || type === "valuesets") {
      this.showLoadingIndicatorForList(
        this.valueSetList,
        workTracker,
        isAppending
      );
    }
  }
  /**
   * @private
   * @param {?} list
   * @param {?} tracker
   * @param {?=} isAppending
   * @return {?}
   */
  showLoadingIndicatorForList(list, tracker, isAppending = false) {
    if (isAppending) {
      list.appendingOptions = tracker;
    } else {
      list.loadingOptions = tracker;
    }
  }
}
PicklistFilterService.ɵfac = function PicklistFilterService_Factory(t) {
  return new (t || PicklistFilterService)(
    ɵngcc0.ɵɵinject(WorkTrackerService),
    ɵngcc0.ɵɵinject(PicklistStateService),
    ɵngcc0.ɵɵinject(PicklistFilterRemoteService),
    ɵngcc0.ɵɵinject(PicklistFilterLocalService)
  );
};
PicklistFilterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistFilterService,
  factory: PicklistFilterService.ɵfac,
});
/** @nocollapse */
PicklistFilterService.ctorParameters = () => [
  { type: WorkTrackerService },
  { type: PicklistStateService },
  { type: PicklistFilterRemoteService },
  { type: PicklistFilterLocalService },
];
if (false) {
  /** @type {?} */
  PicklistFilterService.prototype.searchTerm;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterService.prototype.workTracker;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterService.prototype.stateService;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterService.prototype.remoteFilterService;
  /**
   * @type {?}
   * @private
   */
  PicklistFilterService.prototype.localFilterService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-valueset-moving.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistValuesetMovingService {
  /**
   * @param {?} filterService
   * @param {?} stateService
   */
  constructor(filterService, stateService) {
    this.filterService = filterService;
    this.stateService = stateService;
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.stateService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.stateService.valueSetList;
  }
  /**
   * @param {?} optionsToMove
   * @param {?} pane
   * @param {?=} shouldBreakValuesets
   * @return {?}
   */
  moveOutValuesets(optionsToMove, pane, shouldBreakValuesets = false) {
    this.valueSetList.selectedOptions.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        v.showValues = false;
        optionsToMove.valueSets.set(v.code, v);
        this.valueSetList.options.delete(v.code);
      }
    );
    this.valueSetList.filteredOptions.forEach(
      /**
       * @param {?} valueset
       * @return {?}
       */
      (valueset) => {
        if (
          valueset.selected ||
          valueset.subValuesSelectList.selectedOptions.size < 1
        ) {
          return;
        }
        if (shouldBreakValuesets) {
          this.breakValueset(valueset, optionsToMove, pane.companion);
        } else {
          this.moveSubValues(
            valueset.subValuesSelectList.selectedOptions,
            pane
          );
        }
      }
    );
  }
  /**
   * @private
   * @param {?} valueset
   * @param {?} optionsToMove
   * @param {?} companionPane
   * @return {?}
   */
  breakValueset(valueset, optionsToMove, companionPane) {
    valueset.showValues = false;
    optionsToMove.valueSets.set(valueset.code, valueset);
    this.valueSetList.options.delete(valueset.code);
    /** @type {?} */
    const unselectedSubValues = new Map();
    valueset.subValuesSelectList.filteredOptions
      .filter(
        /**
         * @param {?} o
         * @return {?}
         */
        (o) => !o.selected
      )
      .forEach(
        /**
         * @param {?} o
         * @return {?}
         */
        (o) => {
          unselectedSubValues.set(
            o.code,
            new ValueListOption(o.option, o.code)
          );
        }
      );
    if (!companionPane) {
      return;
    }
    this.moveSubValues(unselectedSubValues, companionPane);
  }
  /**
   * @private
   * @param {?} valuesMap
   * @param {?} sourcePane
   * @return {?}
   */
  moveSubValues(valuesMap, sourcePane) {
    this.removeValuesFromPane(valuesMap, sourcePane);
    if (!sourcePane.companion) {
      return;
    }
    valuesMap.forEach(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => {
        // tslint:disable-next-line:no-non-null-assertion
        /** @type {?} */ (sourcePane.companion).valueList.options.set(
          o.code,
          new ValueListOption(o.option, o.code)
        );
      }
    );
  }
  /**
   * Handles complex logic for when one pane is paged, and we want to keep the "x of y" counts accurate without a round trip to the server
   * @private
   * @param {?} valuesMap
   * @param {?} pane
   * @return {?}
   */
  removeValuesFromPane(valuesMap, pane) {
    if (pane.isPaged) {
      // don't bother trying to remove values or decrement count for options that are already filtered out
      this.filterService.preFilterOptionsForRemoteMode(
        valuesMap,
        pane.valueList
      );
    }
    valuesMap.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        /** @type {?} */
        const optionDeleted = pane.valueList.options.delete(v.code);
        /** @type {?} */
        const optionAlreadyInCompanionList = pane.companion
          ? pane.companion.valueList.options.has(v.code)
          : false;
        if (!optionDeleted && pane.isPaged && !optionAlreadyInCompanionList) {
          pane.valueList.additionalRemoteOptions--;
        }
      }
    );
  }
}
PicklistValuesetMovingService.ɵfac = function PicklistValuesetMovingService_Factory(
  t
) {
  return new (t || PicklistValuesetMovingService)(
    ɵngcc0.ɵɵinject(PicklistFilterService),
    ɵngcc0.ɵɵinject(PicklistStateService)
  );
};
PicklistValuesetMovingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistValuesetMovingService,
  factory: PicklistValuesetMovingService.ɵfac,
});
/** @nocollapse */
PicklistValuesetMovingService.ctorParameters = () => [
  { type: PicklistFilterService },
  { type: PicklistStateService },
];
if (false) {
  /**
   * @type {?}
   * @private
   */
  PicklistValuesetMovingService.prototype.filterService;
  /**
   * @type {?}
   * @private
   */
  PicklistValuesetMovingService.prototype.stateService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Handles loading + moving items to/from list
 */
class PicklistService {
  /**
   * @param {?} workTracker
   * @param {?} filterService
   * @param {?} localFilterService
   * @param {?} valuesetMovingService
   * @param {?} stateService
   */
  constructor(
    workTracker,
    filterService,
    localFilterService,
    valuesetMovingService,
    stateService
  ) {
    this.workTracker = workTracker;
    this.filterService = filterService;
    this.localFilterService = localFilterService;
    this.valuesetMovingService = valuesetMovingService;
    this.stateService = stateService;
  }
  /**
   * @return {?}
   */
  get pane() {
    return this.stateService.pane;
  }
  /**
   * @return {?}
   */
  get picklist() {
    return this.stateService.picklist;
  }
  /**
   * @return {?}
   */
  get optionsSource() {
    return this.stateService.optionsSource;
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.stateService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.stateService.valueSetList;
  }
  /**
   * @return {?}
   */
  get totalValuesCount() {
    return this.valueList.options.size + this.valueList.additionalRemoteOptions;
  }
  /**
   * @return {?}
   */
  get totalValueSetsCount() {
    return (
      this.valueSetList.options.size + this.valueSetList.additionalRemoteOptions
    );
  }
  /**
   * @param {?} settings
   * @param {?} optionsSource
   * @param {?} pane
   * @return {?}
   */
  reset(settings, optionsSource, pane) {
    this.stateService.reset(settings, optionsSource, pane);
    this.filterService.reset();
    if (this.optionsSource.optionsAreLocal()) {
      this.stateService.updateValueList(this.optionsSource.values);
      this.stateService.updateValueSetList(this.optionsSource.valueSets);
      this.localFilterService.filter(
        this.valueList,
        this.filterService.searchTokens
      );
      this.localFilterService.filter(
        this.valueSetList,
        this.filterService.searchTokens
      );
    } else {
      /** @type {?} */
      const loading$ = this.workTracker.startObservable(
        /**
         * @return {?}
         */
        () => this.filterService.filterOptionsRemote()
      );
      this.valueList.loadingOptions = loading$;
      this.valueSetList.loadingOptions = loading$;
    }
  }
  /**
   * @param {?} listOptions
   * @return {?}
   */
  addOptions(listOptions) {
    if (!this.optionsSource.optionsAreLocal()) {
      this.filterService.preFilterOptionsForRemoteMode(
        listOptions.values,
        this.valueList
      );
      this.filterService.preFilterOptionsForRemoteMode(
        listOptions.valueSets,
        this.valueSetList
      );
    }
    listOptions.values.forEach(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => {
        this.valueList.options.set(o.code, o);
      }
    );
    listOptions.valueSets.forEach(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => {
        this.valueSetList.options.set(o.code, o);
      }
    );
    this.localFilterService.filter(
      this.valueList,
      this.filterService.searchTokens
    );
    this.localFilterService.filter(
      this.valueSetList,
      this.filterService.searchTokens
    );
    this.pane.selectNone();
  }
  /**
   * @param {?=} shouldBreakValuesets
   * @return {?}
   */
  moveOutSelectedOptions(shouldBreakValuesets = false) {
    /** @type {?} */
    let optionsToMove = new PicklistValueOptions();
    this.valueList.selectedOptions.forEach(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => {
        optionsToMove.values.set(o.code, o);
        this.valueList.options.delete(o.code);
      }
    );
    this.valuesetMovingService.moveOutValuesets(
      optionsToMove,
      this.pane,
      shouldBreakValuesets
    );
    this.localFilterService.filter(
      this.valueList,
      this.filterService.searchTokens
    );
    this.localFilterService.filter(
      this.valueSetList,
      this.filterService.searchTokens
    );
    this.pane.selectNone();
    return optionsToMove;
  }
  /**
   * @param {?} valueset
   * @return {?}
   */
  loadValuesForValueset(valueset) {
    valueset.loadingValues = true;
    if (!this.optionsSource.getValuesForValueset) {
      return;
    }
    this.optionsSource.getValuesForValueset(valueset.option.code).subscribe(
      /**
       * @param {?} values
       * @return {?}
       */
      (values) => {
        valueset.subValuesSelectList.filteredOptions.length = 0;
        values.forEach(
          /**
           * @param {?} v
           * @return {?}
           */
          (v) => {
            valueset.subValuesSelectList.filteredOptions.push(
              new ValueListOption(v, v.code)
            );
          }
        );
      },
      /**
       * @return {?}
       */ () => {
        console.warn("Unable to load values for valueset");
        valueset.showValues = false;
      },
      /**
       * @return {?}
       */ () => {
        valueset.loadingValues = false;
      }
    );
  }
}
PicklistService.ɵfac = function PicklistService_Factory(t) {
  return new (t || PicklistService)(
    ɵngcc0.ɵɵinject(WorkTrackerService),
    ɵngcc0.ɵɵinject(PicklistFilterService),
    ɵngcc0.ɵɵinject(PicklistFilterLocalService),
    ɵngcc0.ɵɵinject(PicklistValuesetMovingService),
    ɵngcc0.ɵɵinject(PicklistStateService)
  );
};
PicklistService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistService,
  factory: PicklistService.ɵfac,
});
/** @nocollapse */
PicklistService.ctorParameters = () => [
  { type: WorkTrackerService },
  { type: PicklistFilterService },
  { type: PicklistFilterLocalService },
  { type: PicklistValuesetMovingService },
  { type: PicklistStateService },
];
if (false) {
  /**
   * @type {?}
   * @private
   */
  PicklistService.prototype.workTracker;
  /**
   * @type {?}
   * @private
   */
  PicklistService.prototype.filterService;
  /**
   * @type {?}
   * @private
   */
  PicklistService.prototype.localFilterService;
  /**
   * @type {?}
   * @private
   */
  PicklistService.prototype.valuesetMovingService;
  /**
   * @type {?}
   * @private
   */
  PicklistService.prototype.stateService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/services/picklist-action.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistActionService {
  /**
   * @param {?} listService
   */
  constructor(listService) {
    this.listService = listService;
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.listService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.listService.valueSetList;
  }
  /**
   * @template T
   * @param {?} event
   * @param {?} index
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  onItemClicked(event, index, list, item) {
    if (
      event.shiftKey &&
      list.lastClickedOption &&
      !(item.code === list.lastClickedOption.code)
    ) {
      this.shiftClick(index, list, item, list.lastClickedOption);
    } else if (event.ctrlKey) {
      this.ctrlClick(list, item);
    } else {
      // regular click
      this.selectNone();
      this.selectItem(list, item);
      list.lastClickedOption = item;
    }
  }
  /**
   * @template T
   * @param {?} event
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  onItemDoubleClicked(event, list, item) {
    this.selectNone();
    this.selectItem(list, item);
  }
  /**
   * @param {?} event
   * @param {?} valueset
   * @return {?}
   */
  onValuesetCaretClicked(event, valueset) {
    if (
      !valueset.showValues &&
      valueset.subValuesSelectList.filteredOptions.length === 0
    ) {
      this.listService.loadValuesForValueset(valueset);
    }
    valueset.showValues = !valueset.showValues;
  }
  /**
   * @return {?}
   */
  selectAll() {
    this.valueSetList.filteredOptions.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        this.clearListSelection(v.subValuesSelectList);
      }
    ); // deselect sublist items
    this.selectAllInList(this.valueList);
    this.selectAllInList(this.valueSetList);
  }
  /**
   * @return {?}
   */
  selectNone() {
    this.valueSetList.filteredOptions.forEach(
      /**
       * @param {?} v
       * @return {?}
       */
      (v) => {
        this.clearListSelection(v.subValuesSelectList);
      }
    );
    this.clearListSelection(this.valueList);
    this.clearListSelection(this.valueSetList);
  }
  /**
   * @template T
   * @param {?} list
   * @return {?}
   */
  selectAllInList(list) {
    if (!list.isActive) {
      return;
    }
    list.selectedOptions.clear();
    list.lastClickedOption = null;
    list.filteredOptions.forEach(
      /**
       * @param {?} item
       * @return {?}
       */
      (item) => {
        item.selected = true;
        list.selectedOptions.set(item.code, item);
      }
    );
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @return {?}
   */
  clearListSelection(list) {
    list.selectedOptions.clear();
    list.lastClickedOption = null;
    list.filteredOptions.forEach(
      /**
       * @param {?} item
       * @return {?}
       */
      (item) => {
        item.selected = false;
      }
    );
  }
  /**
   * @private
   * @template T
   * @param {?} index
   * @param {?} list
   * @param {?} item
   * @param {?} lastClickedItem
   * @return {?}
   */
  shiftClick(index, list, item, lastClickedItem) {
    /** @type {?} */
    const lastIndex = list.filteredOptions.indexOf(lastClickedItem);
    /** @type {?} */
    let largeIndex = Math.max(index, lastIndex);
    /** @type {?} */
    let smallIndex = Math.min(index, lastIndex);
    /** @type {?} */
    const formerLastClicked = list.lastClickedOption;
    this.selectNone();
    list.lastClickedOption = formerLastClicked;
    for (let i = smallIndex; i <= largeIndex; i++) {
      this.selectItem(list, list.filteredOptions[i]);
    }
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  ctrlClick(list, item) {
    // if ctrl clicking a sub value of a valueset that is selected (such that all subvalues appear selected)
    if (isSubList(list) && list.parentValueSet.selected) {
      this.selectAllInList(list);
      this.deselectItem(this.valueSetList, list.parentValueSet);
      this.deselectItem(list, item);
    } else {
      this.toggleItemSelection(list, item);
    }
    list.lastClickedOption = item;
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  deselectItem(list, item) {
    item.selected = false;
    list.selectedOptions.delete(item.code);
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  selectItem(list, item) {
    item.selected = true;
    list.selectedOptions.set(item.code, item);
  }
  /**
   * @private
   * @template T
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  toggleItemSelection(list, item) {
    if (item.selected) {
      this.deselectItem(list, item);
    } else {
      this.selectItem(list, item);
    }
  }
}
PicklistActionService.ɵfac = function PicklistActionService_Factory(t) {
  return new (t || PicklistActionService)(ɵngcc0.ɵɵinject(PicklistService));
};
PicklistActionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: PicklistActionService,
  factory: PicklistActionService.ɵfac,
});
/** @nocollapse */
PicklistActionService.ctorParameters = () => [{ type: PicklistService }];
if (false) {
  /**
   * @type {?}
   * @private
   */
  PicklistActionService.prototype.listService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/pane/picklist-pane.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistPaneComponent {
  /**
   * @param {?} listService
   * @param {?} actionService
   * @param {?} filterService
   */
  constructor(listService, actionService, filterService) {
    this.listService = listService;
    this.actionService = actionService;
    this.filterService = filterService;
    this.emptyMsg = "No options";
    this.moveSelectedItems = new EventEmitter();
    this.companion = null;
    this.shouldExcludeCompanion = false;
    this.codeIsSignificant = false;
    this.searchTerm = "";
    this.searchTermStream = new Subject();
    this.selectAllWasLastClicked = false;
    this.selectAllLimit = 2000;
  }
  /**
   * @param {?} source
   * @param {?} settings
   * @param {?} companion
   * @param {?=} excludeCompanion
   * @return {?}
   */
  reset(source, settings, companion, excludeCompanion = false) {
    this.companion = companion;
    this.shouldExcludeCompanion = excludeCompanion;
    this.codeIsSignificant = settings.codeIsSignificant;
    this.selectAllWasLastClicked = false;
    this.searchTerm = "";
    this.wireUpSearch();
    this.listService.reset(settings, source, this);
  }
  /**
   * @return {?}
   */
  get valueList() {
    return this.listService.valueList;
  }
  /**
   * @return {?}
   */
  get valueSetList() {
    return this.listService.valueSetList;
  }
  /**
   * @return {?}
   */
  get isPaged() {
    return this.listService.optionsSource.isPaged;
  }
  /**
   * @return {?}
   */
  get optionsAvailableCount() {
    return this.PicklistValueOptionsTotal + this.valueSetOptionsTotal;
  }
  /**
   * @return {?}
   */
  get PicklistValueOptionsTotal() {
    return this.valueList.isActive ? this.listService.totalValuesCount : 0;
  }
  /**
   * @return {?}
   */
  get valueSetOptionsTotal() {
    return this.valueSetList.isActive
      ? this.listService.totalValueSetsCount
      : 0;
  }
  /**
   * @return {?}
   */
  get optionsShowingCount() {
    /** @type {?} */
    const valueListShowing = this.valueList.isActive
      ? this.valueList.filteredOptions.length
      : 0;
    /** @type {?} */
    const valueSetListShowing = this.valueSetList.isActive
      ? this.valueSetList.filteredOptions.length
      : 0;
    return valueListShowing + valueSetListShowing;
  }
  /**
   * @return {?}
   */
  get showTooManyToSelectAllMsg() {
    /** @type {?} */
    const serverMatches = this.valueList.additionalRemoteOptions;
    return (
      this.selectAllWasLastClicked &&
      Number.isFinite(serverMatches) &&
      serverMatches + this.valueList.options.size > this.selectAllLimit
    );
  }
  /**
   * @template T
   * @param {?} list
   * @return {?}
   */
  shouldShowList(list) {
    return (
      list.isActive &&
      (list.filteredOptions.length > 0 || list.additionalRemoteOptions > 0)
    );
  }
  /**
   * @template T
   * @param {?} list
   * @return {?}
   */
  listIsFilteredToEmpty(list) {
    return (
      list.options.size > 0 &&
      list.filteredOptions.length === 0 &&
      list.isActive
    );
  }
  /**
   * @return {?}
   */
  isAnySelected() {
    /** @type {?} */
    const topLevelListHasSelection =
      this.valueList.selectedOptions.size > 0 ||
      this.valueSetList.selectedOptions.size > 0;
    /** @type {?} */
    const subListHasSelection = this.valueSetList.filteredOptions.some(
      /**
       * @param {?} o
       * @return {?}
       */
      (o) => o.subValuesSelectList.selectedOptions.size > 0
    );
    return topLevelListHasSelection || subListHasSelection;
  }
  /**
   * @return {?}
   */
  focusSearch() {
    if (this.searchInputEl) {
      this.searchInputEl.nativeElement.focus();
    }
  }
  /**
   * @return {?}
   */
  scrollToTop() {
    if (this.listContainerEl) {
      this.listContainerEl.nativeElement.scrollTop = 0;
    }
  }
  /**
   * @return {?}
   */
  onSearchKeyup() {
    this.selectNone();
    this.searchTermStream.next(this.searchTerm);
  }
  /**
   * @template T
   * @param {?} event
   * @param {?} index
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  onItemClicked(event, index, list, item) {
    this.selectAllWasLastClicked = false;
    event.stopPropagation();
    this.actionService.onItemClicked(event, index, list, item);
  }
  /**
   * @return {?}
   */
  preventIEHighlightBug() {
    // for IE: https://stackoverflow.com/questions/1527751/disable-text-selection-while-pressing-shift
    /** @type {?} */ (document).onselectstart =
      /**
       * @return {?}
       */
      function () {
        return false;
      };
    setTimeout(
      /**
       * @return {?}
       */
      function () {
        /** @type {?} */ (document).onselectstart =
          /**
           * @return {?}
           */
          () => null;
      },
      0
    );
  }
  /**
   * @param {?} event
   * @param {?} valueset
   * @return {?}
   */
  onValuesetCaretClicked(event, valueset) {
    this.selectAllWasLastClicked = false;
    event.stopPropagation();
    this.actionService.onValuesetCaretClicked(event, valueset);
  }
  /**
   * @param {?} type
   * @return {?}
   */
  triggerLoadMore(type) {
    this.selectAllWasLastClicked = false;
    this.filterService.loadMore(type);
  }
  /**
   * @template T
   * @param {?} event
   * @param {?} list
   * @param {?} item
   * @return {?}
   */
  onItemDoubleClicked(event, list, item) {
    this.selectAllWasLastClicked = false;
    event.stopPropagation();
    this.actionService.onItemDoubleClicked(event, list, item);
    this.moveSelectedItems.emit(this);
  }
  /**
   * @return {?}
   */
  selectAll() {
    this.selectAllWasLastClicked = true;
    /** @type {?} */
    const shouldLoadMoreBeforeSelectAll =
      this.valueList.additionalRemoteOptions &&
      this.valueList.options.size < this.selectAllLimit;
    if (this.pagingValueList() && shouldLoadMoreBeforeSelectAll) {
      /** @type {?} */
      const totalMatches =
        this.valueList.additionalRemoteOptions + this.valueList.options.size;
      /** @type {?} */
      const numberToLoad =
        totalMatches > this.selectAllLimit ? this.selectAllLimit : totalMatches;
      this.loadAndSelectAll(numberToLoad);
    } else {
      this.actionService.selectAll();
    }
  }
  /**
   * @return {?}
   */
  selectNone() {
    this.selectAllWasLastClicked = false;
    this.actionService.selectNone();
  }
  /**
   * @private
   * @param {?} numberToLoad
   * @return {?}
   */
  loadAndSelectAll(numberToLoad) {
    this.filterService.loadForSelectAll(numberToLoad).subscribe(
      /**
       * @return {?}
       */
      () => {
        this.actionService.selectAllInList(this.valueList);
      }
    );
  }
  /**
   * @private
   * @return {?}
   */
  pagingValueList() {
    return (
      this.isPaged &&
      this.shouldShowList(this.valueList) &&
      !this.shouldShowList(this.valueSetList)
    );
  }
  /**
   * @private
   * @return {?}
   */
  wireUpSearch() {
    this.searchTermStream
      .pipe(debounceTime(300), distinctUntilChanged())
      .subscribe(
        /**
         * @param {?} t
         * @return {?}
         */
        (t) => {
          this.filterService.runFilter(t);
          this.selectNone();
        }
      );
  }
}
PicklistPaneComponent.ɵfac = function PicklistPaneComponent_Factory(t) {
  return new (t || PicklistPaneComponent)(
    ɵngcc0.ɵɵdirectiveInject(PicklistService),
    ɵngcc0.ɵɵdirectiveInject(PicklistActionService),
    ɵngcc0.ɵɵdirectiveInject(PicklistFilterService)
  );
};
PicklistPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: PicklistPaneComponent,
  selectors: [["hc-picklist-pane"]],
  viewQuery: function PicklistPaneComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c54, true);
      ɵngcc0.ɵɵviewQuery(_c55, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.listContainerEl = _t.first);
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.searchInputEl = _t.first);
    }
  },
  inputs: { emptyMsg: "emptyMsg" },
  outputs: { moveSelectedItems: "moveSelectedItems" },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      PicklistService,
      PicklistStateService,
      PicklistValuesetMovingService,
      PicklistActionService,
      PicklistFilterService,
      PicklistFilterRemoteService,
      PicklistFilterLocalService,
      WorkTrackerService,
    ]),
  ],
  decls: 27,
  vars: 22,
  consts: [
    [1, "hc-picklist-pane"],
    [1, "picklist-controls"],
    [
      "hcInput",
      "",
      "type",
      "text",
      "placeholder",
      "Search",
      3,
      "ngModel",
      "keyup",
      "ngModelChange",
    ],
    ["searchInput", ""],
    ["hcSuffix", "", "fontSet", "fa", "fontIcon", "fa-search"],
    [1, "second-row-controls"],
    [1, "hc-type-em"],
    ["type", "button", 1, "btn-text-link", 3, "disabled", "click"],
    [1, "list-container"],
    ["listContainer", ""],
    ["class", "loading-list", 4, "ngIf"],
    ["class", "hc-table hc-table-small valueset-table", 4, "ngIf"],
    ["class", "hc-table hc-table-small", 3, "ngClass", 4, "ngIf"],
    ["class", "empty-table-msg hc-type-em", 4, "ngIf"],
    [1, "loading-list"],
    [1, "hc-table", "hc-table-small", "valueset-table"],
    [4, "ngIf"],
    [
      "class",
      "valueset-option value-option-row",
      3,
      "ngClass",
      "mousedown",
      "click",
      "dblclick",
      4,
      "ngFor",
      "ngForOf",
    ],
    ["class", "text-center value-option-row load-more-row", 4, "ngIf"],
    ["colspan", "2"],
    [
      1,
      "valueset-option",
      "value-option-row",
      3,
      "ngClass",
      "mousedown",
      "click",
      "dblclick",
    ],
    [1, "valueset-value-toggle", 3, "click"],
    [
      "hcIconSm",
      "",
      "fontSet",
      "fa",
      "fontIcon",
      "fa-caret-right",
      1,
      "values-caret",
      3,
      "ngClass",
    ],
    ["hcIconSm", "", "fontSet", "fa", 1, "vs-folder", 3, "fontIcon"],
    [1, "vs-title"],
    ["class", "valueset-sublist-table hc-table", 4, "ngIf"],
    [1, "valueset-sublist-table", "hc-table"],
    ["class", "loading-subvals", 4, "ngIf"],
    [
      "class",
      "value-option-row hc-tr",
      3,
      "ngClass",
      "mousedown",
      "click",
      "dblclick",
      4,
      "ngFor",
      "ngForOf",
    ],
    [1, "loading-subvals"],
    [
      1,
      "value-option-row",
      "hc-tr",
      3,
      "ngClass",
      "mousedown",
      "click",
      "dblclick",
    ],
    ["class", "valueset-code", 4, "ngIf"],
    [1, "valueset-code"],
    [1, "text-center", "value-option-row", "load-more-row"],
    ["class", "load-more-link text-link", 3, "click", 4, "ngIf"],
    [1, "load-more-link", "text-link", 3, "click"],
    [1, "hc-table", "hc-table-small", 3, "ngClass"],
    ["class", "value-option-row select-all-matches-row", 4, "ngIf"],
    [
      "class",
      "value-option-row",
      3,
      "ngClass",
      "mousedown",
      "click",
      "dblclick",
      4,
      "ngFor",
      "ngForOf",
    ],
    [1, "value-option-row", "select-all-matches-row"],
    [1, "hc-type-bold"],
    [1, "value-option-row", 3, "ngClass", "mousedown", "click", "dblclick"],
    ["class", "col-code", 4, "ngIf"],
    [1, "col-title"],
    [1, "col-code"],
    [1, "empty-table-msg", "hc-type-em"],
    [4, "ngIf", "ngIfElse"],
    ["emptyMessage", ""],
  ],
  template: function PicklistPaneComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵelementStart(2, "hc-form-field");
      ɵngcc0.ɵɵelementStart(3, "input", 2, 3);
      ɵngcc0.ɵɵlistener(
        "keyup",
        function PicklistPaneComponent_Template_input_keyup_3_listener() {
          return ctx.onSearchKeyup();
        }
      )(
        "ngModelChange",
        function PicklistPaneComponent_Template_input_ngModelChange_3_listener(
          $event
        ) {
          return (ctx.searchTerm = $event);
        }
      );
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelement(5, "hc-icon", 4);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(6, "div", 5);
      ɵngcc0.ɵɵelementStart(7, "div", 6);
      ɵngcc0.ɵɵtext(8);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(9, "div");
      ɵngcc0.ɵɵelementStart(10, "button", 7);
      ɵngcc0.ɵɵlistener(
        "click",
        function PicklistPaneComponent_Template_button_click_10_listener() {
          return ctx.selectAll();
        }
      );
      ɵngcc0.ɵɵtext(11, " Select All ");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(12, "button", 7);
      ɵngcc0.ɵɵlistener(
        "click",
        function PicklistPaneComponent_Template_button_click_12_listener() {
          return ctx.selectNone();
        }
      );
      ɵngcc0.ɵɵtext(13, " Select None ");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementStart(14, "div", 8, 9);
      ɵngcc0.ɵɵtemplate(
        16,
        PicklistPaneComponent_div_16_Template,
        2,
        0,
        "div",
        10
      );
      ɵngcc0.ɵɵpipe(17, "async");
      ɵngcc0.ɵɵtemplate(
        18,
        PicklistPaneComponent_table_18_Template,
        5,
        3,
        "table",
        11
      );
      ɵngcc0.ɵɵpipe(19, "async");
      ɵngcc0.ɵɵtemplate(
        20,
        PicklistPaneComponent_div_20_Template,
        2,
        0,
        "div",
        10
      );
      ɵngcc0.ɵɵpipe(21, "async");
      ɵngcc0.ɵɵtemplate(
        22,
        PicklistPaneComponent_table_22_Template,
        6,
        7,
        "table",
        12
      );
      ɵngcc0.ɵɵpipe(23, "async");
      ɵngcc0.ɵɵtemplate(
        24,
        PicklistPaneComponent_div_24_Template,
        5,
        2,
        "div",
        13
      );
      ɵngcc0.ɵɵpipe(25, "async");
      ɵngcc0.ɵɵpipe(26, "async");
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngModel", ctx.searchTerm);
      ɵngcc0.ɵɵadvance(5);
      ɵngcc0.ɵɵtextInterpolate2(
        " Showing ",
        ctx.optionsShowingCount.toLocaleString(),
        " of ",
        ctx.optionsAvailableCount.toLocaleString(),
        " "
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "disabled",
        ctx.valueList.filteredOptions.length === 0 &&
          ctx.valueSetList.filteredOptions.length === 0
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("disabled", !ctx.isAnySelected());
      ɵngcc0.ɵɵadvance(4);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        ctx.valueSetList.isActive &&
          ɵngcc0.ɵɵpipeBind1(17, 10, ctx.valueSetList.loadingOptions)
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        ctx.shouldShowList(ctx.valueSetList) &&
          !ɵngcc0.ɵɵpipeBind1(19, 12, ctx.valueSetList.loadingOptions)
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        ctx.valueList.isActive &&
          ɵngcc0.ɵɵpipeBind1(21, 14, ctx.valueList.loadingOptions)
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        ctx.shouldShowList(ctx.valueList) &&
          !ɵngcc0.ɵɵpipeBind1(23, 16, ctx.valueList.loadingOptions)
      );
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty(
        "ngIf",
        !ctx.shouldShowList(ctx.valueSetList) &&
          !ctx.shouldShowList(ctx.valueList) &&
          !ɵngcc0.ɵɵpipeBind1(25, 18, ctx.valueList.loadingOptions) &&
          !ɵngcc0.ɵɵpipeBind1(26, 20, ctx.valueSetList.loadingOptions)
      );
    }
  },
  directives: [
    HcFormFieldComponent,
    ɵngcc7.DefaultValueAccessor,
    InputDirective,
    ɵngcc7.NgControlStatus,
    ɵngcc7.NgModel,
    IconComponent,
    HcSuffixDirective,
    ɵngcc1.NgIf,
    ProgressDotsComponent,
    ɵngcc1.NgForOf,
    ɵngcc1.NgClass,
    HcIconSmallDirective,
  ],
  pipes: [ɵngcc1.AsyncPipe],
  styles: [
    ".hc-picklist-pane{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;height:100%}.hc-picklist-pane .hc-form-field-wrapper{border:none;padding-bottom:0}.hc-picklist-pane .picklist-controls{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;font-size:12px}.hc-picklist-pane .second-row-controls{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:15px 0 2px}.hc-picklist-pane .picklist-controls button{font-family:'Open Sans',sans-serif;margin-left:10px}.hc-picklist-pane .picklist-controls .btn-text-link{background:0 0;border:none;color:#00aeff;cursor:pointer;font-size:12px;padding:0;text-align:left}.hc-picklist-pane .picklist-controls .btn-text-link:active{box-shadow:none;color:#008bcc;outline:0;text-decoration:underline}.hc-picklist-pane .picklist-controls .btn-text-link:hover{color:#009de6;text-decoration:underline}.hc-picklist-pane .picklist-controls .btn-text-link[disabled]{color:#c0c5cc;cursor:default;opacity:1;text-decoration:none}.hc-picklist-pane .loading-list{border:1px solid #d7dde4;height:100%}.hc-picklist-pane .list-container{background-color:#fff;border:1px solid #d7dde4;-webkit-box-flex:1;flex:1 1 300px;overflow-y:scroll;position:relative}.hc-picklist-pane .hc-table th{background-color:#e0e6ec;border-bottom:1px solid #d0dae3;border-top:1px solid #d0dae3;font-size:12px;font-style:italic;font-weight:400}.hc-picklist-pane .hc-table tbody{border:0}.hc-picklist-pane .hc-table .select-all-matches-row{background-color:#f9efce;border-color:#fff;color:#846b11;text-align:center}.hc-picklist-pane .hc-table .load-more-row{display:block;font-size:12px;font-weight:700;height:36px;padding:11px;text-align:center}.hc-picklist-pane .hc-table .load-more-link{cursor:pointer}.hc-picklist-pane .hc-table .col-code{width:20%;word-break:normal}.hc-picklist-pane .hc-table .valueset-table{display:block;width:100%}.hc-picklist-pane .hc-table .value-option-row{cursor:default;font-weight:400;line-height:1.1;user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.hc-picklist-pane .hc-table .valueset-value-toggle{color:#00aeff;cursor:pointer;-webkit-transform:color .2s;transform:color .2s}.hc-picklist-pane .hc-table .valueset-value-toggle:hover{color:#006899}.hc-picklist-pane .hc-table .values-caret:before{display:inline-block;font-size:13px;position:relative;top:-1px;-webkit-transition:-webkit-transform .2s;transition:transform .2s;transition:transform .2s,-webkit-transform .2s}.hc-picklist-pane .hc-table .values-caret-showing-values:before{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.hc-picklist-pane .hc-table .selected .values-caret{color:#fff}.hc-picklist-pane .hc-table .vs-folder{left:-3px;position:relative}.hc-picklist-pane .hc-table .selected .vs-folder{color:#fff}.hc-picklist-pane .hc-table .loading-subvals{height:40px}.hc-picklist-pane .hc-table .valueset-sublist-table{border:1px solid #d7dfe7;border-collapse:separate;border-radius:3px;font-size:13px;margin:10px 0 20px;overflow:hidden}.hc-picklist-pane .hc-table .valueset-code{margin-right:5px}.hc-picklist-pane .empty-table-msg{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;height:100%;-webkit-box-pack:center;justify-content:center;position:absolute;width:100%}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
PicklistPaneComponent.ctorParameters = () => [
  { type: PicklistService },
  { type: PicklistActionService },
  { type: PicklistFilterService },
];
PicklistPaneComponent.propDecorators = {
  emptyMsg: [{ type: Input }],
  moveSelectedItems: [{ type: Output }],
  listContainerEl: [
    { type: ViewChild, args: ["listContainer", { static: false }] },
  ],
  searchInputEl: [{ type: ViewChild, args: ["search", { static: false }] }],
};
if (false) {
  /** @type {?} */
  PicklistPaneComponent.prototype.emptyMsg;
  /** @type {?} */
  PicklistPaneComponent.prototype.moveSelectedItems;
  /** @type {?} */
  PicklistPaneComponent.prototype.listContainerEl;
  /** @type {?} */
  PicklistPaneComponent.prototype.searchInputEl;
  /** @type {?} */
  PicklistPaneComponent.prototype.companion;
  /** @type {?} */
  PicklistPaneComponent.prototype.shouldExcludeCompanion;
  /** @type {?} */
  PicklistPaneComponent.prototype.codeIsSignificant;
  /** @type {?} */
  PicklistPaneComponent.prototype.searchTerm;
  /** @type {?} */
  PicklistPaneComponent.prototype.searchTermStream;
  /** @type {?} */
  PicklistPaneComponent.prototype.selectAllWasLastClicked;
  /** @type {?} */
  PicklistPaneComponent.prototype.selectAllLimit;
  /** @type {?} */
  PicklistPaneComponent.prototype.listService;
  /** @type {?} */
  PicklistPaneComponent.prototype.actionService;
  /** @type {?} */
  PicklistPaneComponent.prototype.filterService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/picklist.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PicklistModule {}
PicklistModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PicklistModule });
PicklistModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function PicklistModule_Factory(t) {
    return new (t || PicklistModule)();
  },
  imports: [
    [
      CommonModule,
      FormsModule,
      ButtonModule,
      IconModule,
      InputModule,
      FormFieldModule,
      ProgressIndicatorsModule,
    ],
  ],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/picklist/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pop/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/progress-indicators/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/radio-button/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/nav/scroll-nav-link.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Marks the host element as a link within an `hc-scroll-nav`.
 */
class ScrollNavLinkDirective {
  /**
   * @param {?} _el
   */
  constructor(_el) {
    this._el = _el;
    this._hostClass = true;
    this._hostIndex = 0;
  }
  /**
   * @return {?}
   */
  _onEnter() {
    this.navigateToSection(this.hcScrollLink);
  }
  /**
   * @return {?}
   */
  _onClick() {
    this.navigateToSection(this.hcScrollLink);
  }
  /**
   * @private
   * @param {?} id
   * @return {?}
   */
  navigateToSection(id) {
    /** @type {?} */
    const el = document.getElementById(id);
    if (!el) {
      throw new Error(
        `Failed to navigate. Could not find the element with the id: ${id}.`
      );
    } else {
      el.scrollIntoView();
    }
  }
}
ScrollNavLinkDirective.ɵfac = function ScrollNavLinkDirective_Factory(t) {
  return new (t || ScrollNavLinkDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
ScrollNavLinkDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: ScrollNavLinkDirective,
  selectors: [["", "hcScrollLink", ""]],
  hostVars: 3,
  hostBindings: function ScrollNavLinkDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "keydown.enter",
        function ScrollNavLinkDirective_keydown_enter_HostBindingHandler() {
          return ctx._onEnter();
        }
      )("click", function ScrollNavLinkDirective_click_HostBindingHandler() {
        return ctx._onClick();
      });
    }
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("tabindex", ctx._hostIndex);
      ɵngcc0.ɵɵclassProp("hc-scroll-nav-link", ctx._hostClass);
    }
  },
  inputs: { hcScrollLink: "hcScrollLink" },
});
/** @nocollapse */
ScrollNavLinkDirective.ctorParameters = () => [{ type: ElementRef }];
ScrollNavLinkDirective.propDecorators = {
  hcScrollLink: [{ type: Input }],
  _hostClass: [{ type: HostBinding, args: ["class.hc-scroll-nav-link"] }],
  _hostIndex: [{ type: HostBinding, args: ["attr.tabindex"] }],
  _onEnter: [{ type: HostListener, args: ["keydown.enter"] }],
  _onClick: [{ type: HostListener, args: ["click"] }],
};
if (false) {
  /**
   * The `id` of the corresponding `hcScrollTarget` that you would like to link to.
   * @type {?}
   */
  ScrollNavLinkDirective.prototype.hcScrollLink;
  /** @type {?} */
  ScrollNavLinkDirective.prototype._hostClass;
  /** @type {?} */
  ScrollNavLinkDirective.prototype._hostIndex;
  /** @type {?} */
  ScrollNavLinkDirective.prototype._el;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/nav/scroll-nav.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container for scroll navigation links.
 */
class HcScrollNavComponent {
  /**
   * @param {?} _elementRef
   */
  constructor(_elementRef) {
    this._elementRef = _elementRef;
    this.ACTIVE_CLASS = "hc-scroll-nav-link-active";
  }
  /**
   * @return {?}
   */
  get _links() {
    return this.linkList.toArray().map(
      /**
       * @param {?} e
       * @return {?}
       */
      (e) => e._el.nativeElement
    );
  }
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    if (this._links && this._links[0]) {
      this._links[0].classList.add(this.ACTIVE_CLASS);
    }
  }
  /**
   * @param {?} id
   * @return {?}
   */
  _setActiveClassById(id) {
    /** @type {?} */
    const link = this.linkList.find(
      /**
       * @param {?} e
       * @return {?}
       */
      (e) => e.hcScrollLink === id
    );
    if (!link) {
      throw new Error(
        `Failed to mark active class. Could not find the element with the data target for id: ${id}.`
      );
    }
    this.setActiveClass(link._el.nativeElement);
  }
  /**
   * @private
   * @param {?} element
   * @return {?}
   */
  setActiveClass(element) {
    this._links.forEach(
      /**
       * @param {?} e
       * @return {?}
       */
      (e) => {
        e.classList.remove(this.ACTIVE_CLASS);
      }
    );
    element.classList.add(this.ACTIVE_CLASS);
  }
}
HcScrollNavComponent.ɵfac = function HcScrollNavComponent_Factory(t) {
  return new (t || HcScrollNavComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
HcScrollNavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcScrollNavComponent,
  selectors: [["hc-scroll-nav"]],
  contentQueries: function HcScrollNavComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, ScrollNavLinkDirective, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx.linkList = _t);
    }
  },
  ngContentSelectors: _c3,
  decls: 2,
  vars: 0,
  consts: [[1, "hc-scroll-nav-links-container"]],
  template: function HcScrollNavComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵprojection(1);
      ɵngcc0.ɵɵelementEnd();
    }
  },
  styles: [
    ".hc-scroll-nav-links-container{margin-right:30px}.hc-scroll-nav-links-container ul{list-style:none}.hc-scroll-nav-link{font-size:1rem;background-color:transparent;color:#333;cursor:pointer;font-weight:500;padding:10px 15px}.hc-scroll-nav-link:hover{background-color:rgba(215,221,228,.25)}.hc-scroll-nav-link:active{background-color:rgba(215,221,228,.5)}.hc-scroll-nav-link:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-scroll-nav-link-active,.hc-scroll-nav-link-active:hover{background-color:#00aeff;color:#fff;font-weight:500}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
HcScrollNavComponent.ctorParameters = () => [{ type: ElementRef }];
HcScrollNavComponent.propDecorators = {
  linkList: [
    {
      type: ContentChildren,
      args: [ScrollNavLinkDirective, { descendants: true }],
    },
  ],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcScrollNavComponent.prototype.linkList;
  /**
   * @type {?}
   * @private
   */
  HcScrollNavComponent.prototype.ACTIVE_CLASS;
  /** @type {?} */
  HcScrollNavComponent.prototype._elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/content/scroll-nav-target.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Marks the host element as a linkable section within an `hc-scroll-nav-content`.
 * Must set the `id` and link to it via an `hcScrollLink`.
 */
class ScrollNavTargetDirective {
  /**
   * @param {?} _el
   */
  constructor(_el) {
    this._el = _el;
    this._hostClass = true;
  }
}
ScrollNavTargetDirective.ɵfac = function ScrollNavTargetDirective_Factory(t) {
  return new (t || ScrollNavTargetDirective)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
ScrollNavTargetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: ScrollNavTargetDirective,
  selectors: [["", "hcScrollTarget", ""]],
  hostVars: 2,
  hostBindings: function ScrollNavTargetDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-scroll-nav-target", ctx._hostClass);
    }
  },
});
/** @nocollapse */
ScrollNavTargetDirective.ctorParameters = () => [{ type: ElementRef }];
ScrollNavTargetDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-scroll-nav-target"] }],
};
if (false) {
  /** @type {?} */
  ScrollNavTargetDirective.prototype._hostClass;
  /** @type {?} */
  ScrollNavTargetDirective.prototype._el;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/content/scroll-nav-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Contains scrollable content that is navigable via `hc-scroll-nav` links.
 */
class HcScrollNavContentComponent {
  constructor() {
    this.DEFAULT_BUFFER = 40;
    /**
     * If true, will force the height of the final scroll target area to be the height of the scrollable container.
     * This is helpful if you want the last target in the content area to be able to scroll to the top. You can alternatively
     * target the last item with css. *Defaults to true.*
     */
    this.makeLastTargetFullHeight = true;
    /**
     * Number in pixels, used to give a little leeway in the shifting of the active nav when scrolling. *Defaults to 40.*
     * Example: Left at default, if showing just the bottom 40 pixels of the section before, count the next section as active.
     */
    this.bufferSpace = this.DEFAULT_BUFFER;
    /**
     * If true, applies smooth scrolling via css. *Defaults to true.*
     */
    this.shouldAnimateScroll = true;
    /**
     * Fires when a new section is scrolled into view. Broadcasts the id of that section.
     */
    this.newSectionInView = new EventEmitter();
    this.unsubscribe$ = new Subject();
    this.minHeightForLastTargetSet = false;
  }
  /**
   * @return {?}
   */
  get _scrollTargets() {
    return this.targets.toArray().map(
      /**
       * @param {?} t
       * @return {?}
       */
      (t) => t._el.nativeElement
    );
  }
  /**
   * @return {?}
   */
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  /**
   * @return {?}
   */
  ngAfterViewInit() {
    if (this._cdkScrollableElement) {
      this._cdkScrollableElement
        .elementScrolled()
        .pipe(takeUntil(this.unsubscribe$))
        .subscribe(
          /**
           * @return {?}
           */
          () => {
            this.checkActiveSection();
          }
        );
    }
  }
  /**
   * @return {?}
   */
  ngAfterViewChecked() {
    if (this.makeLastTargetFullHeight && !this.minHeightForLastTargetSet) {
      this.insureMinHeightForLastTarget();
    }
  }
  /**
   * @return {?}
   */
  _onWindowResize() {
    if (this.makeLastTargetFullHeight) {
      this.minHeightForLastTargetSet = false;
    }
  }
  /**
   * Scroll to top and reset the "automatic full height for the last item" setting.
   * @return {?}
   */
  refresh() {
    this.scrollToTop();
    this.minHeightForLastTargetSet = false;
  }
  /**
   * Helper function to scroll to the top of the content area.
   * @return {?}
   */
  scrollToTop() {
    this._cdkScrollableElement.scrollTo({ top: 0 });
  }
  /**
   * Will update the navigation state.
   * @return {?}
   */
  checkActiveSection() {
    /** @type {?} */
    let offset =
      this._cdkScrollableElement.measureScrollOffset("top") +
      this._scrollTargets[0].offsetTop;
    this._scrollTargets.forEach(
      /**
       * @param {?} t
       * @param {?} index
       * @return {?}
       */
      (t, index) => {
        /** @type {?} */
        const el = t;
        /** @type {?} */
        let initialOffset = 0;
        /** @type {?} */
        let nextOffset = 0;
        if (index > 0) {
          initialOffset = el.offsetTop - this.bufferSpace;
        }
        if (index + 1 < this._scrollTargets.length) {
          /** @type {?} */
          const nextEl = this._scrollTargets[index + 1];
          nextOffset = nextEl.offsetTop;
        }
        if (
          (initialOffset &&
            nextOffset &&
            offset >= initialOffset &&
            offset < nextOffset) ||
          (initialOffset && !nextOffset && offset >= initialOffset) ||
          (!initialOffset && nextOffset && offset < nextOffset)
        ) {
          this.setActiveClass(el.getAttribute("id") || "");
        }
      }
    );
  }
  /**
   * @private
   * @return {?}
   */
  insureMinHeightForLastTarget() {
    /** @type {?} */
    const containerHeight = this._cdkScrollableElement.getElementRef()
      .nativeElement.offsetHeight;
    if (containerHeight && this._scrollTargets.length > 0) {
      /** @type {?} */
      const targetEl = this._scrollTargets[this._scrollTargets.length - 1];
      targetEl.style.minHeight = `${containerHeight + 50}px`;
      this.minHeightForLastTargetSet = true;
    }
  }
  /**
   * @private
   * @param {?} scrollTarget
   * @return {?}
   */
  setActiveClass(scrollTarget) {
    if (this.sectionInView !== scrollTarget) {
      this.sectionInView = scrollTarget;
      this.nav._setActiveClassById(scrollTarget);
      this.newSectionInView.next(scrollTarget);
    }
  }
}
HcScrollNavContentComponent.ɵfac = function HcScrollNavContentComponent_Factory(
  t
) {
  return new (t || HcScrollNavContentComponent)();
};
HcScrollNavContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcScrollNavContentComponent,
  selectors: [["hc-scroll-nav-content"]],
  contentQueries: function HcScrollNavContentComponent_ContentQueries(
    rf,
    ctx,
    dirIndex
  ) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, ScrollNavTargetDirective, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx.targets = _t);
    }
  },
  viewQuery: function HcScrollNavContentComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c60, true, CdkScrollable);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._cdkScrollableElement = _t.first);
    }
  },
  hostBindings: function HcScrollNavContentComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "resize",
        function HcScrollNavContentComponent_resize_HostBindingHandler() {
          return ctx._onWindowResize();
        },
        false,
        ɵngcc0.ɵɵresolveWindow
      );
    }
  },
  inputs: {
    makeLastTargetFullHeight: "makeLastTargetFullHeight",
    bufferSpace: "bufferSpace",
    shouldAnimateScroll: "shouldAnimateScroll",
    nav: "nav",
  },
  outputs: { newSectionInView: "newSectionInView" },
  ngContentSelectors: _c3,
  decls: 3,
  vars: 3,
  consts: [
    ["cdk-scrollable", "", 1, "hc-scroll-nav-content-container", 3, "ngClass"],
    ["scrollContainer", ""],
  ],
  template: function HcScrollNavContentComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(1, _c61, ctx.shouldAnimateScroll)
      );
    }
  },
  directives: [ɵngcc10.CdkScrollable, ɵngcc1.NgClass],
  styles: [
    ".hc-scroll-nav-content-container{max-height:100%;overflow:scroll;overflow-x:hidden;width:100%}.hc-scroll-nav-smooth{scroll-behavior:smooth}",
  ],
  encapsulation: 2,
});
HcScrollNavContentComponent.propDecorators = {
  nav: [{ type: Input }],
  makeLastTargetFullHeight: [{ type: Input }],
  bufferSpace: [{ type: Input }],
  shouldAnimateScroll: [{ type: Input }],
  newSectionInView: [{ type: Output }],
  _cdkScrollableElement: [
    {
      type: ViewChild,
      args: ["scrollContainer", { read: CdkScrollable, static: false }],
    },
  ],
  targets: [{ type: ContentChildren, args: [ScrollNavTargetDirective] }],
  _onWindowResize: [{ type: HostListener, args: ["window:resize"] }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcScrollNavContentComponent.prototype.DEFAULT_BUFFER;
  /**
   * Reference to the scroll nav component.
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.nav;
  /**
   * If true, will force the height of the final scroll target area to be the height of the scrollable container.
   * This is helpful if you want the last target in the content area to be able to scroll to the top. You can alternatively
   * target the last item with css. *Defaults to true.*
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.makeLastTargetFullHeight;
  /**
   * Number in pixels, used to give a little leeway in the shifting of the active nav when scrolling. *Defaults to 40.*
   * Example: Left at default, if showing just the bottom 40 pixels of the section before, count the next section as active.
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.bufferSpace;
  /**
   * If true, applies smooth scrolling via css. *Defaults to true.*
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.shouldAnimateScroll;
  /**
   * Fires when a new section is scrolled into view. Broadcasts the id of that section.
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.newSectionInView;
  /** @type {?} */
  HcScrollNavContentComponent.prototype._cdkScrollableElement;
  /**
   * @type {?}
   * @private
   */
  HcScrollNavContentComponent.prototype.targets;
  /**
   * Id of the current section scrolled into view.
   * @type {?}
   */
  HcScrollNavContentComponent.prototype.sectionInView;
  /**
   * @type {?}
   * @private
   */
  HcScrollNavContentComponent.prototype.unsubscribe$;
  /**
   * @type {?}
   * @private
   */
  HcScrollNavContentComponent.prototype.minHeightForLastTargetSet;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-nav/scroll-nav.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollNavModule {}
ScrollNavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ScrollNavModule });
ScrollNavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ScrollNavModule_Factory(t) {
    return new (t || ScrollNavModule)();
  },
  providers: [],
  imports: [[CommonModule, ScrollingModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sort/sort-header.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * States describing the arrow's animated position (animating fromState to toState).
 * If the fromState is not defined, there will be no animated transition to the toState.
 * \@docs-private
 * @record
 */
function ArrowViewStateTransition() {}
if (false) {
  /** @type {?|undefined} */
  ArrowViewStateTransition.prototype.fromState;
  /** @type {?} */
  ArrowViewStateTransition.prototype.toState;
}
/**
 * Applies sorting behavior (click to change sort) and styles to an element, including an
 * arrow to display the current sort direction.
 *
 * Must be provided with an id and contained within a parent HcSort directive.
 *
 * If used on header cells in a CdkTable, it will automatically default its id from its containing
 * column definition.
 */

if (false) {
}

/**
 * @param {?} stepsWithoutRouterLink
 * @return {?}
 */
function throwErrorForMissingRouterLink(stepsWithoutRouterLink) {
  /** @type {?} */
  const stepLabels = stepsWithoutRouterLink.map(
    /**
     * @param {?} step
     * @return {?}
     */
    (step) => step.label
  );
  throw Error(`Routerlink missing on ${stepLabels.join(",")}`);
}
/**
 * @record
 */
function StepInterface() {}
if (false) {
  /**
   * The text to be displayed under the step indicator
   * @type {?|undefined}
   */
  StepInterface.prototype.label;
  /**
   * If using a router, the route this step should navigate to
   * @type {?|undefined}
   */
  StepInterface.prototype.routerLink;
  /**
   * The icon set the step's hc-icon should use. Must be set if using the icon parameter.
   * @type {?|undefined}
   */
  StepInterface.prototype.iconSet;
  /**
   * An glyph that should be displayed inside the step's circle.
   * If not set, the step number will display in the circle instead.
   * @type {?|undefined}
   */
  StepInterface.prototype.icon;
  /**
   * If true, the step will not be clickable
   * @type {?|undefined}
   */
  StepInterface.prototype.disabled;
  /**
   * Apply query params to the routerLink
   * @type {?|undefined}
   */
  StepInterface.prototype.queryParams;
}
/**
 * Convey progress through numbered steps, providing a wizard-like workflow.
 */
class StepperComponent {
  /**
   * @param {?} router
   * @param {?} urlSerializer
   */
  constructor(router, urlSerializer) {
    this.router = router;
    this.urlSerializer = urlSerializer;
    this._routerEnabled = false;
    /**
     * Sets the layout of the progress stepper. *Defaults to `arrow`.*
     */
    this.type = "arrow";
    this._color = "green";
    this._showStepCount = false;
    this._useRouterOutlet = true;
    this._activeIndex = undefined;
    /**
     * Emits the current zero-based index for the active step whenever it changes
     */
    this.activeIndexChange = new EventEmitter();
    this._hostClass = "hc-stepper-" + this.color;
    this.router.events.forEach(
      /**
       * @param {?} event
       * @return {?}
       */
      (event) => {
        if (event instanceof NavigationEnd) {
          this.findCurrentStep();
        }
      }
    );
  }
  /**
   * Sets the highlight color of the progress stepper. *Defaults to `green`.*
   * @return {?}
   */
  get color() {
    return this._color;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set color(value) {
    this._color = value;
    this._hostClass = "hc-stepper-" + this._color;
  }
  /**
   * Determines whether numerals should be displayed on each step indicator for the isolated type.
   * *Defaults to `false`.*
   * @return {?}
   */
  get showStepCount() {
    return this._showStepCount;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set showStepCount(value) {
    this._showStepCount = parseBooleanAttribute(value);
  }
  /**
   * If true, include a router outlet with the component. *Defaults to `true`.*
   * @return {?}
   */
  get useRouterOutlet() {
    return this._useRouterOutlet;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set useRouterOutlet(value) {
    this._useRouterOutlet = parseBooleanAttribute(value);
  }
  /**
   * Get or set the currently selected zero-based index of the stepper
   * @return {?}
   */
  get activeIndex() {
    return this._activeIndex;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set activeIndex(value) {
    if (!this.steps) {
      return;
    }
    if (value !== undefined && (value < 0 || value >= this.steps.length)) {
      throw Error(
        "The hc-stepper activeIndex value of " + value + " is out of bounds"
      );
    }
    if (this._routerEnabled && value !== undefined) {
      this.router.navigate([this.steps[value].routerLink]);
    } else {
      this._activeIndex = value;
      this.activeIndexChange.emit(this._activeIndex);
    }
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this._checkForRouterUse();
    if (this._routerEnabled) {
      this.findCurrentStep();
    }
  }
  /**
   * @param {?} index
   * @return {?}
   */
  _stepClick(index) {
    if (
      !this._routerEnabled &&
      index !== undefined &&
      this.steps[index].disabled !== true
    ) {
      this._activeIndex = index;
      this.activeIndexChange.emit(this._activeIndex);
    }
  }
  /**
   * @private
   * @return {?}
   */
  _checkForRouterUse() {
    /** @type {?} */
    const countUsingRouter = this.steps.filter(
      /**
       * @param {?} step
       * @return {?}
       */
      (step) => step.routerLink !== undefined
    ).length;
    if (countUsingRouter > 0 && countUsingRouter < this.steps.length) {
      /** @type {?} */
      const stepMissingRouterLink = this.steps.filter(
        /**
         * @param {?} step
         * @return {?}
         */
        (step) => step.routerLink === undefined
      );
      throwErrorForMissingRouterLink(stepMissingRouterLink);
    } else {
      this._routerEnabled = countUsingRouter === this.steps.length;
    }
  }
  /**
   * Can be used to activate the current step following \@Input() steps routerLink or queryParams updates
   * @return {?}
   */
  findCurrentStep() {
    /** @type {?} */
    const foundActiveRouteIndex = this.steps.findIndex(
      /**
       * @param {?} step
       * @return {?}
       */
      (step) => {
        /** @type {?} */
        const urlTree = this.router.createUrlTree([step.routerLink], {
          queryParams: step.queryParams,
        });
        /** @type {?} */
        const stepURL = this.urlSerializer.serialize(urlTree);
        return this.router.isActive(stepURL, true);
      }
    );
    this._activeIndex =
      foundActiveRouteIndex > -1 ? foundActiveRouteIndex : undefined;
    this.activeIndexChange.emit(this._activeIndex);
  }
}
StepperComponent.ɵfac = function StepperComponent_Factory(t) {
  return new (t || StepperComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.Router),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.UrlSerializer)
  );
};
StepperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: StepperComponent,
  selectors: [["hc-stepper"]],
  hostVars: 2,
  hostBindings: function StepperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassMap(ctx._hostClass);
    }
  },
  inputs: {
    type: "type",
    color: "color",
    showStepCount: "showStepCount",
    useRouterOutlet: "useRouterOutlet",
    activeIndex: "activeIndex",
    steps: "steps",
  },
  outputs: { activeIndexChange: "activeIndexChange" },
  ngContentSelectors: _c69,
  decls: 6,
  vars: 3,
  consts: [
    [3, "ngClass"],
    [1, "hc-stepper-track"],
    [
      "class",
      "hc-step",
      "routerLinkActive",
      "active",
      3,
      "routerLink",
      "routerLinkActiveOptions",
      "queryParams",
      "ngClass",
      "click",
      4,
      "ngFor",
      "ngForOf",
    ],
    ["class", "hc-step-content", 4, "ngIf"],
    [
      "routerLinkActive",
      "active",
      1,
      "hc-step",
      3,
      "routerLink",
      "routerLinkActiveOptions",
      "queryParams",
      "ngClass",
      "click",
    ],
    [1, "hc-step-disk"],
    [4, "ngIf", "ngIfElse"],
    ["elseBlock", ""],
    ["class", "hc-step-label-count", 4, "ngIf"],
    [1, "hc-step-label"],
    [1, "hc-step-arrow"],
    [1, "hc-step-icon", 3, "fontSet", "fontIcon"],
    [1, "hc-step-label-count"],
    [1, "hc-step-content"],
    [4, "ngIf"],
  ],
  template: function StepperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c68);
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵelementStart(1, "div", 1);
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵtemplate(3, StepperComponent_div_3_Template, 9, 22, "div", 2);
      ɵngcc0.ɵɵprojection(4, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(5, StepperComponent_div_5_Template, 2, 1, "div", 3);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngClass", "hc-stepper-" + ctx.type);
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
      ɵngcc0.ɵɵadvance(2);
      ɵngcc0.ɵɵproperty("ngIf", ctx.useRouterOutlet);
    }
  },
  directives: [
    ɵngcc1.NgClass,
    ɵngcc1.NgForOf,
    ɵngcc1.NgIf,
    ɵngcc6.RouterLinkActive,
    ɵngcc6.RouterLink,
    IconComponent,
    ɵngcc6.RouterOutlet,
  ],
  styles: [
    ".hc-step{-webkit-box-flex:1;flex:1;position:relative}.hc-stepper-arrow .hc-step{line-height:4rem;padding-left:3.6rem;white-space:nowrap;border-top-color:#f0f3f6}.hc-stepper-isolated .hc-step{padding-top:2rem;text-align:center}.hc-stepper-isolated .hc-step:before{background:#d7dde4;content:'';display:block;height:.5rem;left:0;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1}.hc-stepper-arrow .hc-step-disk{border-radius:50%;display:block;font-size:.9rem;height:1.6rem;left:1.2rem;line-height:1.6rem;position:absolute;text-align:center;top:1.2rem;width:1.6rem;box-shadow:0 0 0 3px #d7dde4;background-color:#fff}.hc-stepper-isolated .hc-step-disk{border-radius:50%;display:block;font-size:1rem;height:2rem;left:50%;line-height:2rem;margin-left:-1rem;position:absolute;text-align:center;top:0;width:2rem;z-index:2;box-shadow:0 0 0 3px #f0f3f6;background-color:#fff}.hc-stepper-green .hc-step-arrow-active .hc-step-disk,.hc-stepper-green .hc-step-isolated-active .hc-step-disk,.hc-stepper-green .hc-step-isolated-complete .hc-step-disk,.hc-stepper-green .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #00a859}.hc-stepper-blue .hc-step-arrow-active .hc-step-disk,.hc-stepper-blue .hc-step-isolated-active .hc-step-disk,.hc-stepper-blue .hc-step-isolated-complete .hc-step-disk,.hc-stepper-blue .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #00aeff}.hc-stepper-purple .hc-step-arrow-active .hc-step-disk,.hc-stepper-purple .hc-step-isolated-active .hc-step-disk,.hc-stepper-purple .hc-step-isolated-complete .hc-step-disk,.hc-stepper-purple .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #6e53a3}.hc-stepper-orange .hc-step-arrow-active .hc-step-disk,.hc-stepper-orange .hc-step-isolated-active .hc-step-disk,.hc-stepper-orange .hc-step-isolated-complete .hc-step-disk,.hc-stepper-orange .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #f8961d}.hc-stepper-red .hc-step-arrow-active .hc-step-disk,.hc-stepper-red .hc-step-isolated-active .hc-step-disk,.hc-stepper-red .hc-step-isolated-complete .hc-step-disk,.hc-stepper-red .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #f13c45}.hc-stepper-green .hc-step-arrow-complete .hc-step-disk,.hc-stepper-green .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #23c077}.hc-stepper-blue .hc-step-arrow-complete .hc-step-disk,.hc-stepper-blue .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #42c3ff}.hc-stepper-purple .hc-step-arrow-complete .hc-step-disk,.hc-stepper-purple .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #8973b4}.hc-stepper-orange .hc-step-arrow-complete .hc-step-disk,.hc-stepper-orange .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #f9ab49}.hc-stepper-red .hc-step-arrow-complete .hc-step-disk,.hc-stepper-red .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #f57178}.hc-step-arrow-active:not(.hc-step-last) .hc-step-arrow,.hc-step-arrow-incomplete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f0f3f6;border-bottom:2rem solid #f0f3f6;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-green .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #00a859;border-bottom:2rem solid #00a859;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-blue .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #00aeff;border-bottom:2rem solid #00aeff;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-purple .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #6e53a3;border-bottom:2rem solid #6e53a3;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-orange .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f8961d;border-bottom:2rem solid #f8961d;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-red .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f13c45;border-bottom:2rem solid #f13c45;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-green .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #23c077;border-bottom:2rem solid #23c077;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-blue .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #42c3ff;border-bottom:2rem solid #42c3ff;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-purple .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #8973b4;border-bottom:2rem solid #8973b4;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-orange .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f9ab49;border-bottom:2rem solid #f9ab49;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-red .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f57178;border-bottom:2rem solid #f57178;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-arrow .hc-step-label-count{display:none}.hc-stepper-isolated .hc-step-label-count{color:#333;display:inline-block;line-height:2rem;padding:0 .15rem}.hc-stepper-isolated .hc-step-label-count:after{content:'.'}.hc-step-isolated-active .hc-step-label-count{font-weight:600}.hc-stepper-arrow .hc-step-label{color:#fff}.hc-step-arrow-incomplete .hc-step-label{color:unset}.hc-stepper-isolated .hc-step-label{color:#333;display:inline-block;line-height:2rem;padding:0 .15rem}.hc-step-isolated-active .hc-step-label{font-weight:600}.hc-stepper-arrow .hc-step-icon{font-size:1rem;height:100%;line-height:1.6rem;width:100%}.hc-stepper-isolated .hc-step-icon{font-size:1.4rem;height:100%;line-height:1.92rem;width:100%}.hc-step-arrow-incomplete .hc-step-icon,.hc-step-isolated-incomplete .hc-step-icon{color:#d7dde4}.hc-stepper-green .hc-step-arrow-active .hc-step-icon,.hc-stepper-green .hc-step-isolated-active .hc-step-icon,.hc-stepper-green .hc-step-isolated-complete .hc-step-icon,.hc-stepper-green .hc-step-isolated-completed .hc-step-icon{color:#00a859}.hc-stepper-blue .hc-step-arrow-active .hc-step-icon,.hc-stepper-blue .hc-step-isolated-active .hc-step-icon,.hc-stepper-blue .hc-step-isolated-complete .hc-step-icon,.hc-stepper-blue .hc-step-isolated-completed .hc-step-icon{color:#00aeff}.hc-stepper-purple .hc-step-arrow-active .hc-step-icon,.hc-stepper-purple .hc-step-isolated-active .hc-step-icon,.hc-stepper-purple .hc-step-isolated-complete .hc-step-icon,.hc-stepper-purple .hc-step-isolated-completed .hc-step-icon{color:#6e53a3}.hc-stepper-orange .hc-step-arrow-active .hc-step-icon,.hc-stepper-orange .hc-step-isolated-active .hc-step-icon,.hc-stepper-orange .hc-step-isolated-complete .hc-step-icon,.hc-stepper-orange .hc-step-isolated-completed .hc-step-icon{color:#f8961d}.hc-stepper-red .hc-step-arrow-active .hc-step-icon,.hc-stepper-red .hc-step-isolated-active .hc-step-icon,.hc-stepper-red .hc-step-isolated-complete .hc-step-icon,.hc-stepper-red .hc-step-isolated-completed .hc-step-icon{color:#f13c45}.hc-stepper-green .hc-step-arrow-complete .hc-step-icon,.hc-stepper-green .hc-step-arrow-completed .hc-step-icon{color:#23c077}.hc-stepper-blue .hc-step-arrow-complete .hc-step-icon,.hc-stepper-blue .hc-step-arrow-completed .hc-step-icon{color:#42c3ff}.hc-stepper-purple .hc-step-arrow-complete .hc-step-icon,.hc-stepper-purple .hc-step-arrow-completed .hc-step-icon{color:#8973b4}.hc-stepper-orange .hc-step-arrow-complete .hc-step-icon,.hc-stepper-orange .hc-step-arrow-completed .hc-step-icon{color:#f9ab49}.hc-stepper-red .hc-step-arrow-complete .hc-step-icon,.hc-stepper-red .hc-step-arrow-completed .hc-step-icon{color:#f57178}.hc-stepper-clickable{cursor:pointer;outline:0}.hc-stepper-disabled{pointer-events:none}.hc-stepper-track{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.hc-stepper-arrow .hc-stepper-track{background-color:#f0f3f6}.hc-stepper-isolated .hc-step-first:before{left:50%}.hc-stepper-green .hc-step-arrow-active{background-color:#00a859}.hc-stepper-blue .hc-step-arrow-active{background-color:#00aeff}.hc-stepper-purple .hc-step-arrow-active{background-color:#6e53a3}.hc-stepper-orange .hc-step-arrow-active{background-color:#f8961d}.hc-stepper-red .hc-step-arrow-active{background-color:#f13c45}.hc-stepper-green .hc-step-isolated-active:before{background:#00a859;right:50%}.hc-stepper-green .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-blue .hc-step-isolated-active:before{background:#00aeff;right:50%}.hc-stepper-blue .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-purple .hc-step-isolated-active:before{background:#6e53a3;right:50%}.hc-stepper-purple .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-orange .hc-step-isolated-active:before{background:#f8961d;right:50%}.hc-stepper-orange .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-red .hc-step-isolated-active:before{background:#f13c45;right:50%}.hc-stepper-red .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-isolated .hc-step-last:before{right:50%}.hc-stepper-isolated .hc-step-last:after{display:none}.hc-stepper-green .hc-step-arrow-complete,.hc-stepper-green .hc-step-arrow-completed{background-color:#23c077}.hc-stepper-blue .hc-step-arrow-complete,.hc-stepper-blue .hc-step-arrow-completed{background-color:#42c3ff}.hc-stepper-purple .hc-step-arrow-complete,.hc-stepper-purple .hc-step-arrow-completed{background-color:#8973b4}.hc-stepper-orange .hc-step-arrow-complete,.hc-stepper-orange .hc-step-arrow-completed{background-color:#f9ab49}.hc-stepper-red .hc-step-arrow-complete,.hc-stepper-red .hc-step-arrow-completed{background-color:#f57178}.hc-step-arrow-complete:not(.hc-step-last):after,.hc-step-arrow-incomplete:not(.hc-step-last):after{border-right:.2rem solid #d7dde4;border-left:1rem solid transparent;border-top:2rem solid #d7dde4;border-bottom:2rem solid #d7dde4;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-green .hc-step-isolated-complete:before,.hc-stepper-green .hc-step-isolated-completed:before{background:#00a859}.hc-stepper-blue .hc-step-isolated-complete:before,.hc-stepper-blue .hc-step-isolated-completed:before{background:#00aeff}.hc-stepper-purple .hc-step-isolated-complete:before,.hc-stepper-purple .hc-step-isolated-completed:before{background:#6e53a3}.hc-stepper-orange .hc-step-isolated-complete:before,.hc-stepper-orange .hc-step-isolated-completed:before{background:#f8961d}.hc-stepper-red .hc-step-isolated-complete:before,.hc-stepper-red .hc-step-isolated-completed:before{background:#f13c45}.hc-stepper-green .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #00a859;border-left:1rem solid transparent;border-top:2rem solid #00a859;border-bottom:2rem solid #00a859;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-blue .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #00aeff;border-left:1rem solid transparent;border-top:2rem solid #00aeff;border-bottom:2rem solid #00aeff;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-purple .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #6e53a3;border-left:1rem solid transparent;border-top:2rem solid #6e53a3;border-bottom:2rem solid #6e53a3;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-orange .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #f8961d;border-left:1rem solid transparent;border-top:2rem solid #f8961d;border-bottom:2rem solid #f8961d;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-red .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #f13c45;border-left:1rem solid transparent;border-top:2rem solid #f13c45;border-bottom:2rem solid #f13c45;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
StepperComponent.ctorParameters = () => [
  { type: Router },
  { type: UrlSerializer },
];
StepperComponent.propDecorators = {
  steps: [{ type: Input }],
  type: [{ type: Input }],
  color: [{ type: Input }],
  showStepCount: [{ type: Input }],
  useRouterOutlet: [{ type: Input }],
  activeIndex: [{ type: Input }],
  activeIndexChange: [{ type: Output }],
  _hostClass: [{ type: HostBinding, args: ["class"] }],
};
if (false) {
  /** @type {?} */
  StepperComponent.prototype._routerEnabled;
  /**
   * An array defining the steps in the stepper
   * @type {?}
   */
  StepperComponent.prototype.steps;
  /**
   * Sets the layout of the progress stepper. *Defaults to `arrow`.*
   * @type {?}
   */
  StepperComponent.prototype.type;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype._color;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype._showStepCount;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype._useRouterOutlet;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype._activeIndex;
  /**
   * Emits the current zero-based index for the active step whenever it changes
   * @type {?}
   */
  StepperComponent.prototype.activeIndexChange;
  /** @type {?} */
  StepperComponent.prototype._hostClass;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype.router;
  /**
   * @type {?}
   * @private
   */
  StepperComponent.prototype.urlSerializer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/stepper/stepper.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepperModule {}
StepperModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StepperModule });
StepperModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function StepperModule_Factory(t) {
    return new (t || StepperModule)();
  },
  imports: [[CommonModule, RouterModule, IconModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/stepper/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/subnav/subnav.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Secondary navigation bar appearing below the primary navbar
 */
class SubnavComponent {
  constructor() {
    this._hostClass = true;
    /**
     * @deprecated
     * \@description Not compatible with notification banners, so you should set
     *  the fixed position of the subnav and other header content within your app instead
     *
     */
    this.fixedTop = false;
  }
}
SubnavComponent.ɵfac = function SubnavComponent_Factory(t) {
  return new (t || SubnavComponent)();
};
SubnavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: SubnavComponent,
  selectors: [["hc-subnav"]],
  hostVars: 4,
  hostBindings: function SubnavComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-subnav", ctx._hostClass)(
        "hc-subnav-fixed-top",
        ctx.fixedTop
      );
    }
  },
  inputs: { fixedTop: "fixedTop" },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function SubnavComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
/** @nocollapse */
SubnavComponent.ctorParameters = () => [];
SubnavComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-subnav"] }],
  fixedTop: [
    { type: HostBinding, args: ["class.hc-subnav-fixed-top"] },
    { type: Input },
  ],
};
if (false) {
  /** @type {?} */
  SubnavComponent.prototype._hostClass;
  /**
   * @deprecated
   * \@description Not compatible with notification banners, so you should set
   *  the fixed position of the subnav and other header content within your app instead
   *
   * @type {?}
   */
  SubnavComponent.prototype.fixedTop;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/subnav/subnav-right.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Can be added to a div or individual component to align it to the right side of the subnav
 */
class SubnavRightDirective {
  constructor() {
    this._hostClass = true;
  }
}
SubnavRightDirective.ɵfac = function SubnavRightDirective_Factory(t) {
  return new (t || SubnavRightDirective)();
};
SubnavRightDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: SubnavRightDirective,
  selectors: [["", "hcSubnavRight", ""]],
  hostVars: 2,
  hostBindings: function SubnavRightDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-subnav-right", ctx._hostClass);
    }
  },
});
SubnavRightDirective.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-subnav-right"] }],
};
if (false) {
  /** @type {?} */
  SubnavRightDirective.prototype._hostClass;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/subnav/subnav.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SubnavModule {}
SubnavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SubnavModule });
SubnavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function SubnavModule_Factory(t) {
    return new (t || SubnavModule)();
  },
  imports: [[CommonModule]],
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/subnav/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/table.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class HcTable extends CdkTable {
  /**
   * @param {?} _differs
   * @param {?} _changeDetectorRef
   * @param {?} _elementRef
   * @param {?} _platform
   * @param {?} role
   * @param {?} _dir
   */
  constructor(
    _differs,
    _changeDetectorRef,
    _elementRef,
    _platform,
    role,
    _dir
  ) {
    super(
      _differs,
      _changeDetectorRef,
      _elementRef,
      role,
      _dir,
      document,
      _platform
    );
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._dir = _dir;
    /**
     * Overrides the sticky CSS class set by the `CdkTable`.
     */
    this.stickyCssClass = "hc-table-sticky";
    this._hostHcTableClass = true;
    this._hostHcBordersClass = true;
    this._hostHcTableSmall = false;
  }
  /**
   * Sets whether the table should have a 2px border around each cell (defaults to true)
   * @return {?}
   */
  get borders() {
    return this._hostHcBordersClass;
  }
  /**
   * @param {?} hasBorders
   * @return {?}
   */
  set borders(hasBorders) {
    this._hostHcBordersClass = parseBooleanAttribute(hasBorders);
  }
  /**
   * If true, table has less padding and a smaller font size (defaults to false)
   * @return {?}
   */
  get tight() {
    return this._hostHcTableSmall;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._hostHcTableSmall = parseBooleanAttribute(value);
  }
}
HcTable.ɵfac = function HcTable_Factory(t) {
  return new (t || HcTable)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc9.Platform),
    ɵngcc0.ɵɵinjectAttribute("role"),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8)
  );
};
HcTable.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcTable,
  selectors: [["hc-table"], ["table", "hc-table", ""]],
  hostVars: 6,
  hostBindings: function HcTable_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-table", ctx._hostHcTableClass)(
        "hc-table-borders",
        ctx._hostHcBordersClass
      )("hc-table-small", ctx._hostHcTableSmall);
    }
  },
  inputs: { borders: "borders", tight: "tight" },
  exportAs: ["matTable"],
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c71,
  decls: 6,
  vars: 0,
  consts: [
    ["headerRowOutlet", ""],
    ["rowOutlet", ""],
    ["noDataRowOutlet", ""],
    ["footerRowOutlet", ""],
  ],
  template: function HcTable_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c70);
      ɵngcc0.ɵɵprojection(0);
      ɵngcc0.ɵɵprojection(1, 1);
      ɵngcc0.ɵɵelementContainer(2, 0);
      ɵngcc0.ɵɵelementContainer(3, 1);
      ɵngcc0.ɵɵelementContainer(4, 2);
      ɵngcc0.ɵɵelementContainer(5, 3);
    }
  },
  directives: [],
  styles: [
    ".hc-table{border:1px solid transparent;color:#333;max-width:100%;width:100%}.hc-table td,.hc-table th{background-clip:padding-box;border-bottom:1px solid #c0c5cc;border-top:none;line-height:1.3;padding:8px 16px;position:relative}.hc-table td:focus,.hc-table th:focus{outline:0}.hc-table th{color:#006d9a;font-size:14px;font-weight:600;vertical-align:bottom}.hc-table tbody{border:1px solid #c0c5cc;font-size:15px}.hc-table tbody tr:nth-child(2n){background-color:#fff}.hc-table tbody tr:nth-child(2n+1){background-color:#f9fafb}.hc-table tbody tr:not([disabled]):hover{background-color:#e4e7ea}.hc-table td{vertical-align:top}.hc-table tfoot{font-size:14px;font-weight:600}.hc-table tfoot td{border-bottom:none}.hc-table.hc-table-small td,.hc-table.hc-table-small th{font-size:13px;padding:6px 16px}.hc-table.hc-table-small td.hc-col-sortable-left:after,.hc-table.hc-table-small td.hc-col-sortable:after,.hc-table.hc-table-small th.hc-col-sortable-left:after,.hc-table.hc-table-small th.hc-col-sortable:after{bottom:7px}.hc-table.hc-action-table tbody tr:not([disabled]):hover{background-color:#bfebff;cursor:pointer}.hc-table.hc-action-table tbody tr:not([disabled]).hc-row-selected{background-color:#007bff;color:#fff}.hc-table.hc-action-table tbody tr:not([disabled]).hc-row-selected:hover{background-color:#3395ff}.hc-cell-resizer-left,.hc-cell-resizer-right{cursor:col-resize;display:block;height:100%;position:absolute;top:0;width:10px}.hc-cell-resizer-left.disabled,.hc-cell-resizer-right.disabled{cursor:default}.hc-cell-resizer-left{left:0;margin-left:-1px}.hc-table td:first-of-type .hc-cell-resizer-left,.hc-table th:first-of-type .hc-cell-resizer-left{display:none}.hc-cell-resizer-right{margin-right:-1px;right:0}.hc-table td:last-of-type .hc-cell-resizer-right,.hc-table th:last-of-type .hc-cell-resizer-right{display:none}.hc-row-selected,.hc-table tbody tr.hc-row-selected{background-color:#007bff;color:#fff}.hc-row-selected:hover,.hc-table tbody tr.hc-row-selected:hover{background-color:#3395ff}.hc-row-selected td,.hc-table tbody tr.hc-row-selected td{border-color:#fff}.hc-action-table tbody tr:not([disabled]) .hc-row-selected:hover,.hc-action-table tbody tr:not([disabled]) .hc-table tbody tr.hc-row-selected:hover,.hc-row-selected.hc-action-row:not([disabled]):hover,.hc-table tbody tr.hc-row-selected.hc-action-row:not([disabled]):hover{background-color:#3395ff}.hc-no-hover-table tbody tr .hc-row-selected:hover,.hc-no-hover-table tbody tr .hc-table tbody tr.hc-row-selected:hover{background-color:#007bff}.hc-table tbody tr.hc-action-row:not([disabled]):hover{background-color:#bfebff;cursor:pointer}.hc-table-borders{border:1px solid transparent}.hc-table-borders td,.hc-table-borders th{border:1px solid #c0c5cc}.hc-table-borders .hc-footer-row,.hc-table-borders th{background-color:#f0f3f6}.hc-table-borders tfoot td{border:1px solid #c0c5cc}.hc-table-justify-left{text-align:left}.hc-table-justify-center{text-align:center}.hc-table-justify-right{text-align:right}.hc-table-justify-left .hc-sort-header-container{-webkit-box-pack:left;justify-content:left}.hc-table-justify-center .hc-sort-header-container{-webkit-box-pack:center;justify-content:center}.hc-table-justify-right .hc-sort-header-container{-webkit-box-pack:right;justify-content:right}.hc-table th.hc-col-sortable,.hc-table th.hc-col-sortable-left{background-clip:padding-box;cursor:pointer;padding-right:35px;position:relative}.hc-table th.hc-col-sortable-left:hover,.hc-table th.hc-col-sortable:hover{background-color:#bfebff}.hc-table th.hc-col-sortable-left:after,.hc-table th.hc-col-sortable:after{background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzYwLjc4IDE3OTIiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojYTNhNWE3O308L3N0eWxlPjwvZGVmcz48dGl0bGU+QXJ0Ym9hcmQgMTwvdGl0bGU+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTgyLDEzNDIuODlIODA1Ljc5cTMxLjM0LDAsMzcuMzEsMTYuNDJ0LTE0LjkxLDM3LjNMNDg1LDE3NjkuNjNRNDY0LjA3LDE3OTIsNDMyLjc3LDE3OTJ0LTUyLjIxLTIyLjM3bC0zNDMuMjEtMzczcS0yMC45MS0yMC44OC0xNC45MS0zNy4zdDM3LjMtMTYuNDJIMjgzLjU2VjBINTgyWm03OTguMjYtMTMxOSwzNDMuMiwzNzEuNTVxMjAuODUsMjAuOTEsMTQuOTIsMzYuNTV0LTM3LjMxLDE1LjY2SDE0NzcuMjRWMTc5MC41MkgxMTc4LjgyVjQ0Ny42M0g5NTVxLTMxLjMyLDAtMzcuMy0xNS42NnQxNC45MS0zNi41NWwzNDMuMi0zNzEuNTVRMTI5Ni42NiwxLjUsMTMyOCwxLjQ4VDEzODAuMjQsMjMuODdaIi8+PC9zdmc+);background-position:center center;background-repeat:no-repeat;bottom:10px;content:'';height:13px;margin-left:15px;padding-right:35px;position:absolute;right:1px;width:13px}.hc-table th.hc-col-sortable-left{padding-right:16px;padding-left:35px}.hc-table th.hc-col-sortable-left:after{left:-14px}.hc-table th.hc-active-sort{color:#00a859}.hc-table th.hc-active-sort.hc-sort-asc:after{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxNzYwLjggMTc5MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTc2MC44IDE3OTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMDBBODU5O30KPC9zdHlsZT4KPHRpdGxlPkFydGJvYXJkIDE8L3RpdGxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMCwzNTJjMC04LDMuMy0xNiwxMC0yNEwzMjksOWM2LjItNS44LDE0LjUtOS4xLDIzLTljOCwwLDE1LjcsMywyMyw5bDMyMCwzMjBjMTAsMTAuNywxMi4zLDIyLjMsNywzNQoJYy01LjMsMTMuMy0xNS4zLDIwLTMwLDIwSDQ4MHYxMzc2YzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDlIMjU2Yy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzVjM4NEgzMmMtOS4zLDAtMTctMy0yMy05CglTMCwzNjEuMywwLDM1MnogTTE3NjAuOCwxNTY4djE5MmMwLDkuMy0zLDE3LTksMjNjLTYsNi0xMy43LDktMjMsOWgtODMyYy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzdi0xOTJjMC05LjMsMy0xNyw5LTIzCglzMTMuNy05LDIzLTloODMyYzkuMywwLDE3LDMsMjMsOUMxNzU3LjgsMTU1MSwxNzYwLjgsMTU1OC43LDE3NjAuOCwxNTY4eiBNMTU2OC44LDEwNTZ2MTkyYzAsOS4zLTMsMTctOSwyM2MtNiw2LTEzLjcsOS0yMyw5aC02NDAKCWMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg2NDBjOS4zLDAsMTcsMywyMyw5QzE1NjUuOCwxMDM5LDE1NjguOCwxMDQ2LjcsMTU2OC44LDEwNTZ6CgkgTTEzNzYuOCw1NDR2MTkyYzAsOS4zLTMsMTctOSwyM2MtNiw2LTEzLjcsOS0yMyw5aC00NDhjLTkuMywwLTE3LTMtMjMtOXMtOS0xMy43LTktMjNWNTQ0YzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg0NDgKCWM5LjMsMCwxNywzLDIzLDlDMTM3My44LDUyNywxMzc2LjgsNTM0LjcsMTM3Ni44LDU0NHogTTExODQuOCwzMnYxOTJjMCw5LjMtMywxNy05LDIzcy0xMy43LDktMjMsOWgtMjU2Yy05LjMsMC0xNy0zLTIzLTkKCXMtOS0xMy43LTktMjNWMzJjMC05LjMsMy0xNyw5LTIzczEzLjctOSwyMy05aDI1NmM5LjMsMCwxNywzLDIzLDlTMTE4NC44LDIyLjcsMTE4NC44LDMyeiIvPgo8L3N2Zz4K)}.hc-table th.hc-active-sort.hc-sort-desc:after{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxNzYwLjggMTc5MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTc2MC44IDE3OTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMDBBODU5O30KPC9zdHlsZT4KPHRpdGxlPkFydGJvYXJkIDE8L3RpdGxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTE4NC44LDE1Njh2MTkyYzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDloLTI1NmMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yMwoJczEzLjctOSwyMy05aDI1NmM5LjMsMCwxNywzLDIzLDlTMTE4NC44LDE1NTguNywxMTg0LjgsMTU2OHogTTcwNC44LDE0NDBjMCw4LTMuMywxNi0xMCwyNGwtMzE5LDMxOWMtNi4yLDUuOC0xNC41LDkuMS0yMyw5CgljLTgsMC0xNS43LTMtMjMtOWwtMzIwLTMyMGMtMTAtMTAuNy0xMi4zLTIyLjMtNy0zNWM1LjMtMTMuMywxNS4zLTIwLDMwLTIwaDE5MlYzMmMwLTkuMywzLTE3LDktMjNzMTMuNy05LDIzLTloMTkyCgljOS4zLDAsMTcsMywyMyw5czksMTMuNyw5LDIzdjEzNzZoMTkyYzkuMywwLDE3LDMsMjMsOVM3MDQuOCwxNDMwLjcsNzA0LjgsMTQ0MHogTTEzNzYuOCwxMDU2djE5MmMwLDkuMy0zLDE3LTksMjNzLTEzLjcsOS0yMyw5CgloLTQ0OGMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg0NDhjOS4zLDAsMTcsMywyMyw5UzEzNzYuOCwxMDQ2LjcsMTM3Ni44LDEwNTZ6IE0xNTY4LjgsNTQ0Cgl2MTkyYzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDloLTY0MGMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM1Y1NDRjMC05LjMsMy0xNyw5LTIzczEzLjctOSwyMy05aDY0MGM5LjMsMCwxNywzLDIzLDkKCVMxNTY4LjgsNTM0LjcsMTU2OC44LDU0NHogTTE3NjAuOCwzMnYxOTJjMCw5LjMtMywxNy05LDIzcy0xMy43LDktMjMsOWgtODMyYy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzVjMyYzAtOS4zLDMtMTcsOS0yMwoJczEzLjctOSwyMy05aDgzMmM5LjMsMCwxNywzLDIzLDlTMTc2MC44LDIyLjcsMTc2MC44LDMyeiIvPgo8L3N2Zz4K)}.hc-no-hover-table tbody tr:nth-child(2n):hover{background-color:#fff}.hc-no-hover-table tbody tr:nth-child(2n+1):hover{background-color:#f9fafb}.hc-no-hover-table tbody tr.hc-row-selected:hover{background-color:#007bff}hc-table{display:block}",
  ],
  encapsulation: 2,
  changeDetection: 0,
});
/** @nocollapse */
HcTable.ctorParameters = () => [
  { type: IterableDiffers },
  { type: ChangeDetectorRef },
  { type: ElementRef },
  { type: Platform },
  { type: String, decorators: [{ type: Attribute, args: ["role"] }] },
  { type: Directionality, decorators: [{ type: Optional }] },
];
HcTable.propDecorators = {
  _hostHcTableClass: [{ type: HostBinding, args: ["class.hc-table"] }],
  _hostHcBordersClass: [
    { type: HostBinding, args: ["class.hc-table-borders"] },
  ],
  _hostHcTableSmall: [{ type: HostBinding, args: ["class.hc-table-small"] }],
  borders: [{ type: Input }],
  tight: [{ type: Input }],
};
if (false) {
  /**
   * Overrides the sticky CSS class set by the `CdkTable`.
   * @type {?}
   * @protected
   */
  HcTable.prototype.stickyCssClass;
  /** @type {?} */
  HcTable.prototype._hostHcTableClass;
  /** @type {?} */
  HcTable.prototype._hostHcBordersClass;
  /** @type {?} */
  HcTable.prototype._hostHcTableSmall;
  /**
   * @type {?}
   * @protected
   */
  HcTable.prototype._differs;
  /**
   * @type {?}
   * @protected
   */
  HcTable.prototype._changeDetectorRef;
  /**
   * @type {?}
   * @protected
   */
  HcTable.prototype._elementRef;
  /**
   * @type {?}
   * @protected
   */
  HcTable.prototype._dir;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/cell.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cell definition for the hc-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
class HcCellDef extends CdkCellDef {}
HcCellDef.ɵfac = function HcCellDef_Factory(t) {
  return ɵHcCellDef_BaseFactory(t || HcCellDef);
};
HcCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcCellDef,
  selectors: [["", "hcCellDef", ""]],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkCellDef, useExisting: HcCellDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Header cell definition for the hc-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
class HcHeaderCellDef extends CdkHeaderCellDef {}
HcHeaderCellDef.ɵfac = function HcHeaderCellDef_Factory(t) {
  return ɵHcHeaderCellDef_BaseFactory(t || HcHeaderCellDef);
};
HcHeaderCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcHeaderCellDef,
  selectors: [["", "hcHeaderCellDef", ""]],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkHeaderCellDef, useExisting: HcHeaderCellDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Footer cell definition for the hc-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
class HcFooterCellDef extends CdkFooterCellDef {}
HcFooterCellDef.ɵfac = function HcFooterCellDef_Factory(t) {
  return ɵHcFooterCellDef_BaseFactory(t || HcFooterCellDef);
};
HcFooterCellDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcFooterCellDef,
  selectors: [["", "hcFooterCellDef", ""]],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkFooterCellDef, useExisting: HcFooterCellDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Column definition for the hc-table.
 * Defines a set of cells available for a table column.
 */
class HcColumnDef extends CdkColumnDef {
  constructor() {
    super(...arguments);
    this._justify = "left";
  }
  /**
   * Sets the text alignment for this column: `left` (default), `center` or `right`
   * @return {?}
   */
  get justify() {
    return this._justify;
  }
  /**
   * @param {?} justifyVal
   * @return {?}
   */
  set justify(justifyVal) {
    if (
      justifyVal === "left" ||
      justifyVal === "center" ||
      justifyVal === "right"
    ) {
      this._justify = justifyVal;
    } else {
      throw Error("Unsupported table column alignment value: " + justifyVal);
    }
  }
}
HcColumnDef.ɵfac = function HcColumnDef_Factory(t) {
  return ɵHcColumnDef_BaseFactory(t || HcColumnDef);
};
HcColumnDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcColumnDef,
  selectors: [["", "hcColumnDef", ""]],
  inputs: {
    justify: "justify",
    name: ["hcColumnDef", "name"],
    sticky: "sticky",
    stickyEnd: "stickyEnd",
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkColumnDef, useExisting: HcColumnDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
HcColumnDef.propDecorators = {
  name: [{ type: Input, args: ["hcColumnDef"] }],
  justify: [{ type: Input }],
  sticky: [{ type: Input }],
  stickyEnd: [{ type: Input }],
};
if (false) {
  /**
   * @type {?}
   * @private
   */
  HcColumnDef.prototype._justify;
  /**
   * Unique name for this column.
   * @type {?}
   */
  HcColumnDef.prototype.name;
  /**
   * Whether this column should be sticky positioned at the start of the row
   * @type {?}
   */
  HcColumnDef.prototype.sticky;
  /**
   * Whether this column should be sticky positioned on the end of the row
   * @type {?}
   */
  HcColumnDef.prototype.stickyEnd;
}
/**
 * Header cell template container that adds the right classes and role.
 */
class HcHeaderCell extends CdkHeaderCell {
  /**
   * @param {?} columnDef
   * @param {?} elementRef
   */
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(
      `hc-column-${columnDef.cssClassFriendlyName}`
    );
    elementRef.nativeElement.classList.add(
      `hc-table-justify-` + columnDef.justify
    );
  }
}
HcHeaderCell.ɵfac = function HcHeaderCell_Factory(t) {
  return new (t || HcHeaderCell)(
    ɵngcc0.ɵɵdirectiveInject(HcColumnDef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
HcHeaderCell.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcHeaderCell,
  selectors: [["hc-header-cell"], ["th", "hc-header-cell", ""]],
  hostAttrs: ["role", "columnheader", 1, "hc-header-cell"],
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
});
/** @nocollapse */
HcHeaderCell.ctorParameters = () => [
  { type: HcColumnDef },
  { type: ElementRef },
];
/**
 * Footer cell template container that adds the right classes and role.
 */
class HcFooterCell extends CdkFooterCell {
  /**
   * @param {?} columnDef
   * @param {?} elementRef
   */
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(
      `hc-column-${columnDef.cssClassFriendlyName}`
    );
    elementRef.nativeElement.classList.add(
      `hc-table-justify-` + columnDef.justify
    );
  }
}
HcFooterCell.ɵfac = function HcFooterCell_Factory(t) {
  return new (t || HcFooterCell)(
    ɵngcc0.ɵɵdirectiveInject(HcColumnDef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
HcFooterCell.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcFooterCell,
  selectors: [["hc-footer-cell"], ["td", "hc-footer-cell", ""]],
  hostAttrs: ["role", "gridcell", 1, "hc-footer-cell"],
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
});
/** @nocollapse */
HcFooterCell.ctorParameters = () => [
  { type: HcColumnDef },
  { type: ElementRef },
];
/**
 * Cell template container that adds the right classes and role.
 */
class HcCell extends CdkCell {
  /**
   * @param {?} columnDef
   * @param {?} elementRef
   */
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(
      `hc-column-${columnDef.cssClassFriendlyName}`
    );
    elementRef.nativeElement.classList.add(
      `hc-table-justify-` + columnDef.justify
    );
  }
}
HcCell.ɵfac = function HcCell_Factory(t) {
  return new (t || HcCell)(
    ɵngcc0.ɵɵdirectiveInject(HcColumnDef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)
  );
};
HcCell.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcCell,
  selectors: [["hc-cell"], ["td", "hc-cell", ""]],
  hostAttrs: ["role", "gridcell", 1, "hc-cell"],
  features: [ɵngcc0.ɵɵInheritDefinitionFeature],
});
/** @nocollapse */
HcCell.ctorParameters = () => [{ type: HcColumnDef }, { type: ElementRef }];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/row.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Header row definition for the hc-table.
 * Captures the header row's template and other header properties such as the columns to display.
 */
class HcHeaderRowDef extends CdkHeaderRowDef {}
HcHeaderRowDef.ɵfac = function HcHeaderRowDef_Factory(t) {
  return ɵHcHeaderRowDef_BaseFactory(t || HcHeaderRowDef);
};
HcHeaderRowDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcHeaderRowDef,
  selectors: [["", "hcHeaderRowDef", ""]],
  inputs: {
    columns: ["hcHeaderRowDef", "columns"],
    sticky: ["hcHeaderRowDefSticky", "sticky"],
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkHeaderRowDef, useExisting: HcHeaderRowDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Footer row definition for the mat-table.
 * Captures the footer row's template and other footer properties such as the columns to display.
 */
class HcFooterRowDef extends CdkFooterRowDef {}
HcFooterRowDef.ɵfac = function HcFooterRowDef_Factory(t) {
  return ɵHcFooterRowDef_BaseFactory(t || HcFooterRowDef);
};
HcFooterRowDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcFooterRowDef,
  selectors: [["", "hcFooterRowDef", ""]],
  inputs: {
    columns: ["hcFooterRowDef", "columns"],
    sticky: ["hcFooterRowDefSticky", "sticky"],
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkFooterRowDef, useExisting: HcFooterRowDef },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Data row definition for the mat-table.
 * Captures the footer row's template and other footer properties such as the columns to display and
 * a when predicate that describes when this row should be used.
 * @template T
 */
class HcRowDef extends CdkRowDef {}
HcRowDef.ɵfac = function HcRowDef_Factory(t) {
  return ɵHcRowDef_BaseFactory(t || HcRowDef);
};
HcRowDef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcRowDef,
  selectors: [["", "hcRowDef", ""]],
  inputs: {
    columns: ["hcRowDefColumns", "columns"],
    when: ["hcRowDefWhen", "when"],
  },
  features: [
    ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRowDef, useExisting: HcRowDef }]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
});
/**
 * Footer template container that contains the cell outlet. Adds the right class and role.
 */
class HcHeaderRow extends CdkHeaderRow {}
HcHeaderRow.ɵfac = function HcHeaderRow_Factory(t) {
  return ɵHcHeaderRow_BaseFactory(t || HcHeaderRow);
};
HcHeaderRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcHeaderRow,
  selectors: [["hc-header-row"], ["tr", "hc-header-row", ""]],
  hostAttrs: ["role", "row", 1, "hc-header-row"],
  exportAs: ["hcHeaderRow"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkHeaderRow, useExisting: HcHeaderRow },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function HcHeaderRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementContainer(0, 0);
    }
  },
  directives: [],
  encapsulation: 2,
  changeDetection: 0,
});
/**
 * Footer template container that contains the cell outlet. Adds the right class and role.
 */
class HcFooterRow extends CdkFooterRow {}
HcFooterRow.ɵfac = function HcFooterRow_Factory(t) {
  return ɵHcFooterRow_BaseFactory(t || HcFooterRow);
};
HcFooterRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcFooterRow,
  selectors: [["hc-footer-row"], ["tr", "hc-footer-row", ""]],
  hostAttrs: ["role", "row", 1, "hc-footer-row"],
  exportAs: ["hcFooterRow"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([
      { provide: CdkFooterRow, useExisting: HcFooterRow },
    ]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function HcFooterRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementContainer(0, 0);
    }
  },
  directives: [],
  encapsulation: 2,
  changeDetection: 0,
});
/**
 * Data row template container that contains the cell outlet. Adds the right class and role.
 */
class HcRow extends CdkRow {}
HcRow.ɵfac = function HcRow_Factory(t) {
  return ɵHcRow_BaseFactory(t || HcRow);
};
HcRow.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcRow,
  selectors: [["hc-row"], ["tr", "hc-row", ""]],
  hostAttrs: ["role", "row", 1, "hc-row"],
  exportAs: ["hcRow"],
  features: [
    ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRow, useExisting: HcRow }]),
    ɵngcc0.ɵɵInheritDefinitionFeature,
  ],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function HcRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementContainer(0, 0);
    }
  },
  directives: [],
  encapsulation: 2,
  changeDetection: 0,
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/bind-observable/bind-observable-options.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* Copyright 2017 PSanetra <code@psanetra.de>

Open Source typescript decorator which binds class properties to observable companion properties.
https://github.com/PSanetra/bind-observable

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
/**
 * @record
 */
function BindObservableOpts() {}
if (false) {
  /**
   * optional custom key of the companion property.
   * If not provided, the decorator will take the name of the original property key with a '$' suffix.
   * @type {?|undefined}
   */
  BindObservableOpts.prototype.key;
  /**
   * If true, the observable will emit the raw setter value if the decorated property is an accessor.
   * Otherwise the observable will call the getter once and emit the returned value.
   * This option will be ignored if the decorated property has no get accessor.
   * @type {?|undefined}
   */
  BindObservableOpts.prototype.emitRawSetterValue;
}
/**
 * @param {?} pet
 * @return {?}
 */
function isBindObservableOpts(pet) {
  return pet && typeof pet === "object";
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/bind-observable/bind-observable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const subjects = new WeakMap();
/** @type {?} */
const values = new WeakMap();
/**
 * @param {?} instance
 * @param {?} key
 * @return {?}
 */
function subject(instance, key) {
  /** @type {?} */
  let subjectByProp = subjects.get(instance);
  if (!subjectByProp) {
    subjectByProp = new Map();
    subjects.set(instance, subjectByProp);
  }
  /** @type {?} */
  let _subject = subjectByProp.get(key);
  if (!_subject) {
    _subject = new ReplaySubject(1);
    subjectByProp.set(key, _subject);
  }
  return _subject;
}
/**
 * @param {?} instance
 * @return {?}
 */
function valueMap(instance) {
  /** @type {?} */
  let _valueMap = values.get(instance);
  if (!_valueMap) {
    _valueMap = new Map();
    values.set(instance, _valueMap);
  }
  return _valueMap;
}
/**
 * @param {?} target
 * @param {?} observableKey
 * @return {?}
 */
function defineObservableProperty(target, observableKey) {
  Object.defineProperty(target, observableKey, {
    configurable: true,
    enumerable: false,
    /**
     * @return {?}
     */
    get() {
      return subject(this, observableKey);
    },
  });
}
/**
 * @param {?} target
 * @param {?} propertyKey
 * @param {?} observableKey
 * @return {?}
 */
function redefineSimpleProperty(target, propertyKey, observableKey) {
  Object.defineProperty(target, propertyKey, {
    configurable: true,
    enumerable: true,
    /**
     * @param {?} value
     * @return {?}
     */
    set(value) {
      valueMap(this).set(propertyKey, value);
      subject(this, observableKey).next(value);
    },
    /**
     * @return {?}
     */
    get() {
      return valueMap(this).get(propertyKey);
    },
  });
}
/**
 * @param {?} target
 * @param {?} propertyKey
 * @param {?} observableKey
 * @param {?} emitRawSetterValue
 * @param {?} descriptor
 * @return {?}
 */
function redefineAccessorProperty(
  target,
  propertyKey,
  observableKey,
  emitRawSetterValue,
  descriptor
) {
  Object.defineProperty(target, propertyKey, {
    configurable: descriptor.configurable,
    enumerable: descriptor.enumerable,
    /**
     * @param {?} value
     * @return {?}
     */
    set(value) {
      if (!descriptor.set) {
        throw new Error(
          `Property ${propertyKey} doesn't have a setter and cannot be written`
        );
      }
      descriptor.set.call(this, value);
      /** @type {?} */
      const companionProp = subject(this, observableKey);
      if (emitRawSetterValue || !descriptor.get) {
        companionProp.next(value);
      } else {
        companionProp.next(descriptor.get());
      }
    },
    /**
     * @return {?}
     */
    get() {
      if (!descriptor.get) {
        throw new Error(
          `Property ${propertyKey} doesn't have a getter and cannot be read`
        );
      }
      return descriptor.get.call(this);
    },
  });
}
/**
 * Binds a property to an observable companion property.
 * The observable companion property will emit on all assignments (including initialization),
 * but will not emit undefined if undefined is not explicitly assigned on initialization.
 * @param {?=} observableKeyOrOpts
 * @return {?}
 */
function BindObservable(observableKeyOrOpts) {
  return (
    /**
     * @param {?} target
     * @param {?} propertyKey
     * @return {?}
     */
    (target, propertyKey) => {
      /** @type {?} */
      const opts = isBindObservableOpts(observableKeyOrOpts)
        ? observableKeyOrOpts
        : {};
      if (typeof observableKeyOrOpts === "string") {
        opts.key = observableKeyOrOpts;
      }
      /** @type {?} */
      const observableKey = opts.key || propertyKey + "$";
      // The third parameter of this function (descriptor) is passed only if the decorated property
      // is an accessor, but it won't be passed if another decorator has replaced the descriptor.
      // See Property Decorators at https://www.typescriptlang.org/docs/handbook/decorators.html
      // Because of this, we are forced to retrieve the current descriptor with Reflection API
      /** @type {?} */
      const descriptor = Reflect.getOwnPropertyDescriptor(target, propertyKey);
      delete target[propertyKey];
      delete target[observableKey];
      defineObservableProperty(target, observableKey);
      if (descriptor !== undefined) {
        redefineAccessorProperty(
          target,
          propertyKey,
          observableKey,
          !!opts.emitRawSetterValue,
          descriptor
        );
      } else {
        redefineSimpleProperty(target, propertyKey, observableKey);
      }
    }
  );
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/cell-resizer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellResizeEvent {
  /**
   * @param {?} width
   * @param {?} directionLeft
   */
  constructor(width, directionLeft) {
    this.width = width;
    this.directionLeft = directionLeft;
  }
}
if (false) {
  /** @type {?} */
  CellResizeEvent.prototype.width;
  /** @type {?} */
  CellResizeEvent.prototype.directionLeft;
}
class HcCellResizer {
  constructor() {
    /**
     * Sets whether the resizer is active or not
     */
    this.disabled = false;
    this._directionModifier = 1;
    /**
     * Emits a `CellResizeEvent` when a cell has been resized
     */
    this.resized = new EventEmitter();
    this.isResizing = false;
    /**
     * Emits a boolean value of true while a cell is being resized
     */
    this.resizing = new EventEmitter();
  }
  /**
   * Stores the width value for this resizer;
   * typically used with two-way binding on the cell's style.width property
   * @return {?}
   */
  get width() {
    return this._width;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set width(value) {
    if (value > 0) {
      this._width = value;
    }
  }
  /**
   * @return {?}
   */
  ngOnInit() {
    this.isResizing$
      .pipe(
        // Skip default value
        skip(1),
        untilDestroyed(this)
      )
      .subscribe(
        /**
         * @param {?} isResizing
         * @return {?}
         */
        (isResizing) => {
          this.resizing.emit(isResizing);
          if (isResizing) {
            // We must use arrow function to avoid losing the context,
            //  we cannot pass directly the functions references
            this.dragSubscription = fromEvent(window.document, "mousemove")
              .pipe(untilDestroyed(this))
              .subscribe(
                /**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => this._resizeColumn(event)
              );
            this.dragSubscription.add(
              fromEvent(window.document, "mouseup")
                .pipe(untilDestroyed(this))
                .subscribe(
                  /**
                   * @return {?}
                   */
                  () => this._stopResizing()
                )
            );
          } else {
            // When resize finishes, we emit one last "resized" event for which
            //  the corresponding "isResizing" value will be false.
            // This can be used to detect which is the final resizing event
            //  and ignore the others
            this.resized.emit(
              new CellResizeEvent(this.width, this._directionModifier === -1)
            );
            if (this.dragSubscription) {
              this.dragSubscription.unsubscribe();
            }
          }
        }
      );
  }
  /**
   * @private
   * @param {?} event
   * @return {?}
   */
  _resizeColumn(event) {
    /** @type {?} */
    const deltaX = event.screenX - this._mouseX;
    /** @type {?} */
    const newWidth = this.width + deltaX * this._directionModifier;
    this._mouseX = event.screenX;
    if (newWidth >= 0) {
      this.resized.emit(
        new CellResizeEvent(newWidth, this._directionModifier === -1)
      );
    }
    // Prevent text selection while resizing
    event.preventDefault();
    event.stopPropagation();
  }
  // Same problems that mousemove listener have
  /**
   * @private
   * @return {?}
   */
  _stopResizing() {
    this.isResizing = false;
  }
  // isResizing can be set to true only when the component is not disabled
  /**
   * @param {?} event
   * @return {?}
   */
  _startResizing(event) {
    this.isResizing = !this.disabled;
    this._mouseX = event.screenX;
    if (/** @type {?} */ (event.target).className === "hc-cell-resizer-left") {
      this._directionModifier = -1;
    } else {
      this._directionModifier = 1;
    }
    // Prevent text selection while resizing
    event.preventDefault();
    event.stopPropagation();
  }
  // Must be present for AOT compilation to work, even if empty
  // Otherwise 'ng build --prod' will optimize away any calls to ngOnDestroy,
  // even if the method is added by the untilDestroyed operator
  /**
   * @return {?}
   */
  ngOnDestroy() {}
}
HcCellResizer.ɵfac = function HcCellResizer_Factory(t) {
  return new (t || HcCellResizer)();
};
HcCellResizer.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcCellResizer,
  selectors: [["hc-cell-resizer"]],
  hostVars: 2,
  hostBindings: function HcCellResizer_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "mousedown",
        function HcCellResizer_mousedown_HostBindingHandler($event) {
          return ctx._startResizing($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  inputs: { disabled: "disabled", width: "width" },
  outputs: { resized: "resized", resizing: "resizing" },
  decls: 2,
  vars: 0,
  consts: [
    [1, "hc-cell-resizer-left"],
    [1, "hc-cell-resizer-right"],
  ],
  template: function HcCellResizer_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelement(0, "div", 0);
      ɵngcc0.ɵɵelement(1, "div", 1);
    }
  },
  encapsulation: 2,
  changeDetection: 0,
});
HcCellResizer.propDecorators = {
  disabled: [{ type: HostBinding, args: ["class.disabled"] }, { type: Input }],
  width: [{ type: Input }],
  resized: [{ type: Output }],
  resizing: [{ type: Output }],
  _startResizing: [{ type: HostListener, args: ["mousedown", ["$event"]] }],
};
__decorate(
  [BindObservable(), __metadata("design:type", Object)],
  HcCellResizer.prototype,
  "isResizing",
  void 0
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AccordionComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-accordion",
            template:
              '<div class="hc-accordion-toolbar-wrapper" [ngClass]="[_pointer, _alignment]" (click)="_triggerClick($event, true)" *ngIf="!hideToolbar">\n    <button type="button" class="hc-accordion-trigger" (click)="_triggerClick($event, false)"></button>\n    <ng-content select="hc-accordion-toolbar"></ng-content>\n</div>\n\n<div class="hc-accordion-collapse"\n     [@openState]="_openState"\n     (@openState.start)="_animationStart($event)"\n     (@openState.done)="_animationEnd($event)">\n    <div class="hc-accordion-content">\n        <ng-content></ng-content>\n    </div>\n</div>\n',
            exportAs: "hcAccordion",
            animations: [
              trigger("openState", [
                state(
                  "open, open-instant",
                  style({
                    height: "*",
                  })
                ),
                state(
                  "void",
                  style({
                    height: "0px",
                    visibility: "hidden",
                  })
                ),
                transition("void => open-instant", animate("0ms")),
                transition("void <=> open", animate("400ms ease")),
              ]),
            ],
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-accordion{display:block;background:0 0;color:currentColor;box-sizing:border-box}.hc-accordion-toolbar-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:nowrap;-webkit-box-align:center;align-items:center}.hc-accordion-toolbar-wrapper.hc-toolbar-pointer{cursor:pointer}.hc-accordion-trigger{background:0 0;border:none;color:#00aeff;cursor:pointer;height:48px;outline:0;padding:0;position:relative;width:48px;margin:2px;border-radius:4px;-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center}.hc-accordion-trigger::after{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNi45NzgiIGhlaWdodD0iMTcuMzE5IiB2aWV3Qm94PSIwIDAgMjYuOTc4IDE3LjMxOSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNSIgZGF0YS1uYW1lPSJQYXRoIDUiIGNsYXNzPSJjbHMtMSIgZD0iTTI4LjE3NS0xMi4xODhhMS4wODEsMS4wODEsMCwwLDAsMC0xLjUyM0wyNS40LTE2LjQ3M2ExLjA2MSwxLjA2MSwwLDAsMC0xLjUwNywwTDE1LTcuNTg0bC04Ljg5LTguODlhMS4wNjEsMS4wNjEsMCwwLDAtMS41MDcsMEwxLjgyNS0xMy43MTFhMS4wODEsMS4wODEsMCwwLDAsMCwxLjUyM0wxNC4yNDcuMjE4YTEuMDYxLDEuMDYxLDAsMCwwLDEuNTA3LDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;box-sizing:border-box;content:'';display:block;height:8.5px;margin-top:2px;pointer-events:none;-webkit-transform:rotate(180deg);transform:rotate(180deg);-webkit-transition:-webkit-transform .5s cubic-bezier(.25,.8,.25,1);transition:transform .5s cubic-bezier(.25,.8,.25,1);transition:transform .5s cubic-bezier(.25,.8,.25,1),-webkit-transform .5s cubic-bezier(.25,.8,.25,1);width:13px}.hc-accordion-trigger:focus{box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-accordion-closed .hc-accordion-trigger::after,.hc-accordion-closing .hc-accordion-trigger::after{-webkit-transform:rotate(0);transform:rotate(0)}.hc-accordion-toolbar-wrapper.hc-align-right .hc-accordion-trigger{margin-left:auto;-webkit-box-ordinal-group:2;order:1}.hc-accordion-collapse{display:block;overflow:hidden}.hc-accordion-toolbar{-webkit-box-align:center;align-items:center;box-sizing:border-box;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;flex-wrap:wrap;width:100%}.hc-accordion-toolbar-wrapper.hc-align-right .hc-accordion-toolbar{-webkit-box-ordinal-group:1;order:0}.hc-accordion-content{outline:0;padding:12px 0}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      openChange: [
        {
          type: Output,
        },
      ],
      opened: [
        {
          type: Output,
        },
      ],
      openStart: [
        {
          type: Output,
        },
      ],
      closed: [
        {
          type: Output,
        },
      ],
      closeStart: [
        {
          type: Output,
        },
      ],
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-accordion"],
        },
      ],
      triggerAlign: [
        {
          type: Input,
        },
      ],
      toolbarTrigger: [
        {
          type: Input,
        },
      ],
      hideToolbar: [
        {
          type: Input,
        },
      ],
      open: [
        {
          type: Input,
        },
      ],
      _isOpened: [
        {
          type: HostBinding,
          args: ["class.hc-accordion-opened"],
        },
      ],
      _isOpening: [
        {
          type: HostBinding,
          args: ["class.hc-accordion-opening"],
        },
      ],
      _isClosed: [
        {
          type: HostBinding,
          args: ["class.hc-accordion-closed"],
        },
      ],
      _isClosing: [
        {
          type: HostBinding,
          args: ["class.hc-accordion-closing"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AccordionToolbarComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-accordion-toolbar",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-accordion-toolbar"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(AccordionModule, {
      declarations: function () {
        return [AccordionComponent, AccordionToolbarComponent];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [AccordionComponent, AccordionToolbarComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AccordionModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [AccordionComponent, AccordionToolbarComponent],
            exports: [AccordionComponent, AccordionToolbarComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    WorkTrackerService,
    [
      {
        type: Injectable,
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AppSwitcherComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-app-switcher",
            template:
              '<div class="hc-app-switcher">\n    <h4 class="hc-app-switcher-header">\n        Applications\n        <a\n            hc-button\n            *ngIf="appSwitcherService.allApplicationsUri"\n            buttonStyle="link-inline"\n            class="hc-app-switcher-all-apps-link"\n            [href]="appSwitcherService.allApplicationsUri"\n            target="_blank"\n        >\n            View All\n        </a>\n    </h4>\n\n    <ng-container *ngIf="applications?.length > 0">\n        <div class="hc-app-switcher-apps">\n            <div class="hc-app-switcher-app" *ngFor="let app of applications">\n                <a\n                    class="hc-app-switcher-link"\n                    [ngClass]="{\'hc-app-switcher-link-highlighted\': appIsMe(app)}"\n                    [title]="appIsMe(app) ? \'Current Application\' : app.Description"\n                    [attr.href]="linkIfNotMe(app)"\n                    target="_blank"\n                >\n                    <div\n                        class="hc-app-switcher-app-img"\n                        [ngStyle]="{\n                            width: iconHeight + \'px\',\n                            height: iconHeight + \'px\',\n                            \'background-image\': \'url(\' + app.Icon + \')\'\n                        }"\n                    ></div>\n                    <div class="hc-app-switcher-app-title">{{ app?.FriendlyName | ellipsis: 18 }}</div>\n                </a>\n            </div>\n        </div>\n    </ng-container>\n\n    <!-- Loading -->\n    <div *ngIf="loading | async" class="hc-app-switcher-empty hc-app-switcher-spinner-container">\n        <hc-progress-spinner diameter="60"></hc-progress-spinner>\n    </div>\n\n    <!-- Load Failed -->\n    <div *ngIf="!(loading | async) && loadFailed" class="hc-app-switcher-empty">\n        <span class="hc-app-switcher-warning-icon"></span>\n        <em>Failed to load applications.</em>\n        <a class="hc-app-switcher-retry" hc-button buttonStyle="link" (click)="loadApplications()">Retry now.</a>\n    </div>\n\n    <!-- No Apps Available -->\n    <div *ngIf="!(loading | async) && applications?.length === 0" class="hc-app-switcher-empty">\n        <span class="hc-app-switcher-empty-icon"></span>\n        <em>No applications available.</em>\n    </div>\n</div>\n',
            // tslint:disable-next-line: no-host-metadata-property
            host: { class: "hc-app-switcher-container" },
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-app-switcher-container{height:100%;width:100%}.hc-app-switcher{max-width:360px}.hc-app-switcher-header{-webkit-box-align:baseline;align-items:baseline;border-bottom:1px solid #ccc;display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:10px 0;padding-bottom:5px;padding-left:2px}.hc-app-switcher-all-apps-link{font-size:.92857rem}.hc-app-switcher-apps{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap;-webkit-box-pack:start;justify-content:flex-start}.hc-app-switcher-app{-webkit-box-flex:0;flex:0 0 auto}.hc-app-switcher-link{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:10px;text-decoration:none}.hc-app-switcher-link-highlighted{opacity:.5}.hc-app-switcher-app-title{color:#333;font-weight:600;padding-top:8px;text-align:center;width:100px}.hc-app-switcher-app-img{background-position:center;background-repeat:no-repeat;background-size:cover}.hc-app-switcher-empty{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding:20px;text-align:center;width:360px}.hc-app-switcher-spinner-container{padding:65px 0}.hc-app-switcher-warning-icon{background-repeat:no-repeat;height:40px;opacity:.5;width:40px;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMC4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA3OS41IDcwLjEiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc5LjUgNzAuMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHRpdGxlPndhcm48L3RpdGxlPg0KPHBhdGggZD0iTTc4LjgsNjIuOEw0NCwyLjRjLTEuMy0yLjMtNC4zLTMuMS02LjctMS44Yy0wLjcsMC40LTEuNCwxLTEuOCwxLjhMMC43LDYyLjhjLTEuMywyLjMtMC41LDUuMywxLjgsNi43DQoJYzAuNywwLjQsMS42LDAuNywyLjQsMC43aDY5LjdjMi43LDAsNC45LTIuMiw0LjktNC45Qzc5LjUsNjQuNCw3OS4yLDYzLjUsNzguOCw2Mi44eiBNMzUuMiwyMC43aDkuMnYyNS43aC05LjJWMjAuN3ogTTM5LjcsNjAuOA0KCWMtMy4xLDAtNS42LTIuNS01LjYtNS42YzAtMy4xLDIuNS01LjYsNS42LTUuNmMzLjEsMCw1LjYsMi41LDUuNiw1LjZDNDUuNCw1OC4yLDQyLjgsNjAuOCwzOS43LDYwLjh6Ii8+DQo8L3N2Zz4NCg==)}.hc-app-switcher-empty-icon{background-repeat:no-repeat;height:40px;opacity:.5;width:40px;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA5Ni45OSA4NC4xNSI+PHRpdGxlPmVtcHR5PC90aXRsZT48cGF0aCBkPSJNODcuMTQsMTEuNjVhNS41NCw1LjU0LDAsMCwwLTUtMy41N0gxOGE1LjU0LDUuNTQsMCwwLDAtNSwzLjU3TDEuNTYsNTIuM1Y4OC42N2EzLjU3LDMuNTcsMCwwLDAsMy41NywzLjU3SDk1YTMuNTcsMy41NywwLDAsMCwzLjU3LTMuNTdWNTIuM1pNODUuNzIsNTMuNzJINjguNnMtMi4xNC4xOC0yLjE0LDMuNTdsMC0uMDhhMTYuMzgsMTYuMzgsMCwwLDEtMzIuNzQsMGwwLC4wOGMwLTMuMzktMi4xNC0zLjU2LTIuMTQtMy41NkgxNC40Yy01LjcxLDAtMy41Ny01LTMuNTctNWw4LjU2LTMxLjM4QTMuODEsMy44MSwwLDAsMSwyMywxNC41SDc3Ljg3YTMuNzcsMy43NywwLDAsMSwzLjU3LDIuNzlsNy44NSwzMS4zMlM5MS40Miw1My43Miw4NS43Miw1My43MloiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjU2IC04LjA4KSIvPjwvc3ZnPg==)}.hc-app-switcher-retry{cursor:pointer;font-weight:600;margin-top:10px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        {
          type: undefined,
          decorators: [
            {
              type: Inject,
              args: [APP_SWITCHER_SERVICE],
            },
          ],
        },
        { type: WorkTrackerService },
      ];
    },
    {
      iconHeight: [
        {
          type: Input,
        },
      ],
      serviceName: [
        {
          type: Input,
        },
      ],
      serviceVersion: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AppSwitcherLinksComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-app-switcher-links",
            template:
              '<div class="hc-app-switcher-links-bottom-spacer"></div>\n<a class="hc-app-switcher-links" [href]="_appSwitcherService?.allApplicationsUri">\n    <hc-icon class="hc-app-switcher-links-icon" fontSet="fa" fontIcon="fa-th"></hc-icon>\n    <span class="hc-app-switcher-links-text">View all my applications</span>\n</a>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-app-switcher-links-bottom-spacer{padding-bottom:15px}.hc-app-switcher-links{-webkit-box-align:center;align-items:center;border-top:1px solid #51646f;color:#c0c5cc;display:-webkit-box;display:flex;height:55px;padding-left:2%;text-decoration:none;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-app-switcher-links:hover{background-color:#1b2225}.hc-app-switcher-links-icon{color:#708090;padding-left:28px}.hc-app-switcher-links-text{padding-left:33px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        {
          type: undefined,
          decorators: [
            {
              type: Inject,
              args: [APP_SWITCHER_SERVICE],
            },
          ],
        },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PopoverNotificationService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuItemDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcMenuItem], [hcButtonItem]",
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-item"],
        },
      ],
      // Menu Item uses focus for hover highlighting to sync with keyboard navigation of the menu
      /**
       * @return {?}
       */
      focus: [
        {
          type: HostListener,
          args: ["mouseenter"],
        },
      ],
      /**
       * @return {?}
       */
      blur: [
        {
          type: HostListener,
          args: ["touchend"],
        },
        {
          type: HostListener,
          args: ["touchcancel"],
        },
        {
          type: HostListener,
          args: ["mouseleave"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcPopComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-pop",
            encapsulation: ViewEncapsulation.None,
            animations: [transformPopover],
            template:
              '<ng-template>\n  <div class="hc-pop-container"\n      #focusTrapElement\n      class="{{_yAlignClass}} {{_xAlignClass}}"\n      [class.hc-pop-container-basic]="!disableStyle"\n      [ngClass]="_classList"\n      (click)="_popContainerClicked()"\n      [@transformPopover]="_getAnimation()"\n      (@transformPopover.done)="_onAnimationDone($event)">\n    <ng-content></ng-content>\n    <div *ngIf="showArrow" class="hc-pop-arrow {{_yAlignClass}} {{_xAlignClass}}"></div>\n  </div>\n</ng-template>\n',
            styles: [
              ".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-pop-before.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .hc-pop-before.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.hc-pop-before.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .hc-pop-before.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}.hc-pop-before.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .hc-pop-before.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}.hc-pop-center.hc-pop-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.hc-pop-center.hc-pop-below{-webkit-transform-origin:center top;transform-origin:center top}.hc-pop-after.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .hc-pop-after.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.hc-pop-after.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .hc-pop-after.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}.hc-pop-after.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .hc-pop-after.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}.hc-pop-container-basic{background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;padding:12px}.hc-pop-show-arrow .hc-pop-arrow{background-color:#fff;border-style:solid;border-width:1px;display:block;height:10px;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:10px}.hc-pop-arrow-x-start .hc-pop-arrow{left:5px}.hc-pop-arrow-x-center .hc-pop-arrow{left:calc(50% - 6px)}.hc-pop-arrow-x-end .hc-pop-arrow{left:calc(100% - 15px)}.hc-pop-arrow-y-start .hc-pop-arrow{top:5px}.hc-pop-arrow-y-center .hc-pop-arrow{top:calc(50% - 6px)}.hc-pop-arrow-y-end .hc-pop-arrow{top:calc(100% - 15px)}.hc-pop-arrow-y-above .hc-pop-arrow{border-color:transparent #ccc #ccc transparent;bottom:-6px}.hc-pop-arrow-y-below .hc-pop-arrow{border-color:#ccc transparent transparent #ccc;top:-6px}.hc-pop-arrow-x-before .hc-pop-arrow{border-color:#ccc #ccc transparent transparent;right:-6px}.hc-pop-arrow-x-after .hc-pop-arrow{border-color:transparent transparent #ccc #ccc;left:-6px}.hc-pop-arrow-y-above.hc-pop-show-arrow,.hc-pop-arrow-y-below.hc-pop-show-arrow{margin:6px 0;position:relative}.hc-pop-arrow-x-after.hc-pop-show-arrow,.hc-pop-arrow-x-before.hc-pop-show-arrow{margin:0 6px;position:relative}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        { type: ɵngcc2.FocusTrapFactory },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [DOCUMENT],
            },
          ],
        },
      ];
    },
    {
      disableStyle: [
        {
          type: Input,
        },
      ],
      showArrow: [
        {
          type: Input,
        },
      ],
      shouldAnimate: [
        {
          type: Input,
        },
      ],
      backdropClass: [
        {
          type: Input,
        },
      ],
      autoCloseOnContentClick: [
        {
          type: Input,
        },
      ],
      opened: [
        {
          type: Output,
        },
      ],
      closed: [
        {
          type: Output,
        },
      ],
      afterOpen: [
        {
          type: Output,
        },
      ],
      afterClose: [
        {
          type: Output,
        },
      ],
      backdropClicked: [
        {
          type: Output,
        },
      ],
      overlayKeydown: [
        {
          type: Output,
        },
      ],
      horizontalAlign: [
        {
          type: Input,
        },
      ],
      xAlign: [
        {
          type: Input,
        },
      ],
      verticalAlign: [
        {
          type: Input,
        },
      ],
      yAlign: [
        {
          type: Input,
        },
      ],
      forceAlignment: [
        {
          type: Input,
        },
      ],
      lockAlignment: [
        {
          type: Input,
        },
      ],
      autoFocus: [
        {
          type: Input,
        },
      ],
      restoreFocus: [
        {
          type: Input,
        },
      ],
      scrollStrategy: [
        {
          type: Input,
        },
      ],
      hasBackdrop: [
        {
          type: Input,
        },
      ],
      interactiveClose: [
        {
          type: Input,
        },
      ],
      openTransition: [
        {
          type: Input,
        },
      ],
      closeTransition: [
        {
          type: Input,
        },
      ],
      parent: [
        {
          type: Input,
        },
      ],
      _templateRef: [
        {
          type: ViewChild,
          args: [TemplateRef, { static: false }],
        },
      ],
      _focusTrapElement: [
        {
          type: ViewChild,
          args: ["focusTrapElement", { static: false }],
        },
      ],
      _menuItems: [
        {
          type: ContentChildren,
          args: [MenuItemDirective, { descendants: true }],
        },
      ],
    }
  );
})();
const ɵHcTooltipComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcTooltipComponent
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcTooltipComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-tooltip",
            template:
              '<ng-template #_templateRef>\n    <div\n        class="hc-pop-container , hc-tooltip-container"\n        class="{{ _yAlignClass }} {{ _xAlignClass }}"\n        [class.hc-pop-container-basic]="!disableStyle"\n        [ngClass]="_classList"\n        [@transformPopover]="_getAnimation()"\n        (@transformPopover.done)="_onAnimationDone($event)"\n    >\n        <span class="hc-tooltip">\n            {{ tooltipContent }}\n        </span>\n        <div *ngIf="showArrow" class="hc-pop-arrow hc-pop-arrow-y-above hc-pop-arrow-x-center"></div>\n    </div>\n</ng-template>\n',
            animations: [transformPopover],
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-pop-before.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}[dir=rtl] .hc-pop-before.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}.hc-pop-before.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}[dir=rtl] .hc-pop-before.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}.hc-pop-before.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .hc-pop-before.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}.hc-pop-center.hc-pop-above{-webkit-transform-origin:center bottom;transform-origin:center bottom}.hc-pop-center.hc-pop-below{-webkit-transform-origin:center top;transform-origin:center top}.hc-pop-after.hc-pop-above{-webkit-transform-origin:left bottom;transform-origin:left bottom}[dir=rtl] .hc-pop-after.hc-pop-above{-webkit-transform-origin:right bottom;transform-origin:right bottom}.hc-pop-after.hc-pop-center{-webkit-transform-origin:left center;transform-origin:left center}[dir=rtl] .hc-pop-after.hc-pop-center{-webkit-transform-origin:right center;transform-origin:right center}.hc-pop-after.hc-pop-below{-webkit-transform-origin:left top;transform-origin:left top}[dir=rtl] .hc-pop-after.hc-pop-below{-webkit-transform-origin:right top;transform-origin:right top}.hc-pop-container-basic{background-color:#fff;border:1px solid #ccc;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;padding:12px}.hc-pop-show-arrow .hc-pop-arrow{background-color:#fff;border-style:solid;border-width:1px;display:block;height:10px;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:10px}.hc-pop-arrow-x-start .hc-pop-arrow{left:5px}.hc-pop-arrow-x-center .hc-pop-arrow{left:calc(50% - 6px)}.hc-pop-arrow-x-end .hc-pop-arrow{left:calc(100% - 15px)}.hc-pop-arrow-y-start .hc-pop-arrow{top:5px}.hc-pop-arrow-y-center .hc-pop-arrow{top:calc(50% - 6px)}.hc-pop-arrow-y-end .hc-pop-arrow{top:calc(100% - 15px)}.hc-pop-arrow-y-above .hc-pop-arrow{border-color:transparent #ccc #ccc transparent;bottom:-6px}.hc-pop-arrow-y-below .hc-pop-arrow{border-color:#ccc transparent transparent #ccc;top:-6px}.hc-pop-arrow-x-before .hc-pop-arrow{border-color:#ccc #ccc transparent transparent;right:-6px}.hc-pop-arrow-x-after .hc-pop-arrow{border-color:transparent transparent #ccc #ccc;left:-6px}.hc-pop-arrow-y-above.hc-pop-show-arrow,.hc-pop-arrow-y-below.hc-pop-show-arrow{margin:6px 0;position:relative}.hc-pop-arrow-x-after.hc-pop-show-arrow,.hc-pop-arrow-x-before.hc-pop-show-arrow{margin:0 6px;position:relative}",
              ".hc-pop-container .hc-tooltip{background-color:#333;border-radius:4px;padding:7px;margin:-1px;color:#fff}.hc-pop-container .hc-tooltip+.hc-pop-arrow{background-color:#333!important;border-color:transparent!important}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:2100}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:-webkit-box;display:flex;position:absolute;z-index:2100}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:2100;display:-webkit-box;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .4s cubic-bezier(.25,.8,.25,1);transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:2100;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.hc-tooltip-container{top:-10px;line-height:14px}.hc-tooltip-container .hc-tooltip{margin-right:0;margin-left:0}.hc-tooltip-container .hc-pop-arrow{bottom:-14px}",
            ],
          },
        ],
      },
    ],
    null,
    {
      tooltipContent: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcPopoverAnchoringService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        { type: ɵngcc3.Overlay },
        { type: ɵngcc0.NgZone },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcPopoverAccessibilityService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcPopoverAnchorDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcPop],[hcTooltip]",
            exportAs: "hcPopAnchor",
            providers: [HcPopoverAnchoringService],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        { type: ɵngcc0.ViewContainerRef },
        { type: HcPopoverAnchoringService },
        { type: HcPopoverAccessibilityService },
        { type: ɵngcc0.ComponentFactoryResolver },
      ];
    },
    {
      _hasSubmenu: [
        {
          type: HostBinding,
          args: ["class.hc-menu-item-submenu"],
        },
      ],
      popoverOpened: [
        {
          type: Output,
        },
      ],
      popoverClosed: [
        {
          type: Output,
        },
      ],
      attachedPopover: [
        {
          type: Input,
          args: ["hcPop"],
        },
      ],
      tooltipText: [
        {
          type: Input,
          args: ["hcTooltip"],
        },
      ],
      trigger: [
        {
          type: Input,
        },
      ],
      popoverDelay: [
        {
          type: Input,
        },
      ],
      context: [
        {
          type: Input,
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _showOrHideOnClick: [
        {
          type: HostListener,
          args: ["click", ["$event"]],
        },
      ],
      /**
       * So popover anchors can be accessible via keyboard.
       * @param {?} event
       * @return {?}
       */
      _showOrHideOnEnter: [
        {
          type: HostListener,
          args: ["keydown", ["$event"]],
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _showOrHideOnMouseOver: [
        {
          type: HostListener,
          args: ["touchstart", ["$event"]],
        },
        {
          type: HostListener,
          args: ["mousedown", ["$event"]],
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _showOrHideRightClick: [
        {
          type: HostListener,
          args: ["contextmenu", ["$event"]],
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _showOnHover: [
        {
          type: HostListener,
          args: ["mouseenter", ["$event"]],
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _hideOnLeave: [
        {
          type: HostListener,
          args: ["touchend", ["$event"]],
        },
        {
          type: HostListener,
          args: ["touchcancel", ["$event"]],
        },
        {
          type: HostListener,
          args: ["mouseleave", ["$event"]],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcMenu]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-panel"],
        },
      ],
      _subMenus: [
        {
          type: ContentChildren,
          args: [HcPopoverAnchorDirective],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuIconDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcMenuIcon]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-icon"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuTextDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcMenuText]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-text"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuSubTextDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcMenuSubText]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-sub-text"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DividerDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcDivider]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-divider"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(PopModule, {
      declarations: function () {
        return [
          HcPopComponent,
          HcTooltipComponent,
          HcPopoverAnchorDirective,
          MenuDirective,
          MenuItemDirective,
          MenuIconDirective,
          MenuTextDirective,
          MenuSubTextDirective,
          DividerDirective,
        ];
      },
      imports: function () {
        return [CommonModule, OverlayModule, A11yModule, BidiModule];
      },
      exports: function () {
        return [
          HcPopComponent,
          HcTooltipComponent,
          HcPopoverAnchorDirective,
          BidiModule,
          MenuDirective,
          MenuItemDirective,
          MenuIconDirective,
          MenuTextDirective,
          MenuSubTextDirective,
          DividerDirective,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PopModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, OverlayModule, A11yModule, BidiModule],
            declarations: [
              HcPopComponent,
              HcTooltipComponent,
              HcPopoverAnchorDirective,
              MenuDirective,
              MenuItemDirective,
              MenuIconDirective,
              MenuTextDirective,
              MenuSubTextDirective,
              DividerDirective,
            ],
            exports: [
              HcPopComponent,
              HcTooltipComponent,
              HcPopoverAnchorDirective,
              BidiModule,
              MenuDirective,
              MenuItemDirective,
              MenuIconDirective,
              MenuTextDirective,
              MenuSubTextDirective,
              DividerDirective,
            ],
            entryComponents: [HcTooltipComponent],
            providers: [HcPopoverAccessibilityService],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ProgressSpinnerComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-progress-spinner",
            template:
              '<div class="hc-spinner-container" [ngClass]="{\'center-spinner\': isCentered }">\n    <div class="hc-spinner" \n        [ngClass]="{\'indeterminate-spin\': !isDeterminate, \'large-spinner\': diameter >= 150 }"\n        [style.width.px]="diameter"\n        [style.height.px]="diameter"\n        [style.marginTop.px]="isCentered ? diameter / -2 : 0"\n        [style.marginLeft.px]="isCentered ? diameter / -2 : 0">\n        <div class="spinner-layer spinner-{{color}}" [ngClass]="{\'spinner-base\': hasChannel }">\n            <div class="circle base-circle"></div>\n            <div class="circle-clipper left"><div class="circle" [style.transform]="_leftCircleTransform" [style.transition]="_leftCircleTransition"></div>\n            </div><div class="gap-patch"><div class="circle"></div>\n            </div><div class="circle-clipper right"><div class="circle" [style.transform]="_rightCircleTransform" [style.transition]="_rightCircleTransition"></div></div>\n        </div>\n    </div>\n</div>',
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      isCentered: [
        {
          type: Input,
        },
      ],
      hasChannel: [
        {
          type: Input,
        },
      ],
      isDeterminate: [
        {
          type: Input,
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
      progress: [
        {
          type: Input,
        },
      ],
      diameter: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ProgressDotsComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-progress-dots",
            template:
              '<div class="hc-dots-container" [ngClass]="{\'center-dots\': isCentered }">\n    <div class="hc-dots-loader" [ngClass]="{\'loader-light\': color === \'light\', \'loader-mini\': isMini}">\n        <div class="loader-animate"></div>\n    </div>\n</div>',
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      isCentered: [
        {
          type: Input,
        },
      ],
      isMini: [
        {
          type: Input,
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ProgressIndicatorsModule, {
      declarations: function () {
        return [ProgressSpinnerComponent, ProgressDotsComponent];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [ProgressSpinnerComponent, ProgressDotsComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ProgressIndicatorsModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [ProgressSpinnerComponent, ProgressDotsComponent],
            declarations: [ProgressSpinnerComponent, ProgressDotsComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AppSwitcherService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        { type: ɵngcc5.HttpClient },
        {
          type: undefined,
          decorators: [
            {
              type: Inject,
              args: [APP_SWITCHER_CONFIG],
            },
          ],
        },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    EllipsisPipe,
    [
      {
        type: Pipe,
        args: [
          {
            name: "ellipsis",
            pure: true,
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(EllipsisPipeModule, {
      declarations: [EllipsisPipe],
      exports: [EllipsisPipe],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    EllipsisPipeModule,
    [
      {
        type: NgModule,
        args: [
          {
            declarations: [EllipsisPipe],
            exports: [EllipsisPipe],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NullOrEmptyStringPipe,
    [
      {
        type: Pipe,
        args: [
          {
            name: "ifNullOrEmpty",
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(NullOrEmptyStringPipeModule, {
      declarations: [NullOrEmptyStringPipe],
      exports: [NullOrEmptyStringPipe],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NullOrEmptyStringPipeModule,
    [
      {
        type: NgModule,
        args: [
          {
            declarations: [NullOrEmptyStringPipe],
            exports: [NullOrEmptyStringPipe],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    FileSizePipe,
    [
      {
        type: Pipe,
        args: [{ name: "fileSize", pure: true }],
      },
    ],
    function () {
      return [];
    },
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(FileSizePipeModule, {
      declarations: function () {
        return [FileSizePipe];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [FileSizePipe];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    FileSizePipeModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [FileSizePipe],
            exports: [FileSizePipe],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NumberAbbreviatorPipe,
    [
      {
        type: Pipe,
        args: [{ name: "abbreviateNumber" }],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(NumberAbbreviatorPipeModule, {
      declarations: function () {
        return [NumberAbbreviatorPipe];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [NumberAbbreviatorPipe];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NumberAbbreviatorPipeModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [NumberAbbreviatorPipe],
            exports: [NumberAbbreviatorPipe],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HighlightPipe,
    [
      {
        type: Pipe,
        args: [
          {
            name: "highlight",
            pure: true,
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(HighlightPipeModule, {
      declarations: [HighlightPipe],
      exports: [HighlightPipe],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HighlightPipeModule,
    [
      {
        type: NgModule,
        args: [
          {
            declarations: [HighlightPipe],
            exports: [HighlightPipe],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(PipesModule, {
      imports: [
        EllipsisPipeModule,
        NullOrEmptyStringPipeModule,
        FileSizePipeModule,
        NumberAbbreviatorPipeModule,
        HighlightPipeModule,
      ],
      exports: [
        EllipsisPipeModule,
        NullOrEmptyStringPipeModule,
        FileSizePipeModule,
        NumberAbbreviatorPipeModule,
        HighlightPipeModule,
      ],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PipesModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [
              EllipsisPipeModule,
              NullOrEmptyStringPipeModule,
              FileSizePipeModule,
              NumberAbbreviatorPipeModule,
              HighlightPipeModule,
            ],
            exports: [
              EllipsisPipeModule,
              NullOrEmptyStringPipeModule,
              FileSizePipeModule,
              NumberAbbreviatorPipeModule,
              HighlightPipeModule,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    IconComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-icon",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-icon-sm,[icon-sm]{font-size:14px!important;height:14px!important;width:14px!important}.hc-icon-md,[icon-md]{font-size:20px!important;height:20px!important;width:20px!important}.hc-icon-lg,[icon-lg]{font-size:36px!important;height:36px!important;width:36px!important}.hc-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;font-size:20px;height:20px;text-align:center;width:20px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        {
          type: String,
          decorators: [
            {
              type: Attribute,
              args: ["aria-hidden"],
            },
          ],
        },
      ];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-icon"],
        },
      ],
      fontIcon: [
        {
          type: Input,
        },
      ],
      fontSet: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcIconSmallDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcIconSm]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcIconSmallClass: [
        {
          type: HostBinding,
          args: ["class.hc-icon-sm"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcIconMediumDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcIconMd]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcIconMediumClass: [
        {
          type: HostBinding,
          args: ["class.hc-icon-md"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcIconLargeDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcIconLg]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcIconLargeClass: [
        {
          type: HostBinding,
          args: ["class.hc-icon-lg"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(IconModule, {
      declarations: [
        IconComponent,
        HcIconSmallDirective,
        HcIconMediumDirective,
        HcIconLargeDirective,
      ],
      exports: [
        IconComponent,
        HcIconSmallDirective,
        HcIconMediumDirective,
        HcIconLargeDirective,
      ],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    IconModule,
    [
      {
        type: NgModule,
        args: [
          {
            declarations: [
              IconComponent,
              HcIconSmallDirective,
              HcIconMediumDirective,
              HcIconLargeDirective,
            ],
            exports: [
              IconComponent,
              HcIconSmallDirective,
              HcIconMediumDirective,
              HcIconLargeDirective,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(AppSwitcherModule, {
      declarations: function () {
        return [AppSwitcherComponent, AppSwitcherLinksComponent];
      },
      imports: function () {
        return [
          CommonModule,
          PopModule,
          HttpClientModule,
          PipesModule,
          IconModule,
          ProgressIndicatorsModule,
        ];
      },
      exports: function () {
        return [AppSwitcherComponent, AppSwitcherLinksComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AppSwitcherModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [
              CommonModule,
              PopModule,
              HttpClientModule,
              PipesModule,
              IconModule,
              ProgressIndicatorsModule,
            ],
            declarations: [AppSwitcherComponent, AppSwitcherLinksComponent],
            exports: [AppSwitcherComponent, AppSwitcherLinksComponent],
            entryComponents: [AppSwitcherComponent],
            providers: [
              {
                provide: APP_SWITCHER_SERVICE,
                useClass: AppSwitcherService,
              },
              WorkTrackerService,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcBannerComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-banner",
            template:
              '<div class="hc-banner hc-banner-{{type}}" [ngClass]="{\'hc-banner-dismiss\': clickDismiss}" (click)="_bannerClick($event)">\n    <ng-content></ng-content>\n    <span *ngIf="clickDismiss" class="hc-banner-close">\n        <div class="hc-banner-close-icon"></div>\n    </span>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-banner{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:start;justify-content:flex-start;padding:10px;width:100%;z-index:950}.hc-banner-dismiss{cursor:pointer;pointer-events:all}.hc-banner-dismiss.hc-banner-success:hover{background-color:#008f4b}.hc-banner-dismiss.hc-banner-warning:hover{background-color:#f48a08}.hc-banner-dismiss.hc-banner-alert:hover{background-color:#ef242e}.hc-banner-dismiss.hc-banner-info:hover{background-color:#c6e0ec}.hc-banner-success{background-color:#00a859;color:#fff}.hc-banner-warning{background-color:#f8961d;color:#fff}.hc-banner-alert{background-color:#f13c45;color:#fff}.hc-banner-info{background-color:#d9eaf2;border:1px solid #b3d5e6;border-left:none;border-right:none;color:#333}.hc-banner-close{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;margin-left:auto;padding-left:20px;padding-right:10px}.hc-banner-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNmZmY7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;height:15px;opacity:.6;width:15px}.hc-banner-info .hc-banner-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICMwMDZlOWE7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=)}.hc-banner-stamp{font-size:.78571rem;border-radius:4px;font-weight:700;letter-spacing:1px;margin:0 10px;padding:5px 15px}.hc-banner-success .hc-banner-stamp{background-color:#fff;color:#00a859}.hc-banner-warning .hc-banner-stamp{background-color:#fff;color:#f8961d}.hc-banner-alert .hc-banner-stamp{background-color:#fff;color:#f13c45}.hc-banner-info .hc-banner-stamp{background-color:#008bcc;color:#fff}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      bannerClose: [
        {
          type: Output,
        },
      ],
      type: [
        {
          type: Input,
        },
      ],
      clickDismiss: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    BannerStampDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcBannerStamp]",
          },
        ],
      },
    ],
    null,
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-banner-stamp"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(BannerModule, {
      declarations: function () {
        return [HcBannerComponent, BannerStampDirective];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [HcBannerComponent, BannerStampDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    BannerModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [HcBannerComponent, BannerStampDirective],
            declarations: [HcBannerComponent, BannerStampDirective],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    BreadcrumbsComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-breadcrumbs",
            template:
              '<ol class="breadcrumb">\n    <li *ngFor="let breadcrumb of _breadcrumbs; let last = last" class="breadcrumb-item">\n        <a *ngIf="!last" [routerLink]="[breadcrumb.url]" queryParamsHandling="{{queryParamsHandling}}" [innerText]="breadcrumb.label"></a>\n        <span *ngIf="last" [innerText]="breadcrumb.label"></span>\n        <i class="fa fa-chevron-right breadcrumb-arrow"></i>\n    </li>\n</ol>\n<div class="breadcrumb-responsive-container">\n    <a [style.display]="_backShow" class="breadcrumb-back-button" [routerLink]="_backURL" queryParamsHandling="{{queryParamsHandling}}">\n        <i class="fa fa-chevron-left"></i>\n        <span>&nbsp;Back</span>\n    </a>\n    <span [innerText]="_locationLabel"></span>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc6.ActivatedRoute }, { type: ɵngcc6.Router }];
    },
    {
      queryParamsHandling: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(BreadcrumbsModule, {
      declarations: function () {
        return [BreadcrumbsComponent];
      },
      imports: function () {
        return [CommonModule, RouterModule, IconModule];
      },
      exports: function () {
        return [BreadcrumbsComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    BreadcrumbsModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, RouterModule, IconModule],
            exports: [BreadcrumbsComponent],
            declarations: [BreadcrumbsComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ButtonComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "button[hc-button], button[hc-icon-button]",
            template: "<ng-content></ng-content>",
            host: {
              "[disabled]": "disabled || null",
            },
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-button{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:none;border-radius:5px;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif}.hc-button[disabled]{cursor:not-allowed}.hc-button:focus{outline:0;border-bottom:none;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button:active{background-image:none;outline:0}.hc-button::-moz-focus-inner{border:0}.hc-button.hc-primary{color:#fff;background-color:#00a859}.hc-button.hc-primary:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-primary:hover{background-color:#009750;color:#fff}.hc-button.hc-primary:active{background-color:#008647;color:#fff}.hc-button.hc-primary[disabled],.hc-button.hc-primary[disabled]:active,.hc-button.hc-primary[disabled]:focus,.hc-button.hc-primary[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-primary-alt{color:#fff;background-color:#6e53a3}.hc-button.hc-primary-alt:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-primary-alt:hover{background-color:#634b93;color:#fff}.hc-button.hc-primary-alt:active{background-color:#584282;color:#fff}.hc-button.hc-primary-alt[disabled],.hc-button.hc-primary-alt[disabled]:active,.hc-button.hc-primary-alt[disabled]:focus,.hc-button.hc-primary-alt[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-destructive{color:#fff;background-color:#f13c45}.hc-button.hc-destructive:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-destructive:hover{background-color:#d9363e;color:#fff}.hc-button.hc-destructive:active{background-color:#c13037;color:#fff}.hc-button.hc-destructive[disabled],.hc-button.hc-destructive[disabled]:active,.hc-button.hc-destructive[disabled]:focus,.hc-button.hc-destructive[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-neutral{color:#fff;background-color:#6d6e70}.hc-button.hc-neutral:focus{background-color:#57585a;box-shadow:0 0 0 3px rgba(109,110,112,.4)}.hc-button.hc-neutral:hover{background-color:#626365;color:#fff}.hc-button.hc-neutral:active{background-color:#57585a;color:#fff}.hc-button.hc-neutral[disabled],.hc-button.hc-neutral[disabled]:active,.hc-button.hc-neutral[disabled]:focus,.hc-button.hc-neutral[disabled]:hover{background-color:#6d6e70;opacity:.35}.hc-button.hc-secondary{background-color:#f1f1f1;color:#515353;border:1.5px solid #ccc;height:36px;line-height:33px;padding-right:19px}.hc-button.hc-secondary:focus{background-color:#d9d9d9;box-shadow:0 0 0 3px rgba(241,241,241,.4);box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button.hc-secondary:hover{background-color:#e5e5e5}.hc-button.hc-secondary:active{background-color:#d9d9d9;color:#fff}.hc-button.hc-secondary[disabled],.hc-button.hc-secondary[disabled]:active,.hc-button.hc-secondary[disabled]:focus,.hc-button.hc-secondary[disabled]:hover{background-color:#f1f1f1;opacity:.35}.hc-button.hc-secondary:hover{color:#333}.hc-button.hc-secondary[disabled]:hover{color:#515353}.hc-button.hc-minimal{background-color:transparent;color:#6d6e70}.hc-button.hc-minimal:hover{color:#333;background-color:#e0e0e0}.hc-button.hc-minimal:active{background-color:#d3d3d3}.hc-button.hc-minimal[disabled],.hc-button.hc-minimal[disabled]:active,.hc-button.hc-minimal[disabled]:focus,.hc-button.hc-minimal[disabled]:hover{background-color:transparent;color:#ccc}.hc-button.hc-sm{padding:3px 12px;height:26px;min-width:auto;font-size:1rem;line-height:14px}.hc-button.hc-md{padding:0 20px;height:35px;min-width:150px;font-size:1.07143rem;line-height:15px}.hc-button.hc-lg{padding:0 30px;height:40px;min-width:200px;font-size:1.21429rem;line-height:17px}.hc-button.hc-link,.hc-button.hc-link-inline{background-color:transparent;color:#00aeff;font-weight:600}.hc-button.hc-link .label,.hc-button.hc-link-inline .label{color:#6d6e70;font-weight:400;margin-right:10px}.hc-button.hc-link .value,.hc-button.hc-link-inline .value{color:#333;font-weight:400;margin-right:10px}.hc-button.hc-link-inline:hover,.hc-button.hc-link:hover{color:#33beff}.hc-button.hc-link-inline:active,.hc-button.hc-link:active{color:#008bcc}.hc-button.hc-link-inline[disabled],.hc-button.hc-link-inline[disabled]:active,.hc-button.hc-link-inline[disabled]:focus,.hc-button.hc-link-inline[disabled]:hover,.hc-button.hc-link[disabled],.hc-button.hc-link[disabled]:active,.hc-button.hc-link[disabled]:focus,.hc-button.hc-link[disabled]:hover{opacity:.35;color:#00aeff}.hc-button.hc-link-inline[disabled] .label,.hc-button.hc-link-inline[disabled] .value,.hc-button.hc-link-inline[disabled]:active .label,.hc-button.hc-link-inline[disabled]:active .value,.hc-button.hc-link-inline[disabled]:focus .label,.hc-button.hc-link-inline[disabled]:focus .value,.hc-button.hc-link-inline[disabled]:hover .label,.hc-button.hc-link-inline[disabled]:hover .value,.hc-button.hc-link[disabled] .label,.hc-button.hc-link[disabled] .value,.hc-button.hc-link[disabled]:active .label,.hc-button.hc-link[disabled]:active .value,.hc-button.hc-link[disabled]:focus .label,.hc-button.hc-link[disabled]:focus .value,.hc-button.hc-link[disabled]:hover .label,.hc-button.hc-link[disabled]:hover .value{color:#333}.hc-button.hc-link-inline{padding:0;height:auto;width:auto;min-width:0;font-size:inherit;line-height:inherit;text-align:inherit;white-space:inherit;vertical-align:inherit;font-family:inherit;border:none}.hc-button.hc-link-inline:focus{outline:0;border-radius:0;box-shadow:0 2px 0 0 #00aeff}.hc-button.hc-button-blue{color:#fff;background-color:#00aeff}.hc-button.hc-button-blue:focus{background-color:#008bcc;box-shadow:0 0 0 3px rgba(0,174,255,.4)}.hc-button.hc-button-blue:hover{background-color:#009de6;color:#fff}.hc-button.hc-button-blue:active{background-color:#008bcc;color:#fff}.hc-button.hc-button-blue[disabled],.hc-button.hc-button-blue[disabled]:active,.hc-button.hc-button-blue[disabled]:focus,.hc-button.hc-button-blue[disabled]:hover{background-color:#00aeff;opacity:.35}.hc-button.hc-button-green{color:#fff;background-color:#00a859}.hc-button.hc-button-green:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-button-green:hover{background-color:#009750;color:#fff}.hc-button.hc-button-green:active{background-color:#008647;color:#fff}.hc-button.hc-button-green[disabled],.hc-button.hc-button-green[disabled]:active,.hc-button.hc-button-green[disabled]:focus,.hc-button.hc-button-green[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-button-purple{color:#fff;background-color:#6e53a3}.hc-button.hc-button-purple:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-button-purple:hover{background-color:#634b93;color:#fff}.hc-button.hc-button-purple:active{background-color:#584282;color:#fff}.hc-button.hc-button-purple[disabled],.hc-button.hc-button-purple[disabled]:active,.hc-button.hc-button-purple[disabled]:focus,.hc-button.hc-button-purple[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-button-red{color:#fff;background-color:#f13c45}.hc-button.hc-button-red:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-button-red:hover{background-color:#d9363e;color:#fff}.hc-button.hc-button-red:active{background-color:#c13037;color:#fff}.hc-button.hc-button-red[disabled],.hc-button.hc-button-red[disabled]:active,.hc-button.hc-button-red[disabled]:focus,.hc-button.hc-button-red[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-button-orange{color:#fff;background-color:#f8961d}.hc-button.hc-button-orange:focus{background-color:#c67817;box-shadow:0 0 0 3px rgba(248,150,29,.4)}.hc-button.hc-button-orange:hover{background-color:#df871a;color:#fff}.hc-button.hc-button-orange:active{background-color:#c67817;color:#fff}.hc-button.hc-button-orange[disabled],.hc-button.hc-button-orange[disabled]:active,.hc-button.hc-button-orange[disabled]:focus,.hc-button.hc-button-orange[disabled]:hover{background-color:#f8961d;opacity:.35}.hc-button.hc-button-ruby-red{color:#fff;background-color:#951c1e}.hc-button.hc-button-ruby-red:focus{background-color:#771618;box-shadow:0 0 0 3px rgba(149,28,30,.4)}.hc-button.hc-button-ruby-red:hover{background-color:#86191b;color:#fff}.hc-button.hc-button-ruby-red:active{background-color:#771618;color:#fff}.hc-button.hc-button-ruby-red[disabled],.hc-button.hc-button-ruby-red[disabled]:active,.hc-button.hc-button-ruby-red[disabled]:focus,.hc-button.hc-button-ruby-red[disabled]:hover{background-color:#951c1e;opacity:.35}.hc-button.hc-button-deep-red{color:#fff;background-color:#cc2027}.hc-button.hc-button-deep-red:focus{background-color:#a31a1f;box-shadow:0 0 0 3px rgba(204,32,39,.4)}.hc-button.hc-button-deep-red:hover{background-color:#b81d23;color:#fff}.hc-button.hc-button-deep-red:active{background-color:#a31a1f;color:#fff}.hc-button.hc-button-deep-red[disabled],.hc-button.hc-button-deep-red[disabled]:active,.hc-button.hc-button-deep-red[disabled]:focus,.hc-button.hc-button-deep-red[disabled]:hover{background-color:#cc2027;opacity:.35}.hc-button.hc-button-red-orange{color:#fff;background-color:#f05323}.hc-button.hc-button-red-orange:focus{background-color:#c0421c;box-shadow:0 0 0 3px rgba(240,83,35,.4)}.hc-button.hc-button-red-orange:hover{background-color:#d84b20;color:#fff}.hc-button.hc-button-red-orange:active{background-color:#c0421c;color:#fff}.hc-button.hc-button-red-orange[disabled],.hc-button.hc-button-red-orange[disabled]:active,.hc-button.hc-button-red-orange[disabled]:focus,.hc-button.hc-button-red-orange[disabled]:hover{background-color:#f05323;opacity:.35}.hc-button.hc-button-magenta{color:#fff;background-color:#a94c9d}.hc-button.hc-button-magenta:focus{background-color:#873d7e;box-shadow:0 0 0 3px rgba(169,76,157,.4)}.hc-button.hc-button-magenta:hover{background-color:#98448d;color:#fff}.hc-button.hc-button-magenta:active{background-color:#873d7e;color:#fff}.hc-button.hc-button-magenta[disabled],.hc-button.hc-button-magenta[disabled]:active,.hc-button.hc-button-magenta[disabled]:focus,.hc-button.hc-button-magenta[disabled]:hover{background-color:#a94c9d;opacity:.35}.hc-button.hc-button-pink{color:#fff;background-color:#ef4767}.hc-button.hc-button-pink:focus{background-color:#bf3952;box-shadow:0 0 0 3px rgba(239,71,103,.4)}.hc-button.hc-button-pink:hover{background-color:#d7405d;color:#fff}.hc-button.hc-button-pink:active{background-color:#bf3952;color:#fff}.hc-button.hc-button-pink[disabled],.hc-button.hc-button-pink[disabled]:active,.hc-button.hc-button-pink[disabled]:focus,.hc-button.hc-button-pink[disabled]:hover{background-color:#ef4767;opacity:.35}.hc-button.hc-button-light-pink{color:#fff;background-color:#f8c8db}.hc-button.hc-button-light-pink:focus{background-color:#c6a0af;box-shadow:0 0 0 3px rgba(248,200,219,.4)}.hc-button.hc-button-light-pink:hover{background-color:#dfb4c5;color:#fff}.hc-button.hc-button-light-pink:active{background-color:#c6a0af;color:#fff}.hc-button.hc-button-light-pink[disabled],.hc-button.hc-button-light-pink[disabled]:active,.hc-button.hc-button-light-pink[disabled]:focus,.hc-button.hc-button-light-pink[disabled]:hover{background-color:#f8c8db;opacity:.35}.hc-button.hc-button-azure{color:#fff;background-color:#007bff}.hc-button.hc-button-azure:focus{background-color:#0062cc;box-shadow:0 0 0 3px rgba(0,123,255,.4)}.hc-button.hc-button-azure:hover{background-color:#006fe6;color:#fff}.hc-button.hc-button-azure:active{background-color:#0062cc;color:#fff}.hc-button.hc-button-azure[disabled],.hc-button.hc-button-azure[disabled]:active,.hc-button.hc-button-azure[disabled]:focus,.hc-button.hc-button-azure[disabled]:hover{background-color:#007bff;opacity:.35}.hc-button.hc-button-teal{color:#fff;background-color:#00acac}.hc-button.hc-button-teal:focus{background-color:#008a8a;box-shadow:0 0 0 3px rgba(0,172,172,.4)}.hc-button.hc-button-teal:hover{background-color:#009b9b;color:#fff}.hc-button.hc-button-teal:active{background-color:#008a8a;color:#fff}.hc-button.hc-button-teal[disabled],.hc-button.hc-button-teal[disabled]:active,.hc-button.hc-button-teal[disabled]:focus,.hc-button.hc-button-teal[disabled]:hover{background-color:#00acac;opacity:.35}.hc-button.hc-button-dark-green{color:#fff;background-color:#006c4e}.hc-button.hc-button-dark-green:focus{background-color:#00563e;box-shadow:0 0 0 3px rgba(0,108,78,.4)}.hc-button.hc-button-dark-green:hover{background-color:#006146;color:#fff}.hc-button.hc-button-dark-green:active{background-color:#00563e;color:#fff}.hc-button.hc-button-dark-green[disabled],.hc-button.hc-button-dark-green[disabled]:active,.hc-button.hc-button-dark-green[disabled]:focus,.hc-button.hc-button-dark-green[disabled]:hover{background-color:#006c4e;opacity:.35}.hc-button.hc-button-brown{color:#fff;background-color:#553e36}.hc-button.hc-button-brown:focus{background-color:#44322b;box-shadow:0 0 0 3px rgba(85,62,54,.4)}.hc-button.hc-button-brown:hover{background-color:#4d3831;color:#fff}.hc-button.hc-button-brown:active{background-color:#44322b;color:#fff}.hc-button.hc-button-brown[disabled],.hc-button.hc-button-brown[disabled]:active,.hc-button.hc-button-brown[disabled]:focus,.hc-button.hc-button-brown[disabled]:hover{background-color:#553e36;opacity:.35}.hc-button.hc-button-purple-gray{color:#fff;background-color:#776c7f}.hc-button.hc-button-purple-gray:focus{background-color:#5f5666;box-shadow:0 0 0 3px rgba(119,108,127,.4)}.hc-button.hc-button-purple-gray:hover{background-color:#6b6172;color:#fff}.hc-button.hc-button-purple-gray:active{background-color:#5f5666;color:#fff}.hc-button.hc-button-purple-gray[disabled],.hc-button.hc-button-purple-gray[disabled]:active,.hc-button.hc-button-purple-gray[disabled]:focus,.hc-button.hc-button-purple-gray[disabled]:hover{background-color:#776c7f;opacity:.35}.hc-button.hc-button-yellow{color:#fff;background-color:#f5ed56}.hc-button.hc-button-yellow:focus{background-color:#c4be45;box-shadow:0 0 0 3px rgba(245,237,86,.4)}.hc-button.hc-button-yellow:hover{background-color:#ddd54d;color:#fff}.hc-button.hc-button-yellow:active{background-color:#c4be45;color:#fff}.hc-button.hc-button-yellow[disabled],.hc-button.hc-button-yellow[disabled]:active,.hc-button.hc-button-yellow[disabled]:focus,.hc-button.hc-button-yellow[disabled]:hover{background-color:#f5ed56;opacity:.35}.hc-button.hc-button-yellow-orange{color:#fff;background-color:#e7c447}.hc-button.hc-button-yellow-orange:focus{background-color:#b99d39;box-shadow:0 0 0 3px rgba(231,196,71,.4)}.hc-button.hc-button-yellow-orange:hover{background-color:#d0b040;color:#fff}.hc-button.hc-button-yellow-orange:active{background-color:#b99d39;color:#fff}.hc-button.hc-button-yellow-orange[disabled],.hc-button.hc-button-yellow-orange[disabled]:active,.hc-button.hc-button-yellow-orange[disabled]:focus,.hc-button.hc-button-yellow-orange[disabled]:hover{background-color:#e7c447;opacity:.35}.hc-button.hc-button-tan{color:#fff;background-color:#ebba82}.hc-button.hc-button-tan:focus{background-color:#bc9568;box-shadow:0 0 0 3px rgba(235,186,130,.4)}.hc-button.hc-button-tan:hover{background-color:#d4a775;color:#fff}.hc-button.hc-button-tan:active{background-color:#bc9568;color:#fff}.hc-button.hc-button-tan[disabled],.hc-button.hc-button-tan[disabled]:active,.hc-button.hc-button-tan[disabled]:focus,.hc-button.hc-button-tan[disabled]:hover{background-color:#ebba82;opacity:.35}.hc-icon-button{display:inline-block;position:relative;height:35px;width:35px;line-height:35px;border-radius:5px;outline:0;border:none;margin:0;padding:0;background:0 0;text-decoration:none;cursor:pointer;white-space:nowrap;display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.hc-icon-button:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-icon-button::-moz-focus-inner{border:0}.hc-split-button{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal){min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal)::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-secondary{min-width:auto;padding:8px 12px;margin-left:0;border-left:0;border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle.hc-secondary::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-minimal{min-width:auto;padding:8px 12px;margin-left:0;border-bottom-left-radius:0;border-top-left-radius:0;border-left:2px solid rgba(0,0,0,.12)!important}.hc-split-button .hc-split-button-toggle.hc-minimal::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-sm{padding:3px 7px}.hc-split-button .hc-split-button-toggle.hc-sm::after{width:10px;height:6px;margin-top:1px}.hc-split-button .hc-split-button-toggle.hc-lg{padding:0 16px}.hc-split-button .hc-split-button-toggle.hc-lg::after{width:14px;height:9px}.hc-filters-icon{width:19px;height:19px;display:block;margin-right:7px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjU0NjEgNDcuMjUgMTkuMjgxIDIwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0iRmlsdGVyc19CdXR0b24iIGRhdGEtbmFtZT0iRmlsdGVycyBCdXR0b24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU0NjEgNjcuMjUpIHJvdGF0ZSgtOTApIj4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNCIgZGF0YS1uYW1lPSJQYXRoIDMwNCIgY2xhc3M9ImNscy0xIiBkPSJNOS45MzksMi45OTNWLjcxOUEuNzE5LjcxOSwwLDAsMCw4LjUuNzE5djIuMzZtMCw0Ljg5MnYxMC41OWgwYS43MTkuNzE5LDAsMSwwLDEuNDM5LDBWNy45NDIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02LjA1NCkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNSIgZGF0YS1uYW1lPSJQYXRoIDMwNSIgY2xhc3M9ImNscy0xIiBkPSJNNi40NzUsMTEuMDIzYTMuMjM3LDMuMjM3LDAsMCwwLTYuNDc1LDAsMy4yMzcsMy4yMzcsMCwwLDAsNi40NzUsMFptLTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEsMS43ODQsMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMS40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDYiIGRhdGEtbmFtZT0iUGF0aCAzMDYiIGNsYXNzPSJjbHMtMSIgZD0iTTU2LjkzOSwyLjk5M1YuNzE5YS43MTkuNzE5LDAsMCwwLTEuNDM5LDB2Mi4zNm0wLDQuODkydjEwLjU5aDBhLjcxOS43MTksMCwxLDAsMS40MzksMFY3Ljk0MiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTM5LjUyOSkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNyIgZGF0YS1uYW1lPSJQYXRoIDMwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTMuNDc1LDExLjAyM2EzLjIzNywzLjIzNywwLDEsMC0zLjI1MiwzLjIyM0EzLjIxOCwzLjIxOCwwLDAsMCw1My40NzUsMTEuMDIzWm0tNS4wMzYsMGExLjc4NCwxLjc4NCwwLDEsMSwxLjc4NCwxLjc4NEExLjc5MywxLjc5MywwLDAsMSw0OC40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMzLjQ3NSAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDgiIGRhdGEtbmFtZT0iUGF0aCAzMDgiIGNsYXNzPSJjbHMtMSIgZD0iTTMyLjUsMTYuMjg4djIuMjczYS43MTkuNzE5LDAsMCwwLDEuNDM5LDBWMTYuMm0wLTQuODkyVi43MTloMGEuNzE5LjcxOSwwLDAsMC0xLjQzOSwwVjExLjMzOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzLjE0NykiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwOSIgZGF0YS1uYW1lPSJQYXRoIDMwOSIgY2xhc3M9ImNscy0xIiBkPSJNMjMuNSw0MC4wMjNBMy4yMzcsMy4yMzcsMCwxLDAsMjYuNzUyLDM2LjgsMy4yMTgsMy4yMTgsMCwwLDAsMjMuNSw0MC4wMjNabTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEtMS43ODQtMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMjguNTM2LDQwLjAyM1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNi43MzcgLTI2LjIxKSIvPgogIDwvZz4KPC9zdmc+Cg==)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }];
    },
    {
      buttonStyle: [
        {
          type: Input,
        },
      ],
      size: [
        {
          type: Input,
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    AnchorComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "a[hc-button]",
            template: "<ng-content></ng-content>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-button{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:none;border-radius:5px;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif}.hc-button[disabled]{cursor:not-allowed}.hc-button:focus{outline:0;border-bottom:none;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button:active{background-image:none;outline:0}.hc-button::-moz-focus-inner{border:0}.hc-button.hc-primary{color:#fff;background-color:#00a859}.hc-button.hc-primary:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-primary:hover{background-color:#009750;color:#fff}.hc-button.hc-primary:active{background-color:#008647;color:#fff}.hc-button.hc-primary[disabled],.hc-button.hc-primary[disabled]:active,.hc-button.hc-primary[disabled]:focus,.hc-button.hc-primary[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-primary-alt{color:#fff;background-color:#6e53a3}.hc-button.hc-primary-alt:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-primary-alt:hover{background-color:#634b93;color:#fff}.hc-button.hc-primary-alt:active{background-color:#584282;color:#fff}.hc-button.hc-primary-alt[disabled],.hc-button.hc-primary-alt[disabled]:active,.hc-button.hc-primary-alt[disabled]:focus,.hc-button.hc-primary-alt[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-destructive{color:#fff;background-color:#f13c45}.hc-button.hc-destructive:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-destructive:hover{background-color:#d9363e;color:#fff}.hc-button.hc-destructive:active{background-color:#c13037;color:#fff}.hc-button.hc-destructive[disabled],.hc-button.hc-destructive[disabled]:active,.hc-button.hc-destructive[disabled]:focus,.hc-button.hc-destructive[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-neutral{color:#fff;background-color:#6d6e70}.hc-button.hc-neutral:focus{background-color:#57585a;box-shadow:0 0 0 3px rgba(109,110,112,.4)}.hc-button.hc-neutral:hover{background-color:#626365;color:#fff}.hc-button.hc-neutral:active{background-color:#57585a;color:#fff}.hc-button.hc-neutral[disabled],.hc-button.hc-neutral[disabled]:active,.hc-button.hc-neutral[disabled]:focus,.hc-button.hc-neutral[disabled]:hover{background-color:#6d6e70;opacity:.35}.hc-button.hc-secondary{background-color:#f1f1f1;color:#515353;border:1.5px solid #ccc;height:36px;line-height:33px;padding-right:19px}.hc-button.hc-secondary:focus{background-color:#d9d9d9;box-shadow:0 0 0 3px rgba(241,241,241,.4);box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button.hc-secondary:hover{background-color:#e5e5e5}.hc-button.hc-secondary:active{background-color:#d9d9d9;color:#fff}.hc-button.hc-secondary[disabled],.hc-button.hc-secondary[disabled]:active,.hc-button.hc-secondary[disabled]:focus,.hc-button.hc-secondary[disabled]:hover{background-color:#f1f1f1;opacity:.35}.hc-button.hc-secondary:hover{color:#333}.hc-button.hc-secondary[disabled]:hover{color:#515353}.hc-button.hc-minimal{background-color:transparent;color:#6d6e70}.hc-button.hc-minimal:hover{color:#333;background-color:#e0e0e0}.hc-button.hc-minimal:active{background-color:#d3d3d3}.hc-button.hc-minimal[disabled],.hc-button.hc-minimal[disabled]:active,.hc-button.hc-minimal[disabled]:focus,.hc-button.hc-minimal[disabled]:hover{background-color:transparent;color:#ccc}.hc-button.hc-sm{padding:3px 12px;height:26px;min-width:auto;font-size:1rem;line-height:14px}.hc-button.hc-md{padding:0 20px;height:35px;min-width:150px;font-size:1.07143rem;line-height:15px}.hc-button.hc-lg{padding:0 30px;height:40px;min-width:200px;font-size:1.21429rem;line-height:17px}.hc-button.hc-link,.hc-button.hc-link-inline{background-color:transparent;color:#00aeff;font-weight:600}.hc-button.hc-link .label,.hc-button.hc-link-inline .label{color:#6d6e70;font-weight:400;margin-right:10px}.hc-button.hc-link .value,.hc-button.hc-link-inline .value{color:#333;font-weight:400;margin-right:10px}.hc-button.hc-link-inline:hover,.hc-button.hc-link:hover{color:#33beff}.hc-button.hc-link-inline:active,.hc-button.hc-link:active{color:#008bcc}.hc-button.hc-link-inline[disabled],.hc-button.hc-link-inline[disabled]:active,.hc-button.hc-link-inline[disabled]:focus,.hc-button.hc-link-inline[disabled]:hover,.hc-button.hc-link[disabled],.hc-button.hc-link[disabled]:active,.hc-button.hc-link[disabled]:focus,.hc-button.hc-link[disabled]:hover{opacity:.35;color:#00aeff}.hc-button.hc-link-inline[disabled] .label,.hc-button.hc-link-inline[disabled] .value,.hc-button.hc-link-inline[disabled]:active .label,.hc-button.hc-link-inline[disabled]:active .value,.hc-button.hc-link-inline[disabled]:focus .label,.hc-button.hc-link-inline[disabled]:focus .value,.hc-button.hc-link-inline[disabled]:hover .label,.hc-button.hc-link-inline[disabled]:hover .value,.hc-button.hc-link[disabled] .label,.hc-button.hc-link[disabled] .value,.hc-button.hc-link[disabled]:active .label,.hc-button.hc-link[disabled]:active .value,.hc-button.hc-link[disabled]:focus .label,.hc-button.hc-link[disabled]:focus .value,.hc-button.hc-link[disabled]:hover .label,.hc-button.hc-link[disabled]:hover .value{color:#333}.hc-button.hc-link-inline{padding:0;height:auto;width:auto;min-width:0;font-size:inherit;line-height:inherit;text-align:inherit;white-space:inherit;vertical-align:inherit;font-family:inherit;border:none}.hc-button.hc-link-inline:focus{outline:0;border-radius:0;box-shadow:0 2px 0 0 #00aeff}.hc-button.hc-button-blue{color:#fff;background-color:#00aeff}.hc-button.hc-button-blue:focus{background-color:#008bcc;box-shadow:0 0 0 3px rgba(0,174,255,.4)}.hc-button.hc-button-blue:hover{background-color:#009de6;color:#fff}.hc-button.hc-button-blue:active{background-color:#008bcc;color:#fff}.hc-button.hc-button-blue[disabled],.hc-button.hc-button-blue[disabled]:active,.hc-button.hc-button-blue[disabled]:focus,.hc-button.hc-button-blue[disabled]:hover{background-color:#00aeff;opacity:.35}.hc-button.hc-button-green{color:#fff;background-color:#00a859}.hc-button.hc-button-green:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-button-green:hover{background-color:#009750;color:#fff}.hc-button.hc-button-green:active{background-color:#008647;color:#fff}.hc-button.hc-button-green[disabled],.hc-button.hc-button-green[disabled]:active,.hc-button.hc-button-green[disabled]:focus,.hc-button.hc-button-green[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-button-purple{color:#fff;background-color:#6e53a3}.hc-button.hc-button-purple:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-button-purple:hover{background-color:#634b93;color:#fff}.hc-button.hc-button-purple:active{background-color:#584282;color:#fff}.hc-button.hc-button-purple[disabled],.hc-button.hc-button-purple[disabled]:active,.hc-button.hc-button-purple[disabled]:focus,.hc-button.hc-button-purple[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-button-red{color:#fff;background-color:#f13c45}.hc-button.hc-button-red:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-button-red:hover{background-color:#d9363e;color:#fff}.hc-button.hc-button-red:active{background-color:#c13037;color:#fff}.hc-button.hc-button-red[disabled],.hc-button.hc-button-red[disabled]:active,.hc-button.hc-button-red[disabled]:focus,.hc-button.hc-button-red[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-button-orange{color:#fff;background-color:#f8961d}.hc-button.hc-button-orange:focus{background-color:#c67817;box-shadow:0 0 0 3px rgba(248,150,29,.4)}.hc-button.hc-button-orange:hover{background-color:#df871a;color:#fff}.hc-button.hc-button-orange:active{background-color:#c67817;color:#fff}.hc-button.hc-button-orange[disabled],.hc-button.hc-button-orange[disabled]:active,.hc-button.hc-button-orange[disabled]:focus,.hc-button.hc-button-orange[disabled]:hover{background-color:#f8961d;opacity:.35}.hc-button.hc-button-ruby-red{color:#fff;background-color:#951c1e}.hc-button.hc-button-ruby-red:focus{background-color:#771618;box-shadow:0 0 0 3px rgba(149,28,30,.4)}.hc-button.hc-button-ruby-red:hover{background-color:#86191b;color:#fff}.hc-button.hc-button-ruby-red:active{background-color:#771618;color:#fff}.hc-button.hc-button-ruby-red[disabled],.hc-button.hc-button-ruby-red[disabled]:active,.hc-button.hc-button-ruby-red[disabled]:focus,.hc-button.hc-button-ruby-red[disabled]:hover{background-color:#951c1e;opacity:.35}.hc-button.hc-button-deep-red{color:#fff;background-color:#cc2027}.hc-button.hc-button-deep-red:focus{background-color:#a31a1f;box-shadow:0 0 0 3px rgba(204,32,39,.4)}.hc-button.hc-button-deep-red:hover{background-color:#b81d23;color:#fff}.hc-button.hc-button-deep-red:active{background-color:#a31a1f;color:#fff}.hc-button.hc-button-deep-red[disabled],.hc-button.hc-button-deep-red[disabled]:active,.hc-button.hc-button-deep-red[disabled]:focus,.hc-button.hc-button-deep-red[disabled]:hover{background-color:#cc2027;opacity:.35}.hc-button.hc-button-red-orange{color:#fff;background-color:#f05323}.hc-button.hc-button-red-orange:focus{background-color:#c0421c;box-shadow:0 0 0 3px rgba(240,83,35,.4)}.hc-button.hc-button-red-orange:hover{background-color:#d84b20;color:#fff}.hc-button.hc-button-red-orange:active{background-color:#c0421c;color:#fff}.hc-button.hc-button-red-orange[disabled],.hc-button.hc-button-red-orange[disabled]:active,.hc-button.hc-button-red-orange[disabled]:focus,.hc-button.hc-button-red-orange[disabled]:hover{background-color:#f05323;opacity:.35}.hc-button.hc-button-magenta{color:#fff;background-color:#a94c9d}.hc-button.hc-button-magenta:focus{background-color:#873d7e;box-shadow:0 0 0 3px rgba(169,76,157,.4)}.hc-button.hc-button-magenta:hover{background-color:#98448d;color:#fff}.hc-button.hc-button-magenta:active{background-color:#873d7e;color:#fff}.hc-button.hc-button-magenta[disabled],.hc-button.hc-button-magenta[disabled]:active,.hc-button.hc-button-magenta[disabled]:focus,.hc-button.hc-button-magenta[disabled]:hover{background-color:#a94c9d;opacity:.35}.hc-button.hc-button-pink{color:#fff;background-color:#ef4767}.hc-button.hc-button-pink:focus{background-color:#bf3952;box-shadow:0 0 0 3px rgba(239,71,103,.4)}.hc-button.hc-button-pink:hover{background-color:#d7405d;color:#fff}.hc-button.hc-button-pink:active{background-color:#bf3952;color:#fff}.hc-button.hc-button-pink[disabled],.hc-button.hc-button-pink[disabled]:active,.hc-button.hc-button-pink[disabled]:focus,.hc-button.hc-button-pink[disabled]:hover{background-color:#ef4767;opacity:.35}.hc-button.hc-button-light-pink{color:#fff;background-color:#f8c8db}.hc-button.hc-button-light-pink:focus{background-color:#c6a0af;box-shadow:0 0 0 3px rgba(248,200,219,.4)}.hc-button.hc-button-light-pink:hover{background-color:#dfb4c5;color:#fff}.hc-button.hc-button-light-pink:active{background-color:#c6a0af;color:#fff}.hc-button.hc-button-light-pink[disabled],.hc-button.hc-button-light-pink[disabled]:active,.hc-button.hc-button-light-pink[disabled]:focus,.hc-button.hc-button-light-pink[disabled]:hover{background-color:#f8c8db;opacity:.35}.hc-button.hc-button-azure{color:#fff;background-color:#007bff}.hc-button.hc-button-azure:focus{background-color:#0062cc;box-shadow:0 0 0 3px rgba(0,123,255,.4)}.hc-button.hc-button-azure:hover{background-color:#006fe6;color:#fff}.hc-button.hc-button-azure:active{background-color:#0062cc;color:#fff}.hc-button.hc-button-azure[disabled],.hc-button.hc-button-azure[disabled]:active,.hc-button.hc-button-azure[disabled]:focus,.hc-button.hc-button-azure[disabled]:hover{background-color:#007bff;opacity:.35}.hc-button.hc-button-teal{color:#fff;background-color:#00acac}.hc-button.hc-button-teal:focus{background-color:#008a8a;box-shadow:0 0 0 3px rgba(0,172,172,.4)}.hc-button.hc-button-teal:hover{background-color:#009b9b;color:#fff}.hc-button.hc-button-teal:active{background-color:#008a8a;color:#fff}.hc-button.hc-button-teal[disabled],.hc-button.hc-button-teal[disabled]:active,.hc-button.hc-button-teal[disabled]:focus,.hc-button.hc-button-teal[disabled]:hover{background-color:#00acac;opacity:.35}.hc-button.hc-button-dark-green{color:#fff;background-color:#006c4e}.hc-button.hc-button-dark-green:focus{background-color:#00563e;box-shadow:0 0 0 3px rgba(0,108,78,.4)}.hc-button.hc-button-dark-green:hover{background-color:#006146;color:#fff}.hc-button.hc-button-dark-green:active{background-color:#00563e;color:#fff}.hc-button.hc-button-dark-green[disabled],.hc-button.hc-button-dark-green[disabled]:active,.hc-button.hc-button-dark-green[disabled]:focus,.hc-button.hc-button-dark-green[disabled]:hover{background-color:#006c4e;opacity:.35}.hc-button.hc-button-brown{color:#fff;background-color:#553e36}.hc-button.hc-button-brown:focus{background-color:#44322b;box-shadow:0 0 0 3px rgba(85,62,54,.4)}.hc-button.hc-button-brown:hover{background-color:#4d3831;color:#fff}.hc-button.hc-button-brown:active{background-color:#44322b;color:#fff}.hc-button.hc-button-brown[disabled],.hc-button.hc-button-brown[disabled]:active,.hc-button.hc-button-brown[disabled]:focus,.hc-button.hc-button-brown[disabled]:hover{background-color:#553e36;opacity:.35}.hc-button.hc-button-purple-gray{color:#fff;background-color:#776c7f}.hc-button.hc-button-purple-gray:focus{background-color:#5f5666;box-shadow:0 0 0 3px rgba(119,108,127,.4)}.hc-button.hc-button-purple-gray:hover{background-color:#6b6172;color:#fff}.hc-button.hc-button-purple-gray:active{background-color:#5f5666;color:#fff}.hc-button.hc-button-purple-gray[disabled],.hc-button.hc-button-purple-gray[disabled]:active,.hc-button.hc-button-purple-gray[disabled]:focus,.hc-button.hc-button-purple-gray[disabled]:hover{background-color:#776c7f;opacity:.35}.hc-button.hc-button-yellow{color:#fff;background-color:#f5ed56}.hc-button.hc-button-yellow:focus{background-color:#c4be45;box-shadow:0 0 0 3px rgba(245,237,86,.4)}.hc-button.hc-button-yellow:hover{background-color:#ddd54d;color:#fff}.hc-button.hc-button-yellow:active{background-color:#c4be45;color:#fff}.hc-button.hc-button-yellow[disabled],.hc-button.hc-button-yellow[disabled]:active,.hc-button.hc-button-yellow[disabled]:focus,.hc-button.hc-button-yellow[disabled]:hover{background-color:#f5ed56;opacity:.35}.hc-button.hc-button-yellow-orange{color:#fff;background-color:#e7c447}.hc-button.hc-button-yellow-orange:focus{background-color:#b99d39;box-shadow:0 0 0 3px rgba(231,196,71,.4)}.hc-button.hc-button-yellow-orange:hover{background-color:#d0b040;color:#fff}.hc-button.hc-button-yellow-orange:active{background-color:#b99d39;color:#fff}.hc-button.hc-button-yellow-orange[disabled],.hc-button.hc-button-yellow-orange[disabled]:active,.hc-button.hc-button-yellow-orange[disabled]:focus,.hc-button.hc-button-yellow-orange[disabled]:hover{background-color:#e7c447;opacity:.35}.hc-button.hc-button-tan{color:#fff;background-color:#ebba82}.hc-button.hc-button-tan:focus{background-color:#bc9568;box-shadow:0 0 0 3px rgba(235,186,130,.4)}.hc-button.hc-button-tan:hover{background-color:#d4a775;color:#fff}.hc-button.hc-button-tan:active{background-color:#bc9568;color:#fff}.hc-button.hc-button-tan[disabled],.hc-button.hc-button-tan[disabled]:active,.hc-button.hc-button-tan[disabled]:focus,.hc-button.hc-button-tan[disabled]:hover{background-color:#ebba82;opacity:.35}.hc-icon-button{display:inline-block;position:relative;height:35px;width:35px;line-height:35px;border-radius:5px;outline:0;border:none;margin:0;padding:0;background:0 0;text-decoration:none;cursor:pointer;white-space:nowrap;display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.hc-icon-button:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-icon-button::-moz-focus-inner{border:0}.hc-split-button{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal){min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal)::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-secondary{min-width:auto;padding:8px 12px;margin-left:0;border-left:0;border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle.hc-secondary::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-minimal{min-width:auto;padding:8px 12px;margin-left:0;border-bottom-left-radius:0;border-top-left-radius:0;border-left:2px solid rgba(0,0,0,.12)!important}.hc-split-button .hc-split-button-toggle.hc-minimal::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-sm{padding:3px 7px}.hc-split-button .hc-split-button-toggle.hc-sm::after{width:10px;height:6px;margin-top:1px}.hc-split-button .hc-split-button-toggle.hc-lg{padding:0 16px}.hc-split-button .hc-split-button-toggle.hc-lg::after{width:14px;height:9px}.hc-filters-icon{width:19px;height:19px;display:block;margin-right:7px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjU0NjEgNDcuMjUgMTkuMjgxIDIwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0iRmlsdGVyc19CdXR0b24iIGRhdGEtbmFtZT0iRmlsdGVycyBCdXR0b24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU0NjEgNjcuMjUpIHJvdGF0ZSgtOTApIj4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNCIgZGF0YS1uYW1lPSJQYXRoIDMwNCIgY2xhc3M9ImNscy0xIiBkPSJNOS45MzksMi45OTNWLjcxOUEuNzE5LjcxOSwwLDAsMCw4LjUuNzE5djIuMzZtMCw0Ljg5MnYxMC41OWgwYS43MTkuNzE5LDAsMSwwLDEuNDM5LDBWNy45NDIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02LjA1NCkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNSIgZGF0YS1uYW1lPSJQYXRoIDMwNSIgY2xhc3M9ImNscy0xIiBkPSJNNi40NzUsMTEuMDIzYTMuMjM3LDMuMjM3LDAsMCwwLTYuNDc1LDAsMy4yMzcsMy4yMzcsMCwwLDAsNi40NzUsMFptLTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEsMS43ODQsMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMS40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDYiIGRhdGEtbmFtZT0iUGF0aCAzMDYiIGNsYXNzPSJjbHMtMSIgZD0iTTU2LjkzOSwyLjk5M1YuNzE5YS43MTkuNzE5LDAsMCwwLTEuNDM5LDB2Mi4zNm0wLDQuODkydjEwLjU5aDBhLjcxOS43MTksMCwxLDAsMS40MzksMFY3Ljk0MiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTM5LjUyOSkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNyIgZGF0YS1uYW1lPSJQYXRoIDMwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTMuNDc1LDExLjAyM2EzLjIzNywzLjIzNywwLDEsMC0zLjI1MiwzLjIyM0EzLjIxOCwzLjIxOCwwLDAsMCw1My40NzUsMTEuMDIzWm0tNS4wMzYsMGExLjc4NCwxLjc4NCwwLDEsMSwxLjc4NCwxLjc4NEExLjc5MywxLjc5MywwLDAsMSw0OC40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMzLjQ3NSAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDgiIGRhdGEtbmFtZT0iUGF0aCAzMDgiIGNsYXNzPSJjbHMtMSIgZD0iTTMyLjUsMTYuMjg4djIuMjczYS43MTkuNzE5LDAsMCwwLDEuNDM5LDBWMTYuMm0wLTQuODkyVi43MTloMGEuNzE5LjcxOSwwLDAsMC0xLjQzOSwwVjExLjMzOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzLjE0NykiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwOSIgZGF0YS1uYW1lPSJQYXRoIDMwOSIgY2xhc3M9ImNscy0xIiBkPSJNMjMuNSw0MC4wMjNBMy4yMzcsMy4yMzcsMCwxLDAsMjYuNzUyLDM2LjgsMy4yMTgsMy4yMTgsMCwwLDAsMjMuNSw0MC4wMjNabTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEtMS43ODQtMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMjguNTM2LDQwLjAyM1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNi43MzcgLTI2LjIxKSIvPgogIDwvZz4KPC9zdmc+Cg==)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }];
    },
    {
      _hostAriaDisabled: [
        {
          type: HostBinding,
          args: ["attr.aria-disabled"],
        },
      ],
      _hostTabIndex: [
        {
          type: HostBinding,
          args: ["attr.tabindex"],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _handleClickEvents: [
        {
          type: HostListener,
          args: ["click", ["$event"]],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SplitButtonComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-split-button",
            template:
              '<span class="hc-split-button-wrap" [hcPop]="splitMenu" trigger="none">\n    <button\n        hc-button\n        class="hc-split-button-main"\n        [attr.type]="type"\n        [buttonStyle]="buttonStyle"\n        [size]="size"\n        [attr.title]="title"\n        [attr.name]="name"\n        [attr.value]="value"\n        [tabIndex]="tabIndex"\n        [disabled]="disabled"\n        (click)="_mainBtnClick($event)"\n    >\n        <ng-content></ng-content>\n    </button>\n    <button\n        #splitBtnToggle\n        hc-button\n        class="hc-split-button-toggle"\n        type="button"\n        [buttonStyle]="buttonStyle"\n        [size]="size"\n        (click)="_stopClick($event); openMenu()"\n        [disabled]="disabled"\n        trigger="none"\n    ></button>\n</span>\n\n<hc-pop #splitMenu [xAlign]="menuPosition" [autoCloseOnContentClick]="autoCloseMenuOnClick" [showArrow]="false">\n    <div hcMenu>\n        <ng-content select="[hcButtonItem], [hcMenuItem]"></ng-content>\n    </div>\n</hc-pop>\n',
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-button{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:none;border-radius:5px;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif}.hc-button[disabled]{cursor:not-allowed}.hc-button:focus{outline:0;border-bottom:none;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button:active{background-image:none;outline:0}.hc-button::-moz-focus-inner{border:0}.hc-button.hc-primary{color:#fff;background-color:#00a859}.hc-button.hc-primary:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-primary:hover{background-color:#009750;color:#fff}.hc-button.hc-primary:active{background-color:#008647;color:#fff}.hc-button.hc-primary[disabled],.hc-button.hc-primary[disabled]:active,.hc-button.hc-primary[disabled]:focus,.hc-button.hc-primary[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-primary-alt{color:#fff;background-color:#6e53a3}.hc-button.hc-primary-alt:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-primary-alt:hover{background-color:#634b93;color:#fff}.hc-button.hc-primary-alt:active{background-color:#584282;color:#fff}.hc-button.hc-primary-alt[disabled],.hc-button.hc-primary-alt[disabled]:active,.hc-button.hc-primary-alt[disabled]:focus,.hc-button.hc-primary-alt[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-destructive{color:#fff;background-color:#f13c45}.hc-button.hc-destructive:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-destructive:hover{background-color:#d9363e;color:#fff}.hc-button.hc-destructive:active{background-color:#c13037;color:#fff}.hc-button.hc-destructive[disabled],.hc-button.hc-destructive[disabled]:active,.hc-button.hc-destructive[disabled]:focus,.hc-button.hc-destructive[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-neutral{color:#fff;background-color:#6d6e70}.hc-button.hc-neutral:focus{background-color:#57585a;box-shadow:0 0 0 3px rgba(109,110,112,.4)}.hc-button.hc-neutral:hover{background-color:#626365;color:#fff}.hc-button.hc-neutral:active{background-color:#57585a;color:#fff}.hc-button.hc-neutral[disabled],.hc-button.hc-neutral[disabled]:active,.hc-button.hc-neutral[disabled]:focus,.hc-button.hc-neutral[disabled]:hover{background-color:#6d6e70;opacity:.35}.hc-button.hc-secondary{background-color:#f1f1f1;color:#515353;border:1.5px solid #ccc;height:36px;line-height:33px;padding-right:19px}.hc-button.hc-secondary:focus{background-color:#d9d9d9;box-shadow:0 0 0 3px rgba(241,241,241,.4);box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-button.hc-secondary:hover{background-color:#e5e5e5}.hc-button.hc-secondary:active{background-color:#d9d9d9;color:#fff}.hc-button.hc-secondary[disabled],.hc-button.hc-secondary[disabled]:active,.hc-button.hc-secondary[disabled]:focus,.hc-button.hc-secondary[disabled]:hover{background-color:#f1f1f1;opacity:.35}.hc-button.hc-secondary:hover{color:#333}.hc-button.hc-secondary[disabled]:hover{color:#515353}.hc-button.hc-minimal{background-color:transparent;color:#6d6e70}.hc-button.hc-minimal:hover{color:#333;background-color:#e0e0e0}.hc-button.hc-minimal:active{background-color:#d3d3d3}.hc-button.hc-minimal[disabled],.hc-button.hc-minimal[disabled]:active,.hc-button.hc-minimal[disabled]:focus,.hc-button.hc-minimal[disabled]:hover{background-color:transparent;color:#ccc}.hc-button.hc-sm{padding:3px 12px;height:26px;min-width:auto;font-size:1rem;line-height:14px}.hc-button.hc-md{padding:0 20px;height:35px;min-width:150px;font-size:1.07143rem;line-height:15px}.hc-button.hc-lg{padding:0 30px;height:40px;min-width:200px;font-size:1.21429rem;line-height:17px}.hc-button.hc-link,.hc-button.hc-link-inline{background-color:transparent;color:#00aeff;font-weight:600}.hc-button.hc-link .label,.hc-button.hc-link-inline .label{color:#6d6e70;font-weight:400;margin-right:10px}.hc-button.hc-link .value,.hc-button.hc-link-inline .value{color:#333;font-weight:400;margin-right:10px}.hc-button.hc-link-inline:hover,.hc-button.hc-link:hover{color:#33beff}.hc-button.hc-link-inline:active,.hc-button.hc-link:active{color:#008bcc}.hc-button.hc-link-inline[disabled],.hc-button.hc-link-inline[disabled]:active,.hc-button.hc-link-inline[disabled]:focus,.hc-button.hc-link-inline[disabled]:hover,.hc-button.hc-link[disabled],.hc-button.hc-link[disabled]:active,.hc-button.hc-link[disabled]:focus,.hc-button.hc-link[disabled]:hover{opacity:.35;color:#00aeff}.hc-button.hc-link-inline[disabled] .label,.hc-button.hc-link-inline[disabled] .value,.hc-button.hc-link-inline[disabled]:active .label,.hc-button.hc-link-inline[disabled]:active .value,.hc-button.hc-link-inline[disabled]:focus .label,.hc-button.hc-link-inline[disabled]:focus .value,.hc-button.hc-link-inline[disabled]:hover .label,.hc-button.hc-link-inline[disabled]:hover .value,.hc-button.hc-link[disabled] .label,.hc-button.hc-link[disabled] .value,.hc-button.hc-link[disabled]:active .label,.hc-button.hc-link[disabled]:active .value,.hc-button.hc-link[disabled]:focus .label,.hc-button.hc-link[disabled]:focus .value,.hc-button.hc-link[disabled]:hover .label,.hc-button.hc-link[disabled]:hover .value{color:#333}.hc-button.hc-link-inline{padding:0;height:auto;width:auto;min-width:0;font-size:inherit;line-height:inherit;text-align:inherit;white-space:inherit;vertical-align:inherit;font-family:inherit;border:none}.hc-button.hc-link-inline:focus{outline:0;border-radius:0;box-shadow:0 2px 0 0 #00aeff}.hc-button.hc-button-blue{color:#fff;background-color:#00aeff}.hc-button.hc-button-blue:focus{background-color:#008bcc;box-shadow:0 0 0 3px rgba(0,174,255,.4)}.hc-button.hc-button-blue:hover{background-color:#009de6;color:#fff}.hc-button.hc-button-blue:active{background-color:#008bcc;color:#fff}.hc-button.hc-button-blue[disabled],.hc-button.hc-button-blue[disabled]:active,.hc-button.hc-button-blue[disabled]:focus,.hc-button.hc-button-blue[disabled]:hover{background-color:#00aeff;opacity:.35}.hc-button.hc-button-green{color:#fff;background-color:#00a859}.hc-button.hc-button-green:focus{background-color:#008647;box-shadow:0 0 0 3px rgba(0,168,89,.4)}.hc-button.hc-button-green:hover{background-color:#009750;color:#fff}.hc-button.hc-button-green:active{background-color:#008647;color:#fff}.hc-button.hc-button-green[disabled],.hc-button.hc-button-green[disabled]:active,.hc-button.hc-button-green[disabled]:focus,.hc-button.hc-button-green[disabled]:hover{background-color:#00a859;opacity:.35}.hc-button.hc-button-purple{color:#fff;background-color:#6e53a3}.hc-button.hc-button-purple:focus{background-color:#584282;box-shadow:0 0 0 3px rgba(110,83,163,.4)}.hc-button.hc-button-purple:hover{background-color:#634b93;color:#fff}.hc-button.hc-button-purple:active{background-color:#584282;color:#fff}.hc-button.hc-button-purple[disabled],.hc-button.hc-button-purple[disabled]:active,.hc-button.hc-button-purple[disabled]:focus,.hc-button.hc-button-purple[disabled]:hover{background-color:#6e53a3;opacity:.35}.hc-button.hc-button-red{color:#fff;background-color:#f13c45}.hc-button.hc-button-red:focus{background-color:#c13037;box-shadow:0 0 0 3px rgba(241,60,69,.4)}.hc-button.hc-button-red:hover{background-color:#d9363e;color:#fff}.hc-button.hc-button-red:active{background-color:#c13037;color:#fff}.hc-button.hc-button-red[disabled],.hc-button.hc-button-red[disabled]:active,.hc-button.hc-button-red[disabled]:focus,.hc-button.hc-button-red[disabled]:hover{background-color:#f13c45;opacity:.35}.hc-button.hc-button-orange{color:#fff;background-color:#f8961d}.hc-button.hc-button-orange:focus{background-color:#c67817;box-shadow:0 0 0 3px rgba(248,150,29,.4)}.hc-button.hc-button-orange:hover{background-color:#df871a;color:#fff}.hc-button.hc-button-orange:active{background-color:#c67817;color:#fff}.hc-button.hc-button-orange[disabled],.hc-button.hc-button-orange[disabled]:active,.hc-button.hc-button-orange[disabled]:focus,.hc-button.hc-button-orange[disabled]:hover{background-color:#f8961d;opacity:.35}.hc-button.hc-button-ruby-red{color:#fff;background-color:#951c1e}.hc-button.hc-button-ruby-red:focus{background-color:#771618;box-shadow:0 0 0 3px rgba(149,28,30,.4)}.hc-button.hc-button-ruby-red:hover{background-color:#86191b;color:#fff}.hc-button.hc-button-ruby-red:active{background-color:#771618;color:#fff}.hc-button.hc-button-ruby-red[disabled],.hc-button.hc-button-ruby-red[disabled]:active,.hc-button.hc-button-ruby-red[disabled]:focus,.hc-button.hc-button-ruby-red[disabled]:hover{background-color:#951c1e;opacity:.35}.hc-button.hc-button-deep-red{color:#fff;background-color:#cc2027}.hc-button.hc-button-deep-red:focus{background-color:#a31a1f;box-shadow:0 0 0 3px rgba(204,32,39,.4)}.hc-button.hc-button-deep-red:hover{background-color:#b81d23;color:#fff}.hc-button.hc-button-deep-red:active{background-color:#a31a1f;color:#fff}.hc-button.hc-button-deep-red[disabled],.hc-button.hc-button-deep-red[disabled]:active,.hc-button.hc-button-deep-red[disabled]:focus,.hc-button.hc-button-deep-red[disabled]:hover{background-color:#cc2027;opacity:.35}.hc-button.hc-button-red-orange{color:#fff;background-color:#f05323}.hc-button.hc-button-red-orange:focus{background-color:#c0421c;box-shadow:0 0 0 3px rgba(240,83,35,.4)}.hc-button.hc-button-red-orange:hover{background-color:#d84b20;color:#fff}.hc-button.hc-button-red-orange:active{background-color:#c0421c;color:#fff}.hc-button.hc-button-red-orange[disabled],.hc-button.hc-button-red-orange[disabled]:active,.hc-button.hc-button-red-orange[disabled]:focus,.hc-button.hc-button-red-orange[disabled]:hover{background-color:#f05323;opacity:.35}.hc-button.hc-button-magenta{color:#fff;background-color:#a94c9d}.hc-button.hc-button-magenta:focus{background-color:#873d7e;box-shadow:0 0 0 3px rgba(169,76,157,.4)}.hc-button.hc-button-magenta:hover{background-color:#98448d;color:#fff}.hc-button.hc-button-magenta:active{background-color:#873d7e;color:#fff}.hc-button.hc-button-magenta[disabled],.hc-button.hc-button-magenta[disabled]:active,.hc-button.hc-button-magenta[disabled]:focus,.hc-button.hc-button-magenta[disabled]:hover{background-color:#a94c9d;opacity:.35}.hc-button.hc-button-pink{color:#fff;background-color:#ef4767}.hc-button.hc-button-pink:focus{background-color:#bf3952;box-shadow:0 0 0 3px rgba(239,71,103,.4)}.hc-button.hc-button-pink:hover{background-color:#d7405d;color:#fff}.hc-button.hc-button-pink:active{background-color:#bf3952;color:#fff}.hc-button.hc-button-pink[disabled],.hc-button.hc-button-pink[disabled]:active,.hc-button.hc-button-pink[disabled]:focus,.hc-button.hc-button-pink[disabled]:hover{background-color:#ef4767;opacity:.35}.hc-button.hc-button-light-pink{color:#fff;background-color:#f8c8db}.hc-button.hc-button-light-pink:focus{background-color:#c6a0af;box-shadow:0 0 0 3px rgba(248,200,219,.4)}.hc-button.hc-button-light-pink:hover{background-color:#dfb4c5;color:#fff}.hc-button.hc-button-light-pink:active{background-color:#c6a0af;color:#fff}.hc-button.hc-button-light-pink[disabled],.hc-button.hc-button-light-pink[disabled]:active,.hc-button.hc-button-light-pink[disabled]:focus,.hc-button.hc-button-light-pink[disabled]:hover{background-color:#f8c8db;opacity:.35}.hc-button.hc-button-azure{color:#fff;background-color:#007bff}.hc-button.hc-button-azure:focus{background-color:#0062cc;box-shadow:0 0 0 3px rgba(0,123,255,.4)}.hc-button.hc-button-azure:hover{background-color:#006fe6;color:#fff}.hc-button.hc-button-azure:active{background-color:#0062cc;color:#fff}.hc-button.hc-button-azure[disabled],.hc-button.hc-button-azure[disabled]:active,.hc-button.hc-button-azure[disabled]:focus,.hc-button.hc-button-azure[disabled]:hover{background-color:#007bff;opacity:.35}.hc-button.hc-button-teal{color:#fff;background-color:#00acac}.hc-button.hc-button-teal:focus{background-color:#008a8a;box-shadow:0 0 0 3px rgba(0,172,172,.4)}.hc-button.hc-button-teal:hover{background-color:#009b9b;color:#fff}.hc-button.hc-button-teal:active{background-color:#008a8a;color:#fff}.hc-button.hc-button-teal[disabled],.hc-button.hc-button-teal[disabled]:active,.hc-button.hc-button-teal[disabled]:focus,.hc-button.hc-button-teal[disabled]:hover{background-color:#00acac;opacity:.35}.hc-button.hc-button-dark-green{color:#fff;background-color:#006c4e}.hc-button.hc-button-dark-green:focus{background-color:#00563e;box-shadow:0 0 0 3px rgba(0,108,78,.4)}.hc-button.hc-button-dark-green:hover{background-color:#006146;color:#fff}.hc-button.hc-button-dark-green:active{background-color:#00563e;color:#fff}.hc-button.hc-button-dark-green[disabled],.hc-button.hc-button-dark-green[disabled]:active,.hc-button.hc-button-dark-green[disabled]:focus,.hc-button.hc-button-dark-green[disabled]:hover{background-color:#006c4e;opacity:.35}.hc-button.hc-button-brown{color:#fff;background-color:#553e36}.hc-button.hc-button-brown:focus{background-color:#44322b;box-shadow:0 0 0 3px rgba(85,62,54,.4)}.hc-button.hc-button-brown:hover{background-color:#4d3831;color:#fff}.hc-button.hc-button-brown:active{background-color:#44322b;color:#fff}.hc-button.hc-button-brown[disabled],.hc-button.hc-button-brown[disabled]:active,.hc-button.hc-button-brown[disabled]:focus,.hc-button.hc-button-brown[disabled]:hover{background-color:#553e36;opacity:.35}.hc-button.hc-button-purple-gray{color:#fff;background-color:#776c7f}.hc-button.hc-button-purple-gray:focus{background-color:#5f5666;box-shadow:0 0 0 3px rgba(119,108,127,.4)}.hc-button.hc-button-purple-gray:hover{background-color:#6b6172;color:#fff}.hc-button.hc-button-purple-gray:active{background-color:#5f5666;color:#fff}.hc-button.hc-button-purple-gray[disabled],.hc-button.hc-button-purple-gray[disabled]:active,.hc-button.hc-button-purple-gray[disabled]:focus,.hc-button.hc-button-purple-gray[disabled]:hover{background-color:#776c7f;opacity:.35}.hc-button.hc-button-yellow{color:#fff;background-color:#f5ed56}.hc-button.hc-button-yellow:focus{background-color:#c4be45;box-shadow:0 0 0 3px rgba(245,237,86,.4)}.hc-button.hc-button-yellow:hover{background-color:#ddd54d;color:#fff}.hc-button.hc-button-yellow:active{background-color:#c4be45;color:#fff}.hc-button.hc-button-yellow[disabled],.hc-button.hc-button-yellow[disabled]:active,.hc-button.hc-button-yellow[disabled]:focus,.hc-button.hc-button-yellow[disabled]:hover{background-color:#f5ed56;opacity:.35}.hc-button.hc-button-yellow-orange{color:#fff;background-color:#e7c447}.hc-button.hc-button-yellow-orange:focus{background-color:#b99d39;box-shadow:0 0 0 3px rgba(231,196,71,.4)}.hc-button.hc-button-yellow-orange:hover{background-color:#d0b040;color:#fff}.hc-button.hc-button-yellow-orange:active{background-color:#b99d39;color:#fff}.hc-button.hc-button-yellow-orange[disabled],.hc-button.hc-button-yellow-orange[disabled]:active,.hc-button.hc-button-yellow-orange[disabled]:focus,.hc-button.hc-button-yellow-orange[disabled]:hover{background-color:#e7c447;opacity:.35}.hc-button.hc-button-tan{color:#fff;background-color:#ebba82}.hc-button.hc-button-tan:focus{background-color:#bc9568;box-shadow:0 0 0 3px rgba(235,186,130,.4)}.hc-button.hc-button-tan:hover{background-color:#d4a775;color:#fff}.hc-button.hc-button-tan:active{background-color:#bc9568;color:#fff}.hc-button.hc-button-tan[disabled],.hc-button.hc-button-tan[disabled]:active,.hc-button.hc-button-tan[disabled]:focus,.hc-button.hc-button-tan[disabled]:hover{background-color:#ebba82;opacity:.35}.hc-icon-button{display:inline-block;position:relative;height:35px;width:35px;line-height:35px;border-radius:5px;outline:0;border:none;margin:0;padding:0;background:0 0;text-decoration:none;cursor:pointer;white-space:nowrap;display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.hc-icon-button:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-icon-button::-moz-focus-inner{border:0}.hc-split-button{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal){min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle:not(.hc-secondary):not(.hc-minimal)::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-secondary{min-width:auto;padding:8px 12px;margin-left:0;border-left:0;border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle.hc-secondary::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-minimal{min-width:auto;padding:8px 12px;margin-left:0;border-bottom-left-radius:0;border-top-left-radius:0;border-left:2px solid rgba(0,0,0,.12)!important}.hc-split-button .hc-split-button-toggle.hc-minimal::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMzMzOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}.hc-split-button .hc-split-button-toggle.hc-sm{padding:3px 7px}.hc-split-button .hc-split-button-toggle.hc-sm::after{width:10px;height:6px;margin-top:1px}.hc-split-button .hc-split-button-toggle.hc-lg{padding:0 16px}.hc-split-button .hc-split-button-toggle.hc-lg::after{width:14px;height:9px}.hc-filters-icon{width:19px;height:19px;display:block;margin-right:7px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjU0NjEgNDcuMjUgMTkuMjgxIDIwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0iRmlsdGVyc19CdXR0b24iIGRhdGEtbmFtZT0iRmlsdGVycyBCdXR0b24iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU0NjEgNjcuMjUpIHJvdGF0ZSgtOTApIj4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNCIgZGF0YS1uYW1lPSJQYXRoIDMwNCIgY2xhc3M9ImNscy0xIiBkPSJNOS45MzksMi45OTNWLjcxOUEuNzE5LjcxOSwwLDAsMCw4LjUuNzE5djIuMzZtMCw0Ljg5MnYxMC41OWgwYS43MTkuNzE5LDAsMSwwLDEuNDM5LDBWNy45NDIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02LjA1NCkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNSIgZGF0YS1uYW1lPSJQYXRoIDMwNSIgY2xhc3M9ImNscy0xIiBkPSJNNi40NzUsMTEuMDIzYTMuMjM3LDMuMjM3LDAsMCwwLTYuNDc1LDAsMy4yMzcsMy4yMzcsMCwwLDAsNi40NzUsMFptLTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEsMS43ODQsMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMS40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDYiIGRhdGEtbmFtZT0iUGF0aCAzMDYiIGNsYXNzPSJjbHMtMSIgZD0iTTU2LjkzOSwyLjk5M1YuNzE5YS43MTkuNzE5LDAsMCwwLTEuNDM5LDB2Mi4zNm0wLDQuODkydjEwLjU5aDBhLjcxOS43MTksMCwxLDAsMS40MzksMFY3Ljk0MiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTM5LjUyOSkiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwNyIgZGF0YS1uYW1lPSJQYXRoIDMwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTMuNDc1LDExLjAyM2EzLjIzNywzLjIzNywwLDEsMC0zLjI1MiwzLjIyM0EzLjIxOCwzLjIxOCwwLDAsMCw1My40NzUsMTEuMDIzWm0tNS4wMzYsMGExLjc4NCwxLjc4NCwwLDEsMSwxLjc4NCwxLjc4NEExLjc5MywxLjc5MywwLDAsMSw0OC40MzksMTEuMDIzWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMzLjQ3NSAtNS41NTUpIi8+CiAgICA8cGF0aCBpZD0iUGF0aF8zMDgiIGRhdGEtbmFtZT0iUGF0aCAzMDgiIGNsYXNzPSJjbHMtMSIgZD0iTTMyLjUsMTYuMjg4djIuMjczYS43MTkuNzE5LDAsMCwwLDEuNDM5LDBWMTYuMm0wLTQuODkyVi43MTloMGEuNzE5LjcxOSwwLDAsMC0xLjQzOSwwVjExLjMzOCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIzLjE0NykiLz4KICAgIDxwYXRoIGlkPSJQYXRoXzMwOSIgZGF0YS1uYW1lPSJQYXRoIDMwOSIgY2xhc3M9ImNscy0xIiBkPSJNMjMuNSw0MC4wMjNBMy4yMzcsMy4yMzcsMCwxLDAsMjYuNzUyLDM2LjgsMy4yMTgsMy4yMTgsMCwwLDAsMjMuNSw0MC4wMjNabTUuMDM2LDBhMS43ODQsMS43ODQsMCwxLDEtMS43ODQtMS43ODRBMS43OTMsMS43OTMsMCwwLDEsMjguNTM2LDQwLjAyM1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNi43MzcgLTI2LjIxKSIvPgogIDwvZz4KPC9zdmc+Cg==)}",
              ".hc-split-button,.hc-split-button .hc-split-button-wrap{display:-webkit-inline-box;display:inline-flex}.hc-split-button .hc-split-button-main{margin-right:0;border-bottom-right-radius:0;border-top-right-radius:0;min-width:auto}.hc-split-button .hc-split-button-toggle{min-width:auto;padding:8px 12px;margin-left:0;border-left:1px solid rgba(0,0,0,.12);border-bottom-left-radius:0;border-top-left-radius:0}.hc-split-button .hc-split-button-toggle::after{content:'';width:12px;height:8px;margin-top:2px;display:inline-block;background-repeat:no-repeat;background-size:contain;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSI4Ljk4NyIgdmlld0JveD0iMCAwIDE0IDguOTg3Ij4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTUuMzQ4LTE0LjRhLjU2MS41NjEsMCwwLDAsMC0uNzkxbC0xLjQ0Mi0xLjQzM2EuNTUxLjU1MSwwLDAsMC0uNzgyLDBMOC41MTEtMTIuMDExLDMuOS0xNi42MjRhLjU1MS41NTEsMCwwLDAtLjc4MiwwTDEuNjc0LTE1LjE5MWEuNTYxLjU2MSwwLDAsMCwwLC43OTFMOC4xMi03Ljk2M2EuNTUxLjU1MSwwLDAsMCwuNzgyLDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      click: [
        {
          type: Output,
        },
      ],
      menuPosition: [
        {
          type: Input,
        },
      ],
      autoCloseMenuOnClick: [
        {
          type: Input,
        },
      ],
      type: [
        {
          type: Input,
        },
      ],
      tabIndex: [
        {
          type: Input,
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
      buttonStyle: [
        {
          type: Input,
        },
      ],
      size: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-split-button"],
        },
      ],
      _splitBtnToggle: [
        {
          type: ViewChild,
          args: ["splitBtnToggle", { static: false }],
        },
      ],
      _splitMenu: [
        {
          type: ViewChild,
          args: ["splitMenu", { static: false }],
        },
      ],
      _menuItems: [
        {
          type: ContentChildren,
          args: [MenuItemDirective, { descendants: true }],
        },
      ],
      title: [
        {
          type: Input,
        },
      ],
      name: [
        {
          type: Input,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ButtonModule, {
      declarations: function () {
        return [AnchorComponent, ButtonComponent, SplitButtonComponent];
      },
      imports: function () {
        return [CommonModule, PopModule];
      },
      exports: function () {
        return [
          AnchorComponent,
          ButtonComponent,
          SplitButtonComponent,
          PopModule,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ButtonModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, PopModule],
            declarations: [
              AnchorComponent,
              ButtonComponent,
              SplitButtonComponent,
            ],
            exports: [
              AnchorComponent,
              ButtonComponent,
              SplitButtonComponent,
              PopModule,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵCheckboxGroup_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  CheckboxGroup
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CheckboxGroup,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-checkbox-group",
            providers: [
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => CheckboxGroup
                ),
              },
            ],
            exportAs: "hcCheckboxGroup",
            template: `
        <hc-checkbox *ngIf="!_disableParent" [checked]="_groupState" [indeterminate]="_isIndeterminate" (change)="toggleCheckAll()">{{_parentLabel}}</hc-checkbox>
        <div [class.hc-checkbox-children-group]="!_disableParent">
            <ng-content></ng-content>
        </div>
        `,
            styles: [
              ".hc-checkbox-container{display:-webkit-box;display:flex}.hc-checkbox-container input[type=checkbox]{display:none}.hc-checkbox-content{display:-webkit-inline-box;display:inline-flex;cursor:pointer}.hc-checkbox-content label{cursor:pointer}.hc-checkbox-disabled .hc-checkbox-content{color:#ccc;cursor:not-allowed}.hc-checkbox-disabled .hc-checkbox-content label{cursor:not-allowed}.hc-checkbox-children-group{margin-left:25px;margin-top:5px}.hc-checkbox-align-center{-webkit-box-align:center;align-items:center}.hc-checkbox-align-top{-webkit-box-align:start;align-items:flex-start}.hc-checkbox-align-bottom{-webkit-box-align:end;align-items:flex-end}.hc-checkbox-label{padding:4px 0 4px 34px;line-height:1.5;margin-left:-22px}.hc-checkbox-tight .hc-checkbox-label{padding:2px 0 2px 26px;font-size:.92857rem;margin-left:-18px}.hc-checkbox-align-label-top{padding-top:0!important;margin-top:-3px}.hc-checkbox-align-label-bottom{padding-bottom:0!important;margin-bottom:-3px}.hc-checkbox-overlay{position:relative;width:22px;height:22px;min-width:22px;background-color:#fff;border:1px solid #c0c5cc;border-radius:3px}.hc-checkbox-overlay:after{content:'';position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5BcnRib2FyZCAxPC90aXRsZT48cGF0aCBpZD0iUGF0aF8xMjIyMSIgZGF0YS1uYW1lPSJQYXRoIDEyMjIxIiBjbGFzcz0iY2xzLTEiIGQ9Ik0yOCw5Ljc2YTEuNjYsMS42NiwwLDAsMC0uNDYtMS4xNEwyNS4yMyw2LjM1YTEuNjIsMS42MiwwLDAsMC0yLjI4LDBsLTExLDExTDcuMDUsMTIuNDFhMS42MiwxLjYyLDAsMCwwLTIuMjgsMEwyLjQ5LDE0LjY4QTEuNjcsMS42NywwLDAsMCwyLDE1LjgyLDEuNjYsMS42NiwwLDAsMCwyLjQ5LDE3TDguNTUsMjNsMi4yOCwyLjI4YTEuNjEsMS42MSwwLDAsMCwxLjE0LjQ3LDEuNjMsMS42MywwLDAsMCwxLjE0LS40N0wxNS4zOSwyMywyNy41MSwxMC45QTEuNiwxLjYsMCwwLDAsMjgsOS43NloiLz48L3N2Zz4=);top:1px;left:1px;width:15.5px;height:15.5px;opacity:0}.hc-checkbox-tight .hc-checkbox-overlay{width:18px;height:18px;min-width:18px}.hc-checkbox-tight .hc-checkbox-overlay:after{top:.5px;left:.5px;width:12.5px;height:12.5px}.hc-checkbox-content:hover .hc-checkbox-overlay{border:1px solid #00aeff;background-color:#f2fbff}.hc-checkbox-indeterminate .hc-checkbox-overlay:after{opacity:1;top:4px;left:4px;width:12px;height:7px;border-bottom:3px solid #ccc;background-image:none}.hc-checkbox-indeterminate .hc-checkbox-tight .hc-checkbox-overlay:after{top:1.5px;width:8px}input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#00aeff;border:2px solid #00aeff}input[type=checkbox]:checked+.hc-checkbox-overlay:after{opacity:1}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay{background-color:#e0e0e0;border:1px solid #ccc}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:after{top:2px;left:2px}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:focus{box-shadow:none}.hc-checkbox-overlay:focus{outline:0;box-shadow:0 0 5px #00aeff}.hc-form-field-invalid .hc-checkbox-overlay{border-color:#cc2027!important}.hc-form-field-invalid .hc-checkbox-overlay:focus{box-shadow:0 0 5px #cc2027}.hc-form-field-invalid input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#cc2027}.hc-checkbox-stub .hc-checkbox-label,.hc-checkbox-stub .hc-checkbox-overlay{pointer-events:none}",
            ],
          },
        ],
      },
    ],
    null,
    {
      checkboxes: [
        {
          type: ContentChildren,
          args: [
            forwardRef(
              /**
               * @return {?}
               */ () => CheckboxComponent
            ),
            { descendants: false },
          ],
        },
      ],
      disableParent: [
        {
          type: Input,
        },
      ],
      parentLabel: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CheckboxComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-checkbox",
            template:
              '<div class="hc-checkbox-container" [class.hc-checkbox-stub]="isStub">\n    <div class="hc-checkbox-content" [class.hc-checkbox-tight]="tight" [ngClass]="\'hc-checkbox-align-\'+align">\n        <input #checkboxInput\n               type="checkbox"\n               [id]="_inputId"\n               [attr.value]="value"\n               [attr.name]="name"\n               [indeterminate]="indeterminate"\n               [disabled]="disabled"\n               [required]="required"\n               [checked]="checked"\n               (change)="_stopChangeEvent($event)"\n               (click)="_clickEvent($event)"\n               (blur)="_onBlur()"/>\n        <label class="hc-checkbox-overlay" [attr.for]="_inputId" [tabIndex]="tabIndex" (keydown.space)="_clickEvent($event); $event.preventDefault();"></label>\n        <label class="hc-checkbox-label" [ngClass]="\'hc-checkbox-align-label-\'+align" [attr.for]="_inputId">\n            <ng-content></ng-content>\n        </label>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            providers: [
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => CheckboxComponent
                ),
              },
            ],
            exportAs: "hcCheckbox",
            styles: [
              ".hc-checkbox-container{display:-webkit-box;display:flex}.hc-checkbox-container input[type=checkbox]{display:none}.hc-checkbox-content{display:-webkit-inline-box;display:inline-flex;cursor:pointer}.hc-checkbox-content label{cursor:pointer}.hc-checkbox-disabled .hc-checkbox-content{color:#ccc;cursor:not-allowed}.hc-checkbox-disabled .hc-checkbox-content label{cursor:not-allowed}.hc-checkbox-children-group{margin-left:25px;margin-top:5px}.hc-checkbox-align-center{-webkit-box-align:center;align-items:center}.hc-checkbox-align-top{-webkit-box-align:start;align-items:flex-start}.hc-checkbox-align-bottom{-webkit-box-align:end;align-items:flex-end}.hc-checkbox-label{padding:4px 0 4px 34px;line-height:1.5;margin-left:-22px}.hc-checkbox-tight .hc-checkbox-label{padding:2px 0 2px 26px;font-size:.92857rem;margin-left:-18px}.hc-checkbox-align-label-top{padding-top:0!important;margin-top:-3px}.hc-checkbox-align-label-bottom{padding-bottom:0!important;margin-bottom:-3px}.hc-checkbox-overlay{position:relative;width:22px;height:22px;min-width:22px;background-color:#fff;border:1px solid #c0c5cc;border-radius:3px}.hc-checkbox-overlay:after{content:'';position:absolute;background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5BcnRib2FyZCAxPC90aXRsZT48cGF0aCBpZD0iUGF0aF8xMjIyMSIgZGF0YS1uYW1lPSJQYXRoIDEyMjIxIiBjbGFzcz0iY2xzLTEiIGQ9Ik0yOCw5Ljc2YTEuNjYsMS42NiwwLDAsMC0uNDYtMS4xNEwyNS4yMyw2LjM1YTEuNjIsMS42MiwwLDAsMC0yLjI4LDBsLTExLDExTDcuMDUsMTIuNDFhMS42MiwxLjYyLDAsMCwwLTIuMjgsMEwyLjQ5LDE0LjY4QTEuNjcsMS42NywwLDAsMCwyLDE1LjgyLDEuNjYsMS42NiwwLDAsMCwyLjQ5LDE3TDguNTUsMjNsMi4yOCwyLjI4YTEuNjEsMS42MSwwLDAsMCwxLjE0LjQ3LDEuNjMsMS42MywwLDAsMCwxLjE0LS40N0wxNS4zOSwyMywyNy41MSwxMC45QTEuNiwxLjYsMCwwLDAsMjgsOS43NloiLz48L3N2Zz4=);top:1px;left:1px;width:15.5px;height:15.5px;opacity:0}.hc-checkbox-tight .hc-checkbox-overlay{width:18px;height:18px;min-width:18px}.hc-checkbox-tight .hc-checkbox-overlay:after{top:.5px;left:.5px;width:12.5px;height:12.5px}.hc-checkbox-content:hover .hc-checkbox-overlay{border:1px solid #00aeff;background-color:#f2fbff}.hc-checkbox-indeterminate .hc-checkbox-overlay:after{opacity:1;top:4px;left:4px;width:12px;height:7px;border-bottom:3px solid #ccc;background-image:none}.hc-checkbox-indeterminate .hc-checkbox-tight .hc-checkbox-overlay:after{top:1.5px;width:8px}input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#00aeff;border:2px solid #00aeff}input[type=checkbox]:checked+.hc-checkbox-overlay:after{opacity:1}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay{background-color:#e0e0e0;border:1px solid #ccc}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:after{top:2px;left:2px}.hc-checkbox-disabled input[type=checkbox]+.hc-checkbox-overlay:focus{box-shadow:none}.hc-checkbox-overlay:focus{outline:0;box-shadow:0 0 5px #00aeff}.hc-form-field-invalid .hc-checkbox-overlay{border-color:#cc2027!important}.hc-form-field-invalid .hc-checkbox-overlay:focus{box-shadow:0 0 5px #cc2027}.hc-form-field-invalid input[type=checkbox]:checked+.hc-checkbox-overlay{background-color:#cc2027}.hc-checkbox-stub .hc-checkbox-label,.hc-checkbox-stub .hc-checkbox-overlay{pointer-events:none}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        {
          type: String,
          decorators: [
            {
              type: Attribute,
              args: ["tabindex"],
            },
          ],
        },
        { type: ɵngcc0.Renderer2 },
        { type: ɵngcc0.ElementRef },
        {
          type: ɵngcc7.NgForm,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.FormGroupDirective,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: CheckboxGroup,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.NgControl,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Self,
            },
          ],
        },
      ];
    },
    {
      isStub: [
        {
          type: Input,
        },
      ],
      align: [
        {
          type: Input,
        },
      ],
      name: [
        {
          type: Input,
        },
      ],
      change: [
        {
          type: Output,
        },
      ],
      id: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      _getHostId: [
        {
          type: HostBinding,
          args: ["attr.id"],
        },
      ],
      _getCheckboxCheckedClass: [
        {
          type: HostBinding,
          args: ["class.hc-checkbox-checked"],
        },
      ],
      _getCheckboxDisabledClass: [
        {
          type: HostBinding,
          args: ["class.hc-checkbox-disabled"],
        },
      ],
      _getCheckboxIndeterminateClass: [
        {
          type: HostBinding,
          args: ["class.hc-checkbox-indeterminate"],
        },
      ],
      required: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      checked: [
        {
          type: Input,
        },
      ],
      parent: [
        {
          type: Input,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      indeterminate: [
        {
          type: Input,
        },
      ],
      _checkboxInput: [
        {
          type: ViewChild,
          args: ["checkboxInput", { static: true }],
        },
      ],
    }
  );
})();
const ɵHcCheckboxRequiredValidatorDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcCheckboxRequiredValidatorDirective
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcCheckboxRequiredValidatorDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: `hc-checkbox[required][formControlName],
             hc-checkbox[required][formControl],hc-checkbox[required][ngModel]`,
            providers: [HC_CHECKBOX_REQUIRED_VALIDATOR],
          },
        ],
      },
    ],
    null,
    {
      isRequired: [
        {
          type: HostBinding,
          args: ["attr.required"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(CheckboxModule, {
      declarations: function () {
        return [
          CheckboxComponent,
          HcCheckboxRequiredValidatorDirective,
          CheckboxGroup,
        ];
      },
      imports: function () {
        return [CommonModule, FormsModule];
      },
      exports: function () {
        return [
          CheckboxComponent,
          HcCheckboxRequiredValidatorDirective,
          CheckboxGroup,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CheckboxModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, FormsModule],
            exports: [
              CheckboxComponent,
              HcCheckboxRequiredValidatorDirective,
              CheckboxGroup,
            ],
            declarations: [
              CheckboxComponent,
              HcCheckboxRequiredValidatorDirective,
              CheckboxGroup,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ChipComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-chip",
            template:
              '<div class="hc-chip hc-chip-{{color}}">\n    <span class="hc-chip-content-{{color}}">\n        <ng-content></ng-content>\n    </span>\n    <span *ngIf="hasCloseButton" class="hc-chip-close" (click)="_closeClick($event)">\n        <span class="hc-chip-close-icon"></span>\n    </span>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              "@charset \"UTF-8\";.hc-chip{font-size:1rem;border-radius:6px;display:-webkit-inline-box;display:inline-flex;margin:5px;padding-left:15px;padding-right:15px}.hc-chip-content-neutral{display:-webkit-box;display:flex;padding-top:9px;padding-bottom:9px}.hc-chip-content-green,.hc-chip-content-red,.hc-chip-content-yellow{display:-webkit-box;display:flex;padding-top:7px;padding-bottom:7px}.hc-chip-close{padding:6px 12px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;margin-right:-12px;margin-left:auto;cursor:pointer}.hc-chip-neutral{background-color:#e4e4e4;color:#333}.hc-chip-red{background-color:#efdddd;border:2px solid #e5c6c7;color:#951c1e}.hc-chip-yellow{background-color:#faf3da;border:2px solid #f3e2a3;color:#ad9335}.hc-chip-green{background-color:#d9eedf;border:2px solid #bce1c6;color:#00a859}.hc-chip-close-icon{background-repeat:no-repeat;background-size:contain;display:inline-block;height:10px;opacity:.4;width:10px}.hc-chip-neutral .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMSIgZGF0YS1uYW1lPSJQYXRoIDEiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMzMzIi8+Cjwvc3ZnPgo=)}.hc-chip-red .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMiIgZGF0YS1uYW1lPSJQYXRoIDIiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjOTUxYzFlIi8+Cjwvc3ZnPgo=)}.hc-chip-yellow .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMyIgZGF0YS1uYW1lPSJQYXRoIDMiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjYWQ5MzM1Ii8+Cjwvc3ZnPgo=)}.hc-chip-green .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfNCIgZGF0YS1uYW1lPSJQYXRoIDQiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMDBhODU5Ii8+Cjwvc3ZnPgo=)}.hc-chip-row-contents{display:inline-block}.hc-chip-single-row{height:42px;overflow:hidden}.hc-chip-single-row::before{content:'';float:left;height:50px;width:5px}.hc-chip-single-row>:first-child{float:right;margin-left:-5px;width:100%}.hc-chip-single-row::after{content:'\u2026more';box-sizing:content-box;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;float:right;left:100%;margin-left:-3.5em;padding-right:5px;position:relative;text-align:right;top:-35px;width:3.5em}.hc-chip-row-buffer{margin-right:3.5em}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      closeClick: [
        {
          type: Output,
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
      hasCloseButton: [
        {
          type: Input,
        },
      ],
      action: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ChipRowComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-chip-row",
            template: `
        <div class="hc-chip-row-contents" [ngClass]="{'hc-chip-single-row': !wrap}">
            <div>
                <div class="hc-chip-row-buffer"><ng-content></ng-content></div>
            </div>
        </div>
    `,
            encapsulation: ViewEncapsulation.None,
            styles: [
              "@charset \"UTF-8\";.hc-chip{font-size:1rem;border-radius:6px;display:-webkit-inline-box;display:inline-flex;margin:5px;padding-left:15px;padding-right:15px}.hc-chip-content-neutral{display:-webkit-box;display:flex;padding-top:9px;padding-bottom:9px}.hc-chip-content-green,.hc-chip-content-red,.hc-chip-content-yellow{display:-webkit-box;display:flex;padding-top:7px;padding-bottom:7px}.hc-chip-close{padding:6px 12px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;margin-right:-12px;margin-left:auto;cursor:pointer}.hc-chip-neutral{background-color:#e4e4e4;color:#333}.hc-chip-red{background-color:#efdddd;border:2px solid #e5c6c7;color:#951c1e}.hc-chip-yellow{background-color:#faf3da;border:2px solid #f3e2a3;color:#ad9335}.hc-chip-green{background-color:#d9eedf;border:2px solid #bce1c6;color:#00a859}.hc-chip-close-icon{background-repeat:no-repeat;background-size:contain;display:inline-block;height:10px;opacity:.4;width:10px}.hc-chip-neutral .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMSIgZGF0YS1uYW1lPSJQYXRoIDEiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMzMzIi8+Cjwvc3ZnPgo=)}.hc-chip-red .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMiIgZGF0YS1uYW1lPSJQYXRoIDIiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjOTUxYzFlIi8+Cjwvc3ZnPgo=)}.hc-chip-yellow .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfMyIgZGF0YS1uYW1lPSJQYXRoIDMiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjYWQ5MzM1Ii8+Cjwvc3ZnPgo=)}.hc-chip-green .hc-chip-close-icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOS44ODgiIGhlaWdodD0iMTkuODg4IiB2aWV3Qm94PSIwIDAgMTkuODg4IDE5Ljg4OCI+CiAgPHBhdGggaWQ9IlBhdGhfNCIgZGF0YS1uYW1lPSJQYXRoIDQiIGQ9Ik0yMS43My0zLjU4M2ExLjYyMywxLjYyMywwLDAsMC0uNDY5LTEuMTM4TDE2LjMzOS05LjY0M2w0LjkyMi00LjkyMkExLjYyMywxLjYyMywwLDAsMCwyMS43My0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLS40NjktMS4xMzhsLTIuMjc3LTIuMjc3YTEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LS40NjksMS42MjMsMS42MjMsMCwwLDAtMS4xMzguNDY5TDExLjc4Ni0xNC4yLDYuODY0LTE5LjExOGExLjYyMywxLjYyMywwLDAsMC0xLjEzOC0uNDY5LDEuNjIzLDEuNjIzLDAsMCwwLTEuMTM4LjQ2OUwyLjMxLTE2Ljg0MkExLjYyMywxLjYyMywwLDAsMCwxLjg0Mi0xNS43YTEuNjIzLDEuNjIzLDAsMCwwLC40NjksMS4xMzhMNy4yMzItOS42NDMsMi4zMS00LjcyMWExLjYyMywxLjYyMywwLDAsMC0uNDY5LDEuMTM4QTEuNjIzLDEuNjIzLDAsMCwwLDIuMzEtMi40NDRMNC41ODctLjE2N0ExLjYyMywxLjYyMywwLDAsMCw1LjcyNS4zLDEuNjIzLDEuNjIzLDAsMCwwLDYuODY0LS4xNjdsNC45MjItNC45MjJMMTYuNzA4LS4xNjdBMS42MjMsMS42MjMsMCwwLDAsMTcuODQ2LjNhMS42MjMsMS42MjMsMCwwLDAsMS4xMzgtLjQ2OWwyLjI3Ny0yLjI3N0ExLjYyMywxLjYyMywwLDAsMCwyMS43My0zLjU4M1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xLjg0MiAxOS41ODcpIiBmaWxsPSIjMDBhODU5Ii8+Cjwvc3ZnPgo=)}.hc-chip-row-contents{display:inline-block}.hc-chip-single-row{height:42px;overflow:hidden}.hc-chip-single-row::before{content:'';float:left;height:50px;width:5px}.hc-chip-single-row>:first-child{float:right;margin-left:-5px;width:100%}.hc-chip-single-row::after{content:'\u2026more';box-sizing:content-box;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;float:right;left:100%;margin-left:-3.5em;padding-right:5px;position:relative;text-align:right;top:-35px;width:3.5em}.hc-chip-row-buffer{margin-right:3.5em}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      wrap: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ChipModule, {
      declarations: function () {
        return [ChipComponent, ChipRowComponent];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [ChipComponent, ChipRowComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ChipModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [ChipComponent, ChipRowComponent],
            declarations: [ChipComponent, ChipRowComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcDatepickerIntl,
    [
      {
        type: Injectable,
        args: [{ providedIn: "root" }],
      },
    ],
    function () {
      return [];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CalendarBodyComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "[hc-calendar-body]",
            template:
              '<!-- Create the first row separately so we can include a special spacer cell. -->\n<tr *ngFor="let row of rows; let rowIndex = index" role="row">\n    <!--\n    We mark this cell as aria-hidden so it doesn\'t get read out as one of the days in the week.\n    The aspect ratio of the table cells is maintained by setting the top and bottom padding as a\n    percentage of the width (a variant of the trick described here:\n    https://www.w3schools.com/howto/howto_css_aspect_ratio.asp).\n  -->\n    <td *ngIf="rowIndex === 0 && _firstRowOffset" aria-hidden="true" class="hc-calendar-body-label" [attr.colspan]="_firstRowOffset"></td>\n    <td\n        *ngFor="let item of row; let colIndex = index"\n        role="gridcell"\n        class="hc-calendar-body-cell"\n        [ngClass]="item.cssClasses"\n        [tabindex]="_isActiveCell(rowIndex, colIndex) ? 0 : -1"\n        [class.hc-calendar-body-available]="item.enabled && !_isActiveCell(rowIndex, colIndex)"\n        [class.hc-calendar-body-disabled]="!item.enabled"\n        [class.hc-calendar-body-active]="_isActiveCell(rowIndex, colIndex)"\n        [attr.aria-label]="item.ariaLabel"\n        [attr.aria-disabled]="!item.enabled || null"\n        [attr.aria-selected]="selectedValue === item.value"\n        (click)="_cellClicked(item)"\n        [style.width]="_cellWidth"\n        [style.paddingTop]="_cellPadding"\n        [style.paddingBottom]="_cellPadding"\n    >\n        <div\n            class="hc-calendar-body-cell-content"\n            [class.hc-calendar-body-selected]="selectedValue === item.value"\n            [class.hc-calendar-body-today]="todayValue === item.value"\n        >\n            {{ item.displayValue }}\n        </div>\n    </td>\n</tr>\n',
            host: {
              class: "hc-calendar-body",
              role: "grid",
              "aria-readonly": "true",
            },
            exportAs: "hcCalendarBody",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-body{font-size:14px;min-width:224px}.hc-calendar-body-label{color:#00aeff;font-size:14px;height:0;line-height:0;padding-left:4.71429%;padding-right:4.71429%;text-align:left}[dir=rtl] .hc-calendar-body-label{text-align:right}.hc-calendar-body-cell{cursor:pointer;height:0;line-height:0;outline:0;position:relative;text-align:center}.hc-calendar-body-disabled{color:#c0c5cc}.hc-calendar-body-cell-content{-webkit-box-align:center;align-items:center;border-radius:999px;box-sizing:border-box;color:#333;display:-webkit-box;display:flex;height:90%;-webkit-box-pack:center;justify-content:center;left:5%;line-height:1;position:absolute;top:5%;width:90%;border:1px solid transparent}.hc-calendar-body-disabled .hc-calendar-body-cell-content:not(.hc-calendar-body-selected):not(.hc-calendar-body-today){color:#c0c5cc}.cdk-keyboard-focused .hc-calendar-body-active .hc-calendar-body-cell-content:not(.hc-calendar-body-selected),.cdk-program-focused .hc-calendar-body-active .hc-calendar-body-cell-content:not(.hc-calendar-body-selected),.hc-calendar-body-available:hover .hc-calendar-body-cell-content{border:2px solid #008bcc}.hc-calendar-body-selected{background-color:#008bcc;color:#fff;font-weight:700}.hc-calendar-body-disabled .hc-calendar-body-selected{background-color:#c0c5cc}.hc-calendar-body-selected.hc-calendar-body-today{box-shadow:inset 0 0 0 1px #c0c5cc}.hc-calendar-body-disabled .hc-calendar-body-today:not(.hc-calendar-body-selected),.hc-calendar-body-today:not(.hc-calendar-body-selected){background-color:#c0c5cc;border-color:transparent}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }];
    },
    {
      numCols: [
        {
          type: Input,
        },
      ],
      activeCell: [
        {
          type: Input,
        },
      ],
      cellAspectRatio: [
        {
          type: Input,
        },
      ],
      selectedValueChange: [
        {
          type: Output,
        },
      ],
      label: [
        {
          type: Input,
        },
      ],
      rows: [
        {
          type: Input,
        },
      ],
      todayValue: [
        {
          type: Input,
        },
      ],
      selectedValue: [
        {
          type: Input,
        },
      ],
      labelMinRequiredCells: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MultiYearViewComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-multi-year-view",
            template:
              '<table class="hc-calendar-table">\n    <thead class="hc-calendar-table-header">\n      <tr><th class="hc-calendar-table-header-divider" colspan="4"></th></tr>\n    </thead>\n    <tbody hc-calendar-body\n           [rows]="_years"\n           [todayValue]="_todayYear"\n           [selectedValue]="_selectedYear"\n           [numCols]="4"\n           [cellAspectRatio]="4 / 7"\n           [activeCell]="_getActiveCell()"\n           (selectedValueChange)="_yearSelected($event)"\n           (keydown)="_handleCalendarBodyKeydown($event)">\n    </tbody>\n  </table>\n  ',
            exportAs: "hcMultiYearView",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ChangeDetectorRef },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    {
      selectedChange: [
        {
          type: Output,
        },
      ],
      yearSelected: [
        {
          type: Output,
        },
      ],
      activeDateChange: [
        {
          type: Output,
        },
      ],
      activeDate: [
        {
          type: Input,
        },
      ],
      selected: [
        {
          type: Input,
        },
      ],
      minDate: [
        {
          type: Input,
        },
      ],
      maxDate: [
        {
          type: Input,
        },
      ],
      dateFilter: [
        {
          type: Input,
        },
      ],
      _hcCalendarBody: [
        {
          type: ViewChild,
          args: [CalendarBodyComponent, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MonthViewComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-month-view",
            template:
              '<table class="hc-calendar-table">\n    <thead class="hc-calendar-table-header">\n        <tr>\n            <th *ngFor="let day of _weekdays" [attr.aria-label]="day.long">{{ day.narrow }}</th>\n        </tr>\n        <tr>\n            <th class="hc-calendar-table-header-divider" colspan="7" aria-hidden="true"></th>\n        </tr>\n    </thead>\n    <tbody\n        hc-calendar-body\n        [label]="_monthLabel"\n        [rows]="_weeks"\n        [todayValue]="_todayDate"\n        [selectedValue]="_selectedDate"\n        [labelMinRequiredCells]="3"\n        [activeCell]="_dateAdapter.getDate(activeDate) - 1"\n        (selectedValueChange)="_dateSelected($event)"\n        (keydown)="_handleCalendarBodyKeydown($event)"\n    ></tbody>\n</table>\n',
            exportAs: "hcMonthView",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ChangeDetectorRef },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_FORMATS],
            },
          ],
        },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    {
      selectedChange: [
        {
          type: Output,
        },
      ],
      _userSelection: [
        {
          type: Output,
        },
      ],
      activeDateChange: [
        {
          type: Output,
        },
      ],
      activeDate: [
        {
          type: Input,
        },
      ],
      selected: [
        {
          type: Input,
        },
      ],
      minDate: [
        {
          type: Input,
        },
      ],
      maxDate: [
        {
          type: Input,
        },
      ],
      dateFilter: [
        {
          type: Input,
        },
      ],
      dateClass: [
        {
          type: Input,
        },
      ],
      _hcCalendarBody: [
        {
          type: ViewChild,
          args: [CalendarBodyComponent, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    YearViewComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-year-view",
            template:
              '<table class="hc-calendar-table">\n  <thead class="hc-calendar-table-header">\n    <tr><th class="hc-calendar-table-header-divider" colspan="4"></th></tr>\n  </thead>\n  <tbody hc-calendar-body\n         [label]="_yearLabel"\n         [rows]="_months"\n         [todayValue]="_todayMonth"\n         [selectedValue]="_selectedMonth"\n         [labelMinRequiredCells]="2"\n         [numCols]="4"\n         [cellAspectRatio]="4 / 7"\n         [activeCell]="_dateAdapter.getMonth(activeDate)"\n         (selectedValueChange)="_monthSelected($event)"\n         (keydown)="_handleCalendarBodyKeydown($event)">\n  </tbody>\n</table>\n',
            exportAs: "hcYearView",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ChangeDetectorRef },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_FORMATS],
            },
          ],
        },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    {
      selectedChange: [
        {
          type: Output,
        },
      ],
      monthSelected: [
        {
          type: Output,
        },
      ],
      activeDateChange: [
        {
          type: Output,
        },
      ],
      activeDate: [
        {
          type: Input,
        },
      ],
      selected: [
        {
          type: Input,
        },
      ],
      minDate: [
        {
          type: Input,
        },
      ],
      maxDate: [
        {
          type: Input,
        },
      ],
      dateFilter: [
        {
          type: Input,
        },
      ],
      _hcCalendarBody: [
        {
          type: ViewChild,
          args: [CalendarBodyComponent, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CalendarHeaderComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-calendar-header",
            template:
              '<div *ngIf="calendar.mode!==\'time\'" class="hc-calendar-header">\n    <div class="hc-calendar-controls">\n        <button\n            hc-button\n            buttonStyle="link"\n            type="button"\n            class="hc-calendar-today-button hc-calendar-control-button"\n            (click)="_todayClicked()"\n            [disabled]="!_todayEnabled()"\n            [attr.aria-label]="_todayButtonLabel"\n            [title]="_todayButtonLabel"\n        >\n            Today\n        </button>\n\n        <span>\n            <button\n                hc-button\n                buttonStyle="link"\n                type="button"\n                class="hc-calendar-previous-button hc-calendar-control-button"\n                [disabled]="!previousEnabled()"\n                (click)="previousClicked()"\n                [attr.aria-label]="prevButtonLabel"\n                [title]="prevButtonLabel"\n            ></button>\n            <span class="hc-calendar-month-label">\n                {{ monthButtonText }}\n            </span>\n            <button\n                hc-button\n                buttonStyle="link"\n                type="button"\n                class="hc-calendar-next-button hc-calendar-control-button"\n                [disabled]="!nextEnabled()"\n                (click)="nextClicked()"\n                [attr.aria-label]="nextButtonLabel"\n                [title]="nextButtonLabel"\n            ></button>\n        </span>\n\n        <ng-content></ng-content>\n\n        <button\n            hc-button\n            buttonStyle="link"\n            type="button"\n            class="hc-calendar-period-button hc-calendar-control-button"\n            (click)="currentPeriodClicked()"\n            [attr.aria-label]="periodButtonLabel"\n            [title]="periodButtonLabel"\n        >\n            {{ periodButtonText }}\n            <div class="hc-calendar-dropdown-caret" [class.hc-calendar-dropdown-caret-invert]="calendar.currentView != \'month\'"></div>\n        </button>\n    </div>\n</div>\n',
            exportAs: "hcCalendarHeader",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    function () {
      return [
        { type: HcDatepickerIntl },
        {
          type: CalendarComponent,
          decorators: [
            {
              type: Inject,
              args: [
                forwardRef(
                  /**
                   * @return {?}
                   */ () => CalendarComponent
                ),
              ],
            },
          ],
        },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_FORMATS],
            },
          ],
        },
        { type: ɵngcc0.ChangeDetectorRef },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CalendarComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-calendar",
            template:
              '<ng-template [cdkPortalOutlet]="_calendarHeaderPortal"></ng-template>\n\n<ng-container *ngIf="mode !== \'time\'">\n    <div class="hc-calendar-content" [ngSwitch]="currentView" cdkMonitorSubtreeFocus tabindex="-1">\n        <hc-month-view\n            *ngSwitchCase="\'month\'"\n            [(activeDate)]="activeDate"\n            [selected]="selected"\n            [dateFilter]="dateFilter"\n            [maxDate]="maxDate"\n            [minDate]="minDate"\n            [dateClass]="dateClass"\n            (selectedChange)="_dateSelected($event)"\n            (_userSelection)="_userSelected()"\n        ></hc-month-view>\n\n        <hc-year-view\n            *ngSwitchCase="\'year\'"\n            [(activeDate)]="activeDate"\n            [selected]="selected"\n            [dateFilter]="dateFilter"\n            [maxDate]="maxDate"\n            [minDate]="minDate"\n            (monthSelected)="_monthSelectedInYearView($event)"\n            (selectedChange)="_goToDateInView($event, \'month\')"\n        ></hc-year-view>\n\n        <hc-multi-year-view\n            *ngSwitchCase="\'multi-year\'"\n            [(activeDate)]="activeDate"\n            [selected]="selected"\n            [dateFilter]="dateFilter"\n            [maxDate]="maxDate"\n            [minDate]="minDate"\n            (yearSelected)="_yearSelectedInMultiYearView($event)"\n            (selectedChange)="_goToDateInView($event, \'year\')"\n        ></hc-multi-year-view>\n    </div>\n</ng-container>\n\n<div *ngIf="mode !== \'date\'" class="hc-calendar-time-picker">\n    <hc-icon class="hc-calendar-time-picker-icon" fontSet="fa" fontIcon="fa-clock-o"></hc-icon>\n\n    <hc-form-field inline="true" class="hc-calendar-time-picker-field">\n        <input\n            hcInput\n            class="hc-calendar-time-picker-input"\n            placeholder="hh"\n            [(ngModel)]="hours"\n            (keydown.arrowup)="_hoursUp()"\n            (keydown.arrowdown)="_hoursDown()"\n        />\n        <span hcSuffix class="hc-calendar-time-controls">\n            <button hc-button buttonStyle="minimal" size="sm" (click)="_hoursUp()" class="hc-calendar-time-controls-button">\n                <hc-icon fontSet="fa" fontIcon="fa-caret-up" hcIconSm class="hc-calendar-controls-icon"></hc-icon>\n            </button>\n            <button hc-button buttonStyle="minimal" size="sm" (click)="_hoursDown()" class="hc-calendar-time-controls-button">\n                <hc-icon fontSet="fa" fontIcon="fa-caret-down" hcIconSm class="hc-calendar-controls-icon"></hc-icon>\n            </button>\n        </span>\n    </hc-form-field>\n\n    <hc-form-field inline="true" class="hc-calendar-time-picker-field">\n        <input\n            hcInput\n            class="hc-calendar-time-picker-input"\n            placeholder="mm"\n            [(ngModel)]="minutes"\n            (keydown.arrowup)="_minutesUp()"\n            (keydown.arrowdown)="_minutesDown()"\n        />\n        <span hcSuffix class="hc-calendar-time-controls">\n            <button hc-button buttonStyle="minimal" size="sm" (click)="_minutesUp()" class="hc-calendar-time-controls-button">\n                <hc-icon fontSet="fa" fontIcon="fa-caret-up" hcIconSm class="hc-calendar-controls-icon"></hc-icon>\n            </button>\n            <button hc-button buttonStyle="minimal" size="sm" (click)="_minutesDown()" class="hc-calendar-time-controls-button">\n                <hc-icon fontSet="fa" fontIcon="fa-caret-down" hcIconSm class="hc-calendar-controls-icon"></hc-icon>\n            </button>\n        </span>\n    </hc-form-field>\n\n    <hc-form-field inline="true" *ngIf="_hourCycle === 12" class="hc-calendar-time-picker-field">\n        <hc-select class="hc-calendar-time-picker-select" [formControl]="_period" (change)="_periodChange()">\n            <option value="am">AM</option>\n            <option value="pm">PM</option>\n        </hc-select>\n    </hc-form-field>\n</div>\n',
            // tslint:disable-next-line:no-host-metadata-property
            host: {
              class: "hc-calendar",
            },
            exportAs: "hcCalendar",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-header{padding:0 8px}.hc-calendar-content{outline:0;padding:0 8px 8px}.hc-calendar-controls{display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:0 calc(33% / 7 - 16px) 5%}.hc-calendar-control-button.hc-calendar-period-button,.hc-calendar-control-button.hc-calendar-today-button{font-size:14px;min-width:inherit;padding:10px}.hc-calendar-control-button.hc-calendar-next-button,.hc-calendar-control-button.hc-calendar-previous-button{color:#00aeff;height:40px;min-width:inherit;padding:0;position:relative;top:-2px;width:40px}.hc-calendar-control-button.hc-calendar-next-button::after,.hc-calendar-control-button.hc-calendar-previous-button::after{border:0 solid currentColor;border-top-width:2px;bottom:0;content:'';left:0;margin:15.5px;position:absolute;right:0;top:0}[dir=rtl] .hc-calendar-control-button.hc-calendar-next-button,[dir=rtl] .hc-calendar-control-button.hc-calendar-previous-button{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-calendar-dropdown-caret{border-left:5px solid transparent;border-right:5px solid transparent;border-top-style:solid;border-top-width:5px;display:inline-block;height:0;margin:0 0 0 5px;vertical-align:middle;width:0}[dir=rtl] .hc-calendar-dropdown-caret{margin:0 5px 0 0}.hc-calendar-dropdown-caret.hc-calendar-dropdown-caret-invert{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-calendar-previous-button::after{border-left-width:2px!important;-webkit-transform:translateX(2px) rotate(-45deg);transform:translateX(2px) rotate(-45deg)}.hc-calendar-next-button::after{border-right-width:2px!important;-webkit-transform:translateX(-2px) rotate(45deg);transform:translateX(-2px) rotate(45deg)}.hc-calendar-month-label{-webkit-box-align:center;align-items:center;color:#00aeff;display:-webkit-inline-box;display:inline-flex;font-size:1.07143rem;font-weight:600;height:35px;-webkit-box-pack:center;justify-content:center;line-height:15px;min-width:35px;vertical-align:baseline}.hc-calendar-table{border-collapse:collapse;border-spacing:0;width:100%}.hc-calendar-table-header{color:#00aeff}.hc-calendar-table-header th{font-size:.64286rem;color:#6d6e70;padding:0 0 8px;text-align:center}.hc-calendar-table-header-divider{height:2px;position:relative}.hc-calendar-table-header-divider::after{background:#e0e0e0;content:'';height:2px;left:0;position:absolute;right:0;top:0}.hc-calendar-time-picker{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;margin-top:10px}.hc-calendar-time-picker-field{margin:0 3px}.hc-calendar-time-picker-input{width:25px}.hc-calendar-time-controls{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.hc-calendar-time-controls-button{height:16px!important;line-height:16px!important;padding:0!important;width:16px!important}.hc-calendar-controls-icon{line-height:1!important}.hc-calendar-time-picker-select{width:70px}.hc-calendar-time-picker-icon{color:#708090;font-size:25px;height:25px;margin-right:10px;width:25px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: HcDatepickerIntl },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_FORMATS],
            },
          ],
        },
        { type: ɵngcc0.ChangeDetectorRef },
      ];
    },
    {
      startView: [
        {
          type: Input,
        },
      ],
      mode: [
        {
          type: Input,
        },
      ],
      selectedChange: [
        {
          type: Output,
        },
      ],
      yearSelected: [
        {
          type: Output,
        },
      ],
      monthSelected: [
        {
          type: Output,
        },
      ],
      _userSelection: [
        {
          type: Output,
        },
      ],
      startAt: [
        {
          type: Input,
        },
      ],
      hourCycle: [
        {
          type: Input,
        },
      ],
      selected: [
        {
          type: Input,
        },
      ],
      minDate: [
        {
          type: Input,
        },
      ],
      maxDate: [
        {
          type: Input,
        },
      ],
      headerComponent: [
        {
          type: Input,
        },
      ],
      dateFilter: [
        {
          type: Input,
        },
      ],
      dateClass: [
        {
          type: Input,
        },
      ],
      monthView: [
        {
          type: ViewChild,
          args: [MonthViewComponent, { static: false }],
        },
      ],
      yearView: [
        {
          type: ViewChild,
          args: [YearViewComponent, { static: false }],
        },
      ],
      multiYearView: [
        {
          type: ViewChild,
          args: [MultiYearViewComponent, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerContentComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-datepicker-content",
            template:
              '<hc-calendar cdkTrapFocus\n    [id]="datepicker.id"\n    [ngClass]="datepicker.panelClass"\n    [mode]="datepicker.mode"\n    [hourCycle]="datepicker.hourCycle"\n    [startAt]="datepicker.startAt"\n    [startView]="datepicker.startView"\n    [minDate]="datepicker._minDate"\n    [maxDate]="datepicker._maxDate"\n    [dateFilter]="datepicker._dateFilter"\n    [headerComponent]="datepicker.calendarHeaderComponent"\n    [selected]="datepicker._selected"\n    [dateClass]="datepicker.dateClass"\n    [@fadeInCalendar]="\'enter\'"\n    (selectedChange)="datepicker.select($event)"\n    (yearSelected)="datepicker._selectYear($event)"\n    (monthSelected)="datepicker._selectMonth($event)"\n    (_userSelection)="autoClose()">\n</hc-calendar>\n',
            // tslint:disable-next-line:no-host-metadata-property
            host: {
              class: "hc-datepicker-content",
              "[@transformPanel]": '"enter"',
            },
            animations: [
              HcDatepickerAnimations.transformPanel,
              HcDatepickerAnimations.fadeInCalendar,
            ],
            exportAs: "hcDatepickerContent",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
          },
        ],
      },
    ],
    null,
    {
      _calendar: [
        {
          type: ViewChild,
          args: [CalendarComponent, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-datepicker",
            template: "",
            exportAs: "hcDatepicker",
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            styles: [
              "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-datepicker-content{background-color:#fff;border-radius:4px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);color:#333;display:block;height:100%;width:310px}.hc-datepicker-toggle-active{color:#00aeff}.hc-calendar{display:block;height:100%;padding:10px 0 20px;width:310px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc3.Overlay },
        { type: ɵngcc0.NgZone },
        { type: ɵngcc0.ViewContainerRef },
        {
          type: undefined,
          decorators: [
            {
              type: Inject,
              args: [HC_DATEPICKER_SCROLL_STRATEGY],
            },
          ],
        },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [DOCUMENT],
            },
          ],
        },
      ];
    },
    {
      startView: [
        {
          type: Input,
        },
      ],
      yearSelected: [
        {
          type: Output,
        },
      ],
      monthSelected: [
        {
          type: Output,
        },
      ],
      openedStream: [
        {
          type: Output,
          args: ["opened"],
        },
      ],
      closedStream: [
        {
          type: Output,
          args: ["closed"],
        },
      ],
      mode: [
        {
          type: Input,
        },
      ],
      hourCycle: [
        {
          type: Input,
        },
      ],
      startAt: [
        {
          type: Input,
        },
      ],
      touchUi: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      opened: [
        {
          type: Input,
        },
      ],
      calendarHeaderComponent: [
        {
          type: Input,
        },
      ],
      panelClass: [
        {
          type: Input,
        },
      ],
      dateClass: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcErrorComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-error",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-error"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcPrefixDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcPrefix]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcPrefixClass: [
        {
          type: HostBinding,
          args: ["class.hc-prefix"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcSuffixDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcSuffix]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcSuffixClass: [
        {
          type: HostBinding,
          args: ["class.hc-suffix"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcLabelComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-label",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    InputDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcInput]",
            providers: [
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => InputDirective
                ),
              },
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        {
          type: ɵngcc7.NgForm,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.FormGroupDirective,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.NgControl,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Self,
            },
          ],
        },
      ];
    },
    {
      focusChanged: [
        {
          type: Output,
        },
      ],
      _hostHcInputClass: [
        {
          type: HostBinding,
          args: ["class.hc-input"],
        },
      ],
      type: [
        {
          type: Input,
        },
      ],
      id: [
        {
          type: Input,
        },
      ],
      readonly: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      required: [
        {
          type: Input,
        },
      ],
      _hostId: [
        {
          type: HostBinding,
          args: ["attr.id"],
        },
      ],
      _hostReadOnly: [
        {
          type: HostBinding,
          args: ["readonly"],
        },
      ],
      _hostDisabled: [
        {
          type: HostBinding,
          args: ["disabled"],
        },
      ],
      _hostRequired: [
        {
          type: HostBinding,
          args: ["required"],
        },
      ],
      /**
       * @return {?}
       */
      _onBlur: [
        {
          type: HostListener,
          args: ["blur"],
        },
      ],
      /**
       * @return {?}
       */
      _onFocus: [
        {
          type: HostListener,
          args: ["focus"],
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      /**
       * @return {?}
       */
      _inputEvent: [
        {
          type: HostListener,
          args: ["input"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFormFieldComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-form-field",
            template:
              '<div\n    [class.hc-form-field-wrapper-inline]="inline"\n    [class.hc-form-field-wrapper]="!inline"\n    [class.hc-form-field-no-label]="!hasLabel"\n    [class.hc-form-field-wrapper-tight]="tight" >\n    <span *ngIf="hasLabel" [ngClass]="inline ? \'hc-form-field-label-wrapper-inline\' : \'hc-form-field-label-wrapper\'" [class.hc-form-field-label-wrapper-tight]="tight">\n        <label [ngClass]="inline ? \'hc-form-field-label-inline\' : \'hc-form-field-label\'" [class.hc-form-field-label-tight]="tight" [attr.for]="_control._componentId">\n            <ng-content select="hc-label"></ng-content>\n            <span class="hc-required-marker" aria-hidden="true" *ngIf="_control._isRequired && !_control._isDisabled">&nbsp;*</span>\n        </label>\n    </span>\n    <div class="hc-form-field-content-wrapper">\n\n        <ng-content select="hc-label-ext"></ng-content>\n\n        <div\n            *ngIf="hasInput"\n            [class.hc-form-field-flex]="!inline"\n            [class.hc-form-field-flex-inline]="inline"\n            [class.hc-form-field-invalid]="_shouldShowErrorMessages()"\n            [class.hc-form-field-flex-focused]="_hasFocusedInput"\n        >\n            <div class="hc-form-field-prefix" *ngIf="_prefixChildren.length">\n                <ng-content select="[hcPrefix]"></ng-content>\n            </div>\n            <div #inputs class="hc-form-field-infix" [class.hc-form-field-infix-tight]="tight">\n                <ng-content select="[hcInput]"></ng-content>\n            </div>\n            <div class="hc-form-field-suffix" *ngIf="_suffixChildren.length">\n                <ng-content select="[hcSuffix]"></ng-content>\n            </div>\n        </div>\n\n        <div\n            *ngIf="!hasInput"\n            [class.hc-form-field-non-input]="!inline"\n            [class.hc-form-field-non-input-inline]="inline"\n            [class.hc-form-field-non-input-inline-tight]="inline && tight"\n            [class.hc-form-field-invalid]="_shouldShowErrorMessages()"\n        >\n            <ng-content></ng-content>\n        </div>\n        <div class="hc-form-field-error-wrapper" *ngIf="_shouldShowErrorMessages()">\n            <hc-error *ngIf="_control._errorMessage && _control._errorMessage.length">{{ _control._errorMessage }}</hc-error>\n            <ng-content select="hc-error"></ng-content>\n        </div>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-form-field{position:relative;text-align:left;font-size:inherit;font-family:'Open Sans','Helvetica Neue',Helvetica,Arial,sans-serif;font-weight:400;line-height:1.5;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit}.hc-form-field-wrapper{position:relative;padding-bottom:1.525em;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit}.hc-form-field-wrapper-inline{display:-webkit-inline-box;display:inline-flex;width:100%;padding-bottom:inherit}.hc-form-field-wrapper-tight{padding-bottom:10px}.hc-form-field-content-wrapper{display:-webkit-box;display:flex;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit;flex-wrap:wrap;width:100%}.hc-form-field-flex{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:baseline;align-items:baseline;box-sizing:border-box;width:100%;border:1px solid #c0c5cc;background:#fff}.hc-form-field-flex:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-form-field-flex.hc-form-field-flex-focused{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-disabled .hc-form-field-flex{cursor:not-allowed;border:1px solid #e0e0e0;background-color:#f0f3f6;color:#adadad}.hc-form-field-flex-inline{display:-webkit-inline-box;display:inline-flex;-webkit-box-align:center;align-items:center;box-sizing:border-box;border:1px solid #c0c5cc;background:#fff}.hc-form-field-flex-inline:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-form-field-flex-inline.hc-form-field-flex-focused{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-disabled .hc-form-field-flex-inline{cursor:not-allowed;border:1px solid #e0e0e0;background-color:#f0f3f6;color:#adadad}.hc-form-field-invalid.hc-form-field-flex,.hc-form-field-invalid.hc-form-field-flex-inline{border:1px solid #cc2027}.hc-form-field-invalid.hc-form-field-flex-inline.hc-form-field-flex-focused,.hc-form-field-invalid.hc-form-field-flex.hc-form-field-flex-focused{box-shadow:0 0 3px #cc2027}.hc-form-field-non-input{display:-webkit-inline-box;display:inline-flex;-webkit-box-orient:inherit;-webkit-box-direction:inherit;flex-direction:inherit;width:100%}.hc-form-field-non-input-inline{display:-webkit-inline-box;display:inline-flex;-webkit-box-flex:0;flex:0 0 100%;min-height:35px;-webkit-box-align:center;align-items:center}.hc-form-field-non-input-inline-tight{min-height:auto}.hc-form-field-prefix,.hc-form-field-suffix{white-space:nowrap;-webkit-box-flex:0;flex:none;position:relative}.hc-form-field-prefix .hc-icon,.hc-form-field-suffix .hc-icon{color:#a1a1a1;font-size:125%;line-height:1.5}.hc-form-field-wrapper-tight .hc-form-field-prefix .hc-icon,.hc-form-field-wrapper-tight .hc-form-field-suffix .hc-icon{line-height:1.3}.hc-form-field-disabled .hc-form-field-prefix,.hc-form-field-disabled .hc-form-field-suffix{opacity:.5}.hc-form-field-suffix{padding-right:7px}.hc-form-field-prefix{padding-left:7px}.hc-form-field-infix{display:block;position:relative;-webkit-box-flex:1;flex:auto;padding:.393em 10px}.hc-form-field-infix-tight{padding:.1965em 7px;font-size:.92857rem}.hc-form-field-label-wrapper{box-sizing:content-box;width:100%}.hc-form-field-label-wrapper .hc-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.hc-form-field-label-wrapper.hc-form-field-label-wrapper-tight{font-size:.92857rem}.hc-form-field-label-wrapper-inline{-webkit-box-flex:1;flex:1 0 auto;padding:7px 15px 0 0}.hc-form-field-label-wrapper-inline .hc-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.hc-form-field-label-wrapper-inline.hc-form-field-label-wrapper-tight{padding-top:0;line-height:1.9}.hc-form-field-label{display:block;width:100%;margin-bottom:3px;font:inherit;font-size:1rem;color:#333}.hc-form-field-label-extension{color:#6d6e70;font-size:.85714rem;margin-bottom:10px}.hc-form-field-label-inline{width:100%;font:inherit;font-size:1rem;color:#333}.hc-form-field-label-tight{font-size:.92857rem}.hc-form-field-error-wrapper{box-sizing:border-box;width:100%;overflow:hidden;margin-top:.53333em;font-size:75%}.hc-error{display:block;color:#cc2027}.hc-required-marker{color:#cc2027}",
              ".hc-input{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;text-align:inherit}.hc-input[disabled]{cursor:not-allowed}.hc-input:-moz-ui-invalid{box-shadow:none}.hc-input::-ms-clear,.hc-input::-ms-reveal{display:none}.hc-input::-webkit-input-placeholder{color:#c0c5cc}.hc-input::-moz-placeholder{color:#c0c5cc}.hc-input::placeholder{color:#c0c5cc}.hc-input:-ms-input-placeholder{color:#c0c5cc}.hc-input::-ms-input-placeholder{color:#c0c5cc}textarea.hc-input{resize:vertical;overflow:auto;padding:2px 0;margin:-2px 0}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      _classHcFormFieldClass: [
        {
          type: HostBinding,
          args: ["class.hc-form-field"],
        },
      ],
      _disabledClass: [
        {
          type: HostBinding,
          args: ["class.hc-form-field-disabled"],
        },
      ],
      inline: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      _control: [
        {
          type: ContentChild,
          args: [HcFormControlComponent, { static: false }],
        },
      ],
      _controls: [
        {
          type: ContentChildren,
          args: [HcFormControlComponent],
        },
      ],
      _errorChildren: [
        {
          type: ContentChildren,
          args: [HcErrorComponent],
        },
      ],
      _prefixChildren: [
        {
          type: ContentChildren,
          args: [HcPrefixDirective],
        },
      ],
      _suffixChildren: [
        {
          type: ContentChildren,
          args: [HcSuffixDirective],
        },
      ],
      _inputChildren: [
        {
          type: ContentChildren,
          args: [InputDirective],
        },
      ],
      _labelChildren: [
        {
          type: ContentChildren,
          args: [HcLabelComponent],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerInputDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "input[hcDatepicker]",
            host: {
              "[attr.aria-haspopup]": "true",
              "[attr.aria-owns]":
                "(_datepicker?.opened && _datepicker.id) || null",
              "[attr.min]": "min ? _dateAdapter.toIso8601(min) : null",
              "[attr.max]": "max ? _dateAdapter.toIso8601(max) : null",
              "[disabled]": "disabled",
              "(input)": "_onInput($event.target.value)",
              "(change)": "_onChange()",
              "(blur)": "_onBlur()",
              "(keydown)": "_onKeydown($event)",
            },
            providers: [
              HC_DATEPICKER_VALUE_ACCESSOR,
              HC_DATEPICKER_VALIDATORS,
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => DatepickerInputDirective
                ),
              },
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        {
          type: DateAdapter,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: undefined,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_FORMATS],
            },
          ],
        },
        {
          type: HcFormFieldComponent,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    {
      dateChange: [
        {
          type: Output,
        },
      ],
      dateInput: [
        {
          type: Output,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      hcDatepicker: [
        {
          type: Input,
        },
      ],
      hcDatepickerFilter: [
        {
          type: Input,
        },
      ],
      min: [
        {
          type: Input,
        },
      ],
      max: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      _mode: [
        {
          type: Input,
        },
      ],
      _hourCycle: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerToggleIconDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcDatepickerToggleIcon]",
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerToggleComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-datepicker-toggle",
            template:
              '<button\n    hc-icon-button\n    #button\n    class="hc-calendar-toggle"\n    type="button"\n    aria-haspopup="true"\n    [attr.aria-label]="_intl.openCalendarLabel"\n    [attr.tabindex]="disabled ? -1 : tabIndex"\n    [disabled]="disabled"\n    (click)="_open($event)"\n>\n    <ng-content select="[hcDatepickerToggleIcon]"></ng-content>\n    <hc-icon hcSuffix fontSet="fa" [fontIcon]="datepicker.mode === \'time\' ? \'fa-clock-o\' : \'fa-calendar\'" *ngIf="!_customIcon"></hc-icon>\n</button>\n',
            // tslint:disable-next-line:no-host-metadata-property
            host: {
              class: "hc-datepicker-toggle",
              // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the
              // consumer may have provided, while still being able to receive focus.
              "[attr.tabindex]": "-1",
              "[class.hc-datepicker-toggle-active]":
                "datepicker && datepicker.opened",
              "(focus)": "_button.focus()",
            },
            exportAs: "hcDatepickerToggle",
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              "@charset \"UTF-8\";body,html{font-family:\"Open Sans\",\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;color:#333}h1{font-size:2.57143rem;font-weight:300;line-height:1.2;color:#333;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}h2{font-size:1.57143rem;font-weight:600;line-height:1.5;color:#333}h3{font-size:1.28571rem;font-weight:600;line-height:1.5;color:#333}h4{font-size:1rem;font-weight:600;line-height:1.5;color:#333}p{font-size:1.14286rem;font-weight:400;line-height:1.5;color:#333}code{color:#a94c9d;font-family:Consolas,Menlo,'Ubuntu Mono',monospace;background-color:#f1f1f1;border-radius:3px;padding:3px 7px;font-size:1rem;font-weight:400;line-height:1.4}pre{border:1px solid #a1a1a1;padding:20px;margin:16px auto;border-radius:5px;display:block;background-color:#f1f1f1;font-weight:400}pre>span{font-size:1rem;line-height:1.4;padding:10px 0;background-color:#f1f1f1}pre>code{overflow-x:auto;display:block;font-size:1rem;padding:10px;line-height:1.4;background-color:#f1f1f1;color:#333;border:unset;border-radius:unset}a{text-decoration:none;color:#00aeff}a:hover{color:#33beff}a:active{color:#008bcc}.hc-font-xsm{font-size:.85714rem}.hc-font-sm{font-size:1rem}.hc-font-md{font-size:1.14286rem}.hc-font-lg{font-size:1.28571rem}.hc-font-xlg{font-size:1.57143rem}.hc-font-light{font-weight:300}.hc-font-reg{font-weight:400}.hc-font-bold,strong{font-weight:600}.hc-font-xbold{font-weight:700}.hc-text-titlecase{text-transform:capitalize}.hc-text-uppercase{text-transform:uppercase}.hc-text-lowercase{text-transform:lowercase}.hc-text-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-font-em,em{color:#6d6e70;font-style:italic}.hc-text-highlight{color:#333;background-color:#f5ed56}article ul{list-style-type:none;display:table}article>ul>li{display:table;padding-left:20px}article ul>li:before{content:'\u2022  ';display:table-cell;padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{margin-top:6px!important}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{margin-bottom:6px!important}article ol>li{padding-left:6px;margin-left:40px!important}article ul li ul li{display:table;margin-left:0}article ul li ul li:before{content:'\u2013  ';display:table-cell;padding-right:15px}article ol>li>ol>li{list-style-type:lower-alpha;padding-left:6px;margin-left:18px!important}article ul li ul li ul li:before{content:'- ';display:table-cell;padding-right:15px}article ol li ol li ol li{list-style-type:lower-roman;padding-left:10px;margin-left:12px!important}article table tbody>tr>td{vertical-align:top}article table ul li{font-size:14px;margin-left:15px!important;display:table}article table ol li{font-size:14px;margin-left:30px!important;padding-right:10px;padding-left:6px!important}article table ul li ul li{font-size:14px;padding-right:6px;margin-left:0!important;display:table}article table ul li ul li:before{padding-right:12px}article table ul li ul li ul li{font-size:14px;display:table}article table ul li ul li ul li:before{padding-right:10px}article ol li ol li ol li:first-child,article ol li ol li:first-child,article ol>li:first-child,article table ol li ol li ol>li:first-child,article table ol li ol>li:first-child,article table ol>li:first-child,article table ul li ul li ul>li:first-child,article table ul li ul>li:first-child,article table ul>li:first-child,article ul li ul li ul li:first-child,article ul li ul li:first-child,article ul>li:first-child{padding-top:6px}article ol li ol li ol li:last-child,article ol li ol li:last-child,article ol>li:last-child,article table ol li ol li ol>li:last-child,article table ol li ol>li:last-child,article table ol>li:last-child,article table ul li ul li ul>li:last-child,article table ul li ul>li:last-child,article table ul>li:last-child,article ul li ul li ul li:last-child,article ul li ul li:last-child,article ul>li:last-child{padding-bottom:6px}.hc-calendar-toggle{background:0 0;border:none;box-sizing:border-box;color:#00aeff;cursor:pointer;display:inline-block;height:32px;line-height:1.5;margin:0;outline:0;overflow:visible;padding:0;position:relative;text-align:center;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:baseline;-webkit-tap-highlight-color:transparent;white-space:nowrap;width:32px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: HcDatepickerIntl },
        { type: ɵngcc0.ChangeDetectorRef },
        {
          type: String,
          decorators: [
            {
              type: Attribute,
              args: ["tabindex"],
            },
          ],
        },
      ];
    },
    {
      tabIndex: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      datepicker: [
        {
          type: Input,
          args: ["for"],
        },
      ],
      _customIcon: [
        {
          type: ContentChild,
          args: [DatepickerToggleIconDirective, { static: false }],
        },
      ],
      _button: [
        {
          type: ViewChild,
          args: ["button", { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NativeDateAdapter,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        {
          type: String,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Inject,
              args: [HC_DATE_LOCALE],
            },
          ],
        },
        { type: ɵngcc9.Platform },
      ];
    },
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(NativeDateModule, {
      imports: function () {
        return [PlatformModule];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NativeDateModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [PlatformModule],
            providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(HcNativeDateModule, {
      imports: [NativeDateModule],
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcNativeDateModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [NativeDateModule],
            providers: [{ provide: HC_DATE_FORMATS, useValue: ɵ0$1 }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcLabelExtensionComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-label-ext",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostHcLabelClass: [
        {
          type: HostBinding,
          args: ["class.hc-form-field-label-extension"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFormDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcForm]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      tight: [
        {
          type: Input,
        },
      ],
      _formFields: [
        {
          type: ContentChildren,
          args: [HcFormFieldComponent],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(FormFieldModule, {
      declarations: function () {
        return [
          HcFormFieldComponent,
          HcErrorComponent,
          HcPrefixDirective,
          HcSuffixDirective,
          HcLabelComponent,
          HcLabelExtensionComponent,
          HcFormDirective,
        ];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [
          HcFormFieldComponent,
          HcErrorComponent,
          HcPrefixDirective,
          HcSuffixDirective,
          HcLabelComponent,
          HcLabelExtensionComponent,
          HcFormDirective,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    FormFieldModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [
              HcFormFieldComponent,
              HcErrorComponent,
              HcPrefixDirective,
              HcSuffixDirective,
              HcLabelComponent,
              HcLabelExtensionComponent,
              HcFormDirective,
            ],
            exports: [
              HcFormFieldComponent,
              HcErrorComponent,
              HcPrefixDirective,
              HcSuffixDirective,
              HcLabelComponent,
              HcLabelExtensionComponent,
              HcFormDirective,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(InputModule, {
      declarations: function () {
        return [InputDirective];
      },
      imports: function () {
        return [CommonModule, FormFieldModule];
      },
      exports: function () {
        return [InputDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    InputModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, FormFieldModule],
            declarations: [InputDirective],
            exports: [InputDirective],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcOptionDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "option[ngValue]",
          },
        ],
      },
    ],
    null,
    {
      ngValue: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SelectComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-select",
            template:
              '<div class="hc-select-container" [class.hc-select-tight]="tight">\n    <span class="hc-select-chevron"></span>\n    <select\n        #selectInput\n        class="hc-select-input"\n        [disabled]="disabled"\n        (change)="_change($event, selectInput.value)"\n        [value]="value"\n        (focus)="focus.next()"\n        (blur)="blur.next()"\n        [required]="required"\n    >\n        <option *ngIf="placeholder" value="" selected disabled hidden>{{ placeholder }}</option>\n        <ng-content></ng-content>\n    </select>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            providers: [
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => SelectComponent
                ),
              },
            ],
            styles: [
              ".hc-select{display:inline-block;width:100%}.hc-select-container{position:relative}.hc-select-container select:-moz-focusring{color:transparent;text-shadow:0 0 0 #000}@-moz-document url-prefix(){.hc-select-container select:focus{outline:0}}.hc-select-chevron{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;height:35px;-webkit-box-pack:center;justify-content:center;line-height:35px;pointer-events:none;position:absolute;right:0;text-align:center;top:0;width:35px}.hc-select-chevron:after{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNi45NzgiIGhlaWdodD0iMTcuMzE5IiB2aWV3Qm94PSIwIDAgMjYuOTc4IDE3LjMxOSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNSIgZGF0YS1uYW1lPSJQYXRoIDUiIGNsYXNzPSJjbHMtMSIgZD0iTTI4LjE3NS0xMi4xODhhMS4wODEsMS4wODEsMCwwLDAsMC0xLjUyM0wyNS40LTE2LjQ3M2ExLjA2MSwxLjA2MSwwLDAsMC0xLjUwNywwTDE1LTcuNTg0bC04Ljg5LTguODlhMS4wNjEsMS4wNjEsMCwwLDAtMS41MDcsMEwxLjgyNS0xMy43MTFhMS4wODEsMS4wODEsMCwwLDAsMCwxLjUyM0wxNC4yNDcuMjE4YTEuMDYxLDEuMDYxLDAsMCwwLDEuNTA3LDBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS41MTEgMTYuNzg3KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;box-sizing:border-box;content:'';height:8.5px;margin-top:2px;pointer-events:none;width:13px}.hc-select-disabled .hc-select-chevron{opacity:.4}.hc-select-tight .hc-select-chevron{height:28px}.hc-select-input{font-size:1rem;-webkit-appearance:none;-moz-appearance:none;background-color:#fff;border:1px solid #c0c5cc;border-radius:0;color:#333;cursor:pointer;font:inherit;height:35px;line-height:1.3;padding-left:9px;padding-right:32px;width:100%}.hc-select-input::-ms-expand{display:none}.hc-select-input[disabled]{background-color:#f0f3f6;border:1px solid #e0e0e0;color:#adadad;cursor:not-allowed}.hc-select-input:hover{border:1px solid #00aeff;background-color:#f2fbff}.hc-select-input:focus{border:1px solid #00aeff;background-color:#fff;box-shadow:0 0 3px #00aeff;outline:0}.hc-form-field-invalid .hc-select-input{border:1px solid #cc2027}.hc-form-field-invalid .hc-select-input:focus{box-shadow:0 0 3px #cc2027}.hc-select-tight .hc-select-input{font-size:.92857rem;height:28px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        {
          type: ɵngcc7.NgForm,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.FormGroupDirective,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.NgControl,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Self,
            },
          ],
        },
      ];
    },
    {
      focus: [
        {
          type: Output,
        },
      ],
      blur: [
        {
          type: Output,
        },
      ],
      change: [
        {
          type: Output,
        },
      ],
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-select"],
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      required: [
        {
          type: Input,
        },
      ],
      id: [
        {
          type: Input,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      _disabledClass: [
        {
          type: HostBinding,
          args: ["class.hc-select-disabled"],
        },
      ],
      _options: [
        {
          type: ContentChildren,
          args: [HcOptionDirective],
        },
      ],
      _nativeSelect: [
        {
          type: ViewChild,
          args: ["selectInput", { static: false }],
        },
      ],
      placeholder: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(SelectModule, {
      declarations: function () {
        return [SelectComponent, HcOptionDirective];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [SelectComponent, HcOptionDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SelectModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [SelectComponent, HcOptionDirective],
            declarations: [SelectComponent, HcOptionDirective],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(DatepickerModule, {
      declarations: function () {
        return [
          CalendarComponent,
          CalendarBodyComponent,
          DatepickerComponent,
          DatepickerContentComponent,
          DatepickerInputDirective,
          DatepickerToggleComponent,
          DatepickerToggleIconDirective,
          MonthViewComponent,
          YearViewComponent,
          MultiYearViewComponent,
          CalendarHeaderComponent,
        ];
      },
      imports: function () {
        return [
          CommonModule,
          FormsModule,
          ReactiveFormsModule,
          ButtonModule,
          IconModule,
          InputModule,
          FormFieldModule,
          SelectModule,
          OverlayModule,
          A11yModule,
          PortalModule,
        ];
      },
      exports: function () {
        return [
          CalendarComponent,
          CalendarBodyComponent,
          DatepickerComponent,
          DatepickerContentComponent,
          DatepickerInputDirective,
          DatepickerToggleComponent,
          DatepickerToggleIconDirective,
          MonthViewComponent,
          YearViewComponent,
          MultiYearViewComponent,
          CalendarHeaderComponent,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DatepickerModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [
              CommonModule,
              FormsModule,
              ReactiveFormsModule,
              ButtonModule,
              IconModule,
              InputModule,
              FormFieldModule,
              SelectModule,
              OverlayModule,
              A11yModule,
              PortalModule,
            ],
            exports: [
              CalendarComponent,
              CalendarBodyComponent,
              DatepickerComponent,
              DatepickerContentComponent,
              DatepickerInputDirective,
              DatepickerToggleComponent,
              DatepickerToggleIconDirective,
              MonthViewComponent,
              YearViewComponent,
              MultiYearViewComponent,
              CalendarHeaderComponent,
            ],
            declarations: [
              CalendarComponent,
              CalendarBodyComponent,
              DatepickerComponent,
              DatepickerContentComponent,
              DatepickerInputDirective,
              DatepickerToggleComponent,
              DatepickerToggleIconDirective,
              MonthViewComponent,
              YearViewComponent,
              MultiYearViewComponent,
              CalendarHeaderComponent,
            ],
            providers: [
              HcDatepickerIntl,
              HC_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
            ],
            entryComponents: [
              DatepickerContentComponent,
              CalendarHeaderComponent,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ConfigStoreService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CalendarWrapperComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-calendar-wrapper",
            template:
              '<div class="form-container">\n    <hc-form-field class="hc-calendar-wrapper-form-field">\n        <hc-label [innerText]="prefixLabel"></hc-label>\n        <input\n            hcInput\n            hcDatepicker\n            [(ngModel)]="selectedDate"\n            required\n            (dateChange)="_onInputChange($event)"\n            [min]="minDate"\n            [max]="maxDate"\n            [_mode]="mode"\n            [_hourCycle]="hourCycle"\n        />\n        <hc-error [innerText]="invalidDateLabel"></hc-error>\n    </hc-form-field>\n</div>\n<hc-calendar\n    [mode]="mode"\n    [hourCycle]="hourCycle"\n    [startAt]="selectedDate"\n    [selected]="selectedDate"\n    [minDate]="minDate"\n    [maxDate]="maxDate"\n    (selectedChange)="_onCalendarChange($event)"\n    [dateFilter]="configStore.weekendFilter"\n>\n</hc-calendar>\n',
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-calendar-wrapper-form-field>.hc-form-field-wrapper{height:70px;padding-bottom:0}.hc-calendar-wrapper>.form-container{padding-left:13px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ConfigStoreService }, { type: ɵngcc0.ChangeDetectorRef }];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-calendar-wrapper"],
        },
      ],
      selectedDateChange: [
        {
          type: Output,
        },
      ],
      mode: [
        {
          type: Input,
        },
      ],
      hourCycle: [
        {
          type: Input,
        },
      ],
      selectedDate: [
        {
          type: Input,
        },
      ],
      hcCalendar: [
        {
          type: ViewChild,
          args: [CalendarComponent, { static: true }],
        },
      ],
      datePickerInput: [
        {
          type: ViewChild,
          args: [DatepickerInputDirective, { static: true }],
        },
      ],
      dateFormat: [
        {
          type: Input,
        },
      ],
      prefixLabel: [
        {
          type: Input,
        },
      ],
      excludeWeekends: [
        {
          type: Input,
        },
      ],
      minDate: [
        {
          type: Input,
        },
      ],
      maxDate: [
        {
          type: Input,
        },
      ],
      invalidDateLabel: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PickerOverlayComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-date-range-picker-overlay",
            template:
              '<div class="hc-date-range-calendar-container" *ngIf="options$ | async as options">\n    <div class="hc-date-range-calendar-item hc-date-range-calendar-wrapper">\n        <hc-calendar-wrapper\n            [prefixLabel]="options.startDatePrefix"\n            [selectedDate]="_fromDate"\n            [minDate]="options.fromMinMax?.fromDate"\n            (selectedDateChange)="_updateFromDate($event)"\n            [maxDate]="options.fromMinMax?.toDate"\n            [excludeWeekends]="options.excludeWeekends"\n            [dateFormat]="options.format"\n            [invalidDateLabel]="options.invalidDateLabel"\n            [mode]="options.mode"\n            [hourCycle]="options.hourCycle"\n        ></hc-calendar-wrapper>\n    </div>\n    <div class="hc-date-range-calendar-item hc-date-range-calendar-wrapper">\n        <hc-calendar-wrapper\n            [prefixLabel]="options.endDatePrefix"\n            [selectedDate]="_toDate"\n            [minDate]="options.toMinMax?.fromDate"\n            [maxDate]="options.toMinMax?.toDate"\n            (selectedDateChange)="_updateToDate($event)"\n            [excludeWeekends]="options.excludeWeekends"\n            [dateFormat]="options.format"\n            [invalidDateLabel]="options.invalidDateLabel"\n            [mode]="options.mode"\n            [hourCycle]="options.hourCycle"\n        ></hc-calendar-wrapper>\n    </div>\n    <div class="hc-date-range-calendar-item hc-date-range">\n        <div class="hc-date-range-menu">\n            <hc-radio-group class="presets" [(ngModel)]="_selectedPreset">\n                <hc-radio-button *ngFor="let p of options.presets; let i = index" [value]="i" (change)="_updateRangeByPreset(i)">\n                    {{ p.presetLabel }}\n                </hc-radio-button>\n            </hc-radio-group>\n            <div class="hc-date-range-controls">\n                <button class="hc-date-range-control" hc-button buttonStyle="link" type="button" (click)="_discardNewDates()">\n                    {{ options.cancelLabel }}\n                </button>\n                <button\n                    class="hc-date-range-control"\n                    hc-button\n                    buttonStyle="primary"\n                    type="button"\n                    [disabled]="!(this._toDate && this._fromDate)"\n                    (click)="_applyNewDates()"\n                >\n                    {{ options.applyLabel }}\n                </button>\n            </div>\n            <hc-chip *ngIf="_rangeIsInvalid" color="red">\n                <span class="hc-date-range-warning-icon"></span>The start date cannot be after the end date.\n            </hc-chip>\n        </div>\n    </div>\n</div>\n\n\n',
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              ".hc-date-range-calendar-container{display:-webkit-box;display:flex;justify-content:space-around;min-width:650px}.hc-date-range-calendar-item{font-size:14px;font-weight:400;min-width:210px;padding:1em}.hc-date-range-calendar-wrapper{width:338px}.hc-date-range-menu{height:100%;width:250px}.hc-date-range-controls{display:-webkit-box;display:flex;justify-content:space-around;margin:10% auto}.hc-date-range-control{min-width:120px!important}.hc-date-range-overlay{background:#fff;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.hc-date-range-overlay-backdrop{background-color:rgba(0,0,0,.2);opacity:.2}.presets{padding-left:21px}.hc-date-range-warning-icon{-webkit-box-flex:1;flex:1 0 auto;width:16px;height:16px;margin-right:10px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMCA3OS41IDcwLjEiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc5LjUgNzAuMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6Izk1MUMxRTt9DQo8L3N0eWxlPg0KPHRpdGxlPndhcm48L3RpdGxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTc4LjgsNjIuOEw0NCwyLjRjLTEuMy0yLjMtNC4zLTMuMS02LjctMS44Yy0wLjcsMC40LTEuNCwxLTEuOCwxLjhMMC43LDYyLjhjLTEuMywyLjMtMC41LDUuMywxLjgsNi43DQoJYzAuNywwLjQsMS42LDAuNywyLjQsMC43aDY5LjdjMi43LDAsNC45LTIuMiw0LjktNC45Qzc5LjUsNjQuNCw3OS4yLDYzLjUsNzguOCw2Mi44eiBNMzUuMiwyMC43aDkuMnYyNS43aC05LjJWMjAuN3ogTTM5LjcsNjAuOA0KCWMtMy4xLDAtNS42LTIuNS01LjYtNS42czIuNS01LjYsNS42LTUuNnM1LjYsMi41LDUuNiw1LjZDNDUuNCw1OC4yLDQyLjgsNjAuOCwzOS43LDYwLjh6Ii8+DQo8L3N2Zz4NCg==)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ConfigStoreService },
        { type: ɵngcc3.OverlayRef },
        { type: ɵngcc0.ChangeDetectorRef },
      ];
    },
    {
      calendarWrappers: [
        {
          type: ViewChildren,
          args: [CalendarWrapperComponent],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    CalendarOverlayService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.Injector }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DateRangeDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcDateRange]",
            providers: [CalendarOverlayService, ConfigStoreService, DatePipe],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        { type: CalendarOverlayService },
        { type: ConfigStoreService },
      ];
    },
    {
      selectedDateRangeChanged: [
        {
          type: Output,
        },
      ],
      selectedPresetChanged: [
        {
          type: Output,
        },
      ],
      /**
       * @return {?}
       */
      _onClick: [
        {
          type: HostListener,
          args: ["click"],
        },
      ],
      selectedDate: [
        {
          type: Input,
        },
      ],
      options: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    RadioGroupDirective,
    [
      {
        type: Directive,
        args: [
          {
            // tslint:disable:directive-selector
            selector: "hc-radio-group",
            providers: [
              {
                provide: HcFormControlComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => RadioGroupDirective
                ),
                multi: true,
              },
            ],
            exportAs: "hcRadioGroup",
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ChangeDetectorRef },
        {
          type: ɵngcc7.NgForm,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.FormGroupDirective,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        {
          type: ɵngcc7.NgControl,
          decorators: [
            {
              type: Optional,
            },
            {
              type: Self,
            },
          ],
        },
      ];
    },
    {
      _verticalClass: [
        {
          type: HostBinding,
          args: ["class.hc-radio-group-vertical"],
        },
      ],
      _horizontalClass: [
        {
          type: HostBinding,
          args: ["class.hc-radio-group-horizontal"],
        },
      ],
      change: [
        {
          type: Output,
        },
      ],
      name: [
        {
          type: Input,
        },
      ],
      id: [
        {
          type: Input,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      required: [
        {
          type: Input,
        },
      ],
      inline: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      radios: [
        {
          type: ContentChildren,
          args: [
            forwardRef(
              /**
               * @return {?}
               */ () => RadioButtonComponent
            ),
            { descendants: true },
          ],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    RadioButtonComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-radio-button",
            template:
              '<label class="hc-radio-container"\n    [class.disabled]="disabled"\n    [class.hc-radio-inline]="_inlineGroup"\n    [class.hc-radio-tight]="tight" >\n    <input class="hc-radio-input"\n           [class.disabled]="disabled"\n           type="radio"\n           [id]="_inputId"\n           [attr.value]="value"\n           [attr.name]="name"\n           [disabled]="disabled"\n           [required]="required"\n           [checked]="checked"\n           (change)="_onInputChange($event)"\n           (click)="_onInputClick($event)"/>\n    <span class="hc-radio-overlay" [class.disabled]="disabled"></span>\n    <div class="hc-radio-content">\n        <ng-content></ng-content>\n    </div>\n</label>\n',
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              ".hc-radio-container{cursor:pointer;display:block;line-height:1.5;margin:4px 0;padding-left:35px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.hc-radio-container.disabled{color:#ccc;cursor:not-allowed}.hc-radio-container.hc-radio-inline{padding-left:32px;margin-right:25px}.hc-radio-container.hc-radio-tight{margin:1px 15px 1px 0;padding-left:25px}.hc-radio-tight .hc-radio-overlay{height:18px;width:18px;top:1px}.hc-radio-tight .hc-radio-overlay:after{left:3px;top:3px}.hc-radio-tight .hc-radio-content{font-size:.92857rem}.hc-radio-overlay{background-color:#fff;border:1px solid #c0c5cc;border-radius:50%;height:22px;left:0;position:absolute;top:0;width:22px}.hc-radio-overlay:after{background:#fff;border-radius:50%;content:'';display:none;height:8px;left:5px;position:absolute;top:5px;width:8px}.hc-radio-overlay.disabled{background-color:#e0e0e0;border-color:#ccc;cursor:not-allowed}.hc-radio-overlay.disabled:after{background:#e0e0e0}.hc-radio-container:hover .hc-radio-overlay{border:1px solid #00aeff;background-color:#f2fbff}.hc-radio-container:hover .hc-radio-overlay.disabled{background-color:#e0e0e0;border-color:#ccc;cursor:not-allowed}.hc-radio-container:hover .hc-radio-overlay.disabled:after{background:#e0e0e0}.hc-radio-input:checked~.hc-radio-overlay{background-color:#00aeff;border:2px solid #00aeff}.hc-radio-input:checked~.hc-radio-overlay:after{display:block}.hc-radio-input:checked~.hc-radio-overlay.disabled{background-color:#e0e0e0;border:1px solid #ccc}.hc-radio-input{cursor:pointer;opacity:0;position:absolute}.hc-radio-input.disabled{cursor:not-allowed}.hc-radio-input:focus+.hc-radio-overlay{outline:0;box-shadow:0 0 5px #00aeff}.hc-radio-input:active+.hc-radio-overlay{outline:0}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        {
          type: RadioGroupDirective,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
        { type: ɵngcc0.ChangeDetectorRef },
        { type: ɵngcc0.ElementRef },
      ];
    },
    {
      id: [
        {
          type: Input,
        },
      ],
      change: [
        {
          type: Output,
        },
      ],
      value: [
        {
          type: Input,
        },
      ],
      checked: [
        {
          type: Input,
        },
      ],
      _getHostId: [
        {
          type: HostBinding,
          args: ["attr.id"],
        },
      ],
      required: [
        {
          type: Input,
        },
      ],
      disabled: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      name: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(RadioButtonModule, {
      declarations: function () {
        return [RadioButtonComponent, RadioGroupDirective];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [RadioButtonComponent, RadioGroupDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    RadioButtonModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [RadioButtonComponent, RadioGroupDirective],
            declarations: [RadioButtonComponent, RadioGroupDirective],
            providers: [],
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(DateRangeModule, {
      declarations: function () {
        return [
          DateRangeDirective,
          CalendarWrapperComponent,
          PickerOverlayComponent,
        ];
      },
      imports: function () {
        return [
          CommonModule,
          ChipModule,
          FormFieldModule,
          DatepickerModule,
          HcNativeDateModule,
          InputModule,
          ButtonModule,
          RadioButtonModule,
          OverlayModule,
          FormsModule,
        ];
      },
      exports: function () {
        return [DateRangeDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DateRangeModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [
              CommonModule,
              ChipModule,
              FormFieldModule,
              DatepickerModule,
              HcNativeDateModule,
              InputModule,
              ButtonModule,
              RadioButtonModule,
              OverlayModule,
              FormsModule,
            ],
            declarations: [
              DateRangeDirective,
              CalendarWrapperComponent,
              PickerOverlayComponent,
            ],
            entryComponents: [PickerOverlayComponent],
            exports: [DateRangeDirective],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    Drawer,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-drawer",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
            animations: [
              trigger("openState", [
                state(
                  "open-left, open-right, open-instant",
                  style({
                    visibility: "visible",
                  })
                ),
                state(
                  "void",
                  style({
                    "box-shadow": "none",
                    visibility: "hidden",
                  })
                ),
                transition("void => open-instant", animate("0ms")),
                transition("open-instant => void", animate(openStateAnimation)),
                transition("void => open-left", [
                  animate(
                    "0ms",
                    style({ transform: "translate3d(-100%, 0, 0)" })
                  ),
                  animate(openStateAnimation),
                ]),
                transition("open-left => void", [
                  animate(
                    openStateAnimation,
                    style({ transform: "translate3d(-100%, 0, 0)" })
                  ),
                ]),
                transition("void => open-right", [
                  animate(
                    "0ms",
                    style({ transform: "translate3d(100%, 0, 0)" })
                  ),
                  animate(openStateAnimation),
                ]),
                transition("open-right => void", [
                  animate(
                    openStateAnimation,
                    style({ transform: "translate3d(100%, 0, 0)" })
                  ),
                ]),
              ]),
            ],
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              ".hc-drawer,.hc-menu-drawer{bottom:0;box-sizing:border-box;display:block;height:100%;outline:0;overflow-y:auto;position:absolute;top:0;z-index:3}.hc-drawer.hc-drawer-opened:not(.drawer-side),.hc-drawer.hc-drawer-opening:not(.drawer-side),.hc-menu-drawer.hc-drawer-opened:not(.drawer-side),.hc-menu-drawer.hc-drawer-opening:not(.drawer-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.hc-drawer-right{right:0}.hc-drawer-container{position:relative;z-index:1;box-sizing:border-box;display:block;overflow:hidden}.hc-drawer-content{position:relative;z-index:1;display:block;height:100%;left:0;overflow:auto;padding:10px 20px;right:0;-webkit-transition-duration:.4s;transition-duration:.4s;-webkit-transition-property:margin-left,margin-right,-webkit-transform;transition-property:transform,margin-left,margin-right,-webkit-transform;-webkit-transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-timing-function:cubic-bezier(.25,.8,.25,1)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      tabindex: [
        {
          type: HostBinding,
        },
      ],
      _drawerClass: [
        {
          type: HostBinding,
          args: ["class.hc-drawer"],
        },
      ],
      mode: [
        {
          type: Input,
        },
      ],
      align: [
        {
          type: Input,
        },
      ],
      openStart: [
        {
          type: Output,
        },
      ],
      closeStart: [
        {
          type: Output,
        },
      ],
      _openStream: [
        {
          type: Output,
          args: ["opened"],
        },
      ],
      _closeStream: [
        {
          type: Output,
          args: ["closed"],
        },
      ],
      opened: [
        {
          type: Input,
        },
      ],
      _isOpened: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-opened"],
        },
      ],
      _isOpening: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-opening"],
        },
      ],
      _isClosed: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-closed"],
        },
      ],
      _isClosing: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-closing"],
        },
      ],
      _isRight: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-right"],
        },
      ],
      _openState: [
        {
          type: HostBinding,
          args: ["@openState"],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _onAnimationStart: [
        {
          type: HostListener,
          args: ["@openState.start", ["$event"]],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _onAnimationEnd: [
        {
          type: HostListener,
          args: ["@openState.done", ["$event"]],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _onKeyDown: [
        {
          type: HostListener,
          args: ["keydown", ["$event"]],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DrawerContainer,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-drawer-container",
            template:
              '<ng-content select="hc-drawer,hc-menu-drawer"></ng-content>\n\n<div class="hc-drawer-content"\n     [style.margin-left.px]="_contentMargins.left"\n     [style.margin-right.px]="_contentMargins.right">\n    <ng-content></ng-content>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-drawer,.hc-menu-drawer{bottom:0;box-sizing:border-box;display:block;height:100%;outline:0;overflow-y:auto;position:absolute;top:0;z-index:3}.hc-drawer.hc-drawer-opened:not(.drawer-side),.hc-drawer.hc-drawer-opening:not(.drawer-side),.hc-menu-drawer.hc-drawer-opened:not(.drawer-side),.hc-menu-drawer.hc-drawer-opening:not(.drawer-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.hc-drawer-right{right:0}.hc-drawer-container{position:relative;z-index:1;box-sizing:border-box;display:block;overflow:hidden}.hc-drawer-content{position:relative;z-index:1;display:block;height:100%;left:0;overflow:auto;padding:10px 20px;right:0;-webkit-transition-duration:.4s;transition-duration:.4s;-webkit-transition-property:margin-left,margin-right,-webkit-transform;transition-property:transform,margin-left,margin-right,-webkit-transform;-webkit-transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-timing-function:cubic-bezier(.25,.8,.25,1)}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        { type: ɵngcc0.Renderer2 },
        { type: ɵngcc0.NgZone },
        { type: ɵngcc0.ChangeDetectorRef },
      ];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-container"],
        },
      ],
      _drawers: [
        {
          type: ContentChildren,
          args: [Drawer],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DrawerToolbar,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcDrawerToolbar]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-drawer-toolbar"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    MenuDrawer,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-menu-drawer",
            template:
              '<div class="hc-menu-drawer-toolbar-container">\n    <ng-content select="[hcDrawerToolbar]"></ng-content>\n</div>\n<div class="hc-menu-drawer-item-container">\n    <div class="drawer-menu">\n        <ng-content select="hc-drawer-item"></ng-content>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            animations: [
              trigger("openState", [
                state(
                  "open-left, open-right, open-instant",
                  style({
                    transform: "translate3d(0, 0, 0)",
                    visibility: "visible",
                  })
                ),
                state(
                  "void",
                  style({
                    "box-shadow": "none",
                    visibility: "hidden",
                  })
                ),
                transition("void => open-instant", animate("0ms")),
                transition(
                  "open-instant => void",
                  animate(openStateAnimation$1)
                ),
                transition("void => open-left", [
                  animate(
                    "0ms",
                    style({ transform: "translate3d(-100%, 0, 0)" })
                  ),
                  animate(openStateAnimation$1),
                ]),
                transition("open-left => void", [
                  animate(
                    openStateAnimation$1,
                    style({ transform: "translate3d(-100%, 0, 0)" })
                  ),
                ]),
                transition("void => open-right", [
                  animate(
                    "0ms",
                    style({ transform: "translate3d(100%, 0, 0)" })
                  ),
                  animate(openStateAnimation$1),
                ]),
                transition("open-right => void", [
                  animate(
                    openStateAnimation$1,
                    style({ transform: "translate3d(100%, 0, 0)" })
                  ),
                ]),
              ]),
            ],
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [
              {
                provide: Drawer,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => MenuDrawer
                ),
              },
            ],
            styles: [
              ".hc-drawer,.hc-menu-drawer{bottom:0;box-sizing:border-box;display:block;height:100%;outline:0;overflow-y:auto;position:absolute;top:0;z-index:3}.hc-drawer.hc-drawer-opened:not(.drawer-side),.hc-drawer.hc-drawer-opening:not(.drawer-side),.hc-menu-drawer.hc-drawer-opened:not(.drawer-side),.hc-menu-drawer.hc-drawer-opening:not(.drawer-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.hc-drawer-right{right:0}.hc-drawer-container{position:relative;z-index:1;box-sizing:border-box;display:block;overflow:hidden}.hc-drawer-content{position:relative;z-index:1;display:block;height:100%;left:0;overflow:auto;padding:10px 20px;right:0;-webkit-transition-duration:.4s;transition-duration:.4s;-webkit-transition-property:margin-left,margin-right,-webkit-transform;transition-property:transform,margin-left,margin-right,-webkit-transform;-webkit-transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-timing-function:cubic-bezier(.25,.8,.25,1)}",
              ".hc-menu-drawer{display:block;overflow:hidden}.hc-menu-drawer-item-container{background-color:#384655;height:100%;overflow-y:auto}.hc-drawer-toolbar-visible .hc-menu-drawer-item-container{height:calc(100% - 52px)}.hc-menu-drawer-toolbar-container{background-color:#2e3946;color:#00aeff;display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;font-size:18px}.hc-drawer-toolbar{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:52px;max-height:52px;overflow:hidden;padding:15px 28px 15px 15px}.hc-drawer-item{color:#fff;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-webkit-box-align:center;align-items:center;padding:15px 28px 15px 15px;cursor:pointer;width:100%}.hc-drawer-item:last-child hr{display:none}.hc-drawer-item:hover{background-color:#323f4d}.hc-drawer-divider{border:none;background-color:#6b737b;height:1px;margin:0 28px 0 0}.hc-drawer-right .hc-drawer-divider{margin:0 0 0 15px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-menu-drawer"],
        },
      ],
      menuTheme: [
        {
          type: Input,
        },
      ],
      toolbar: [
        {
          type: ContentChild,
          args: [DrawerToolbar, { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DrawerItem,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-drawer-item",
            template: `
        <div class="hc-drawer-item">
            <ng-content></ng-content>
        </div>
        <hr class="hc-drawer-divider" />
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    null,
    null
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(DrawerModule, {
      declarations: function () {
        return [Drawer, DrawerContainer, MenuDrawer, DrawerItem, DrawerToolbar];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [Drawer, DrawerContainer, MenuDrawer, DrawerItem, DrawerToolbar];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    DrawerModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: exportedComponents,
            exports: exportedComponents,
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-list",
            template: "<ng-content></ng-content>\n",
            encapsulation: ViewEncapsulation.None,
            styles: [".hc-list{display:block}"],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-list"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListItemComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-list-item",
            template:
              '<div class="hc-list-content">\n    <ng-content select="[hcListAvatar], [hcListIcon]"></ng-content>\n    <div class="hc-list-text">\n        <ng-content select="[hcListLine]"></ng-content>\n    </div>\n    <ng-content></ng-content>\n</div>\n\n\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-list-item{color:rgba(0,0,0,.87);display:block;font-size:16px;height:56px}.hc-list-content{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;height:inherit;padding:0 12px}.hc-list-text{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;padding-left:16px;width:100%}.hc-list-avatar,.hc-list-icon{font-size:24px;height:24px;padding:4px;width:24px}.hc-list-avatar{border-radius:50%}.hc-list-line{display:block;font-size:inherit;font-weight:400;margin:0;overflow:hidden;padding:0;text-overflow:ellipsis;white-space:nowrap}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-list-item"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListAvatarDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcListAvatar]",
          },
        ],
      },
    ],
    null,
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-list-avatar"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListIconDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcListIcon]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-list-icon"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListLineDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcListLine]",
          },
        ],
      },
    ],
    null,
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-list-line"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ListModule, {
      declarations: function () {
        return [
          ListComponent,
          ListItemComponent,
          ListAvatarDirective,
          ListIconDirective,
          ListLineDirective,
        ];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [
          ListComponent,
          ListItemComponent,
          ListAvatarDirective,
          ListIconDirective,
          ListLineDirective,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ListModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [
              ListComponent,
              ListItemComponent,
              ListAvatarDirective,
              ListIconDirective,
              ListLineDirective,
            ],
            exports: [
              ListComponent,
              ListItemComponent,
              ListAvatarDirective,
              ListIconDirective,
              ListLineDirective,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal",
            template: `
        <ng-content></ng-content>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _modalWrapperClass: [
        {
          type: HostBinding,
          args: ["class.hc-modal-content"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalFooterComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal-footer",
            template: `
        <ng-content></ng-content>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _modalFooterClass: [
        {
          type: HostBinding,
          args: ["class.hc-modal-footer"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalWindowComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal-window",
            template: `
        <div [class]="'hc-modal hc-modal-' + _size"><ng-content></ng-content></div>
    `,
            encapsulation: ViewEncapsulation.None,
            // tslint:disable-next-line: no-host-metadata-property
            host: { class: "hc-modal-window" },
            animations: [
              trigger("fadeInOut", [
                state("in", style({ opacity: 1 })),
                transition("void <=> *", [
                  style({
                    opacity: 0,
                  }),
                  animate("0.2s ease-in-out"),
                ]),
              ]),
            ],
            styles: [
              ".hc-modal-window{-webkit-box-align:center;align-items:center;bottom:0;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;left:0;position:fixed;right:0;top:0}.hc-modal{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;height:calc(100% - 50px);-webkit-box-pack:center;justify-content:center;max-height:calc(100% - 50px);min-height:135px}.hc-modal-auto{width:auto}.hc-modal-sm{width:300px}.hc-modal-md{width:500px}.hc-modal-lg{width:800px}.hc-modal-xl{width:992px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ActiveModal }, { type: ɵngcc0.ElementRef }];
    },
    {
      _ignoreOverlayClick: [
        {
          type: Input,
        },
      ],
      _size: [
        {
          type: Input,
        },
      ],
      /**
       * @return {?}
       */
      _fadeInOut: [
        {
          type: HostBinding,
          args: ["@fadeInOut"],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _overlayClick: [
        {
          type: HostListener,
          args: ["mousedown", ["$event"]],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalOverlayComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal-overlay",
            template: "",
            encapsulation: ViewEncapsulation.None,
            // tslint:disable-next-line: no-host-metadata-property
            host: { class: "hc-modal-overlay" },
            animations: [
              trigger("fadeInOut", [
                state("in", style({ opacity: 0.5 })),
                transition("void <=> *", [
                  style({
                    opacity: 0,
                  }),
                  animate("0.2s ease-in-out"),
                ]),
              ]),
            ],
            styles: [
              `
            .hc-modal-overlay {
                background-color: #000;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                opacity: 0.5;
                display: block;
            }
        `,
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ActiveModal }];
    },
    {
      _ignoreEscapeKey: [
        {
          type: Input,
        },
      ],
      /**
       * @return {?}
       */
      _fadeInOut: [
        {
          type: HostBinding,
          args: ["@fadeInOut"],
        },
      ],
      /**
       * @param {?} event
       * @return {?}
       */
      _escapeKey: [
        {
          type: HostListener,
          args: ["document:keyup.escape", ["$event"]],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ComponentFactoryResolver },
        { type: ɵngcc0.Injector },
        { type: ɵngcc0.ApplicationRef },
        { type: ɵngcc0.RendererFactory2 },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalHeaderComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal-header",
            template: `
        <ng-content></ng-content>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _modalHeaderClass: [
        {
          type: HostBinding,
          args: ["class.hc-modal-header"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalBodyComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-modal-body",
            template: `
        <ng-content></ng-content>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _modalBodyClass: [
        {
          type: HostBinding,
          args: ["class.hc-modal-body"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ModalModule, {
      declarations: function () {
        return [
          ModalOverlayComponent,
          ModalWindowComponent,
          ModalHeaderComponent,
          ModalBodyComponent,
          ModalFooterComponent,
          ModalComponent,
        ];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [
          ModalHeaderComponent,
          ModalBodyComponent,
          ModalFooterComponent,
          ModalComponent,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ModalModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            declarations: [
              ModalOverlayComponent,
              ModalWindowComponent,
              ModalHeaderComponent,
              ModalBodyComponent,
              ModalFooterComponent,
              ModalComponent,
            ],
            entryComponents: [ModalOverlayComponent, ModalWindowComponent],
            exports: [
              ModalHeaderComponent,
              ModalBodyComponent,
              ModalFooterComponent,
              ModalComponent,
            ],
            providers: [ModalService],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NavbarLinkComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-navbar-link",
            template:
              '<a \n    *ngIf="!_hidden" \n    title="{{linkText}}" \n    [routerLink]="uri" \n    routerLinkActive="active"\n    class="navbar-link"\n    [ngClass]="{ \'active\': this.active === true, \'inactive\': this.active === false }"\n    [routerLinkActiveOptions]="{exact: exact}"\n>\n    {{linkText}}<ng-content></ng-content>\n</a>\n',
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }];
    },
    {
      exact: [
        {
          type: Input,
        },
      ],
      active: [
        {
          type: Input,
        },
      ],
      uri: [
        {
          type: Input,
        },
      ],
      linkText: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NavbarMobileMenuComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-navbar-mobile-menu",
            template:
              '<div #navbarMobile class="hc-navbar-mobile-menu-dropdown" [style.top.px]="_yPos">\n    <ng-content></ng-content>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-navbar-mobile-menu-dropdown{background-color:#262f34;visibility:hidden;margin-top:53px;padding-top:15px;position:fixed;-webkit-transition:top .7s;transition:top .7s;width:100%;z-index:960}@media (max-width:768px){.hc-navbar-mobile-menu-dropdown{display:inline;visibility:visible}}.hc-navbar-mobile-menu-dropdown hr{background-color:#51646f;border:0;height:1px;margin:0 0 0 5%!important}.hc-navbar-mobile-menu-dropdown hc-list a{text-decoration:none}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item{color:#d7dde4;cursor:pointer;display:block;visibility:inherit;padding-left:2%;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item:hover{background-color:#1b2225}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item:focus{outline:0}.hc-navbar-mobile-menu-dropdown hc-list .active-link{background-color:#1b2225;border-left:8px solid #00aeff;color:#fff;font-weight:700}.hc-navbar-mobile-menu-dropdown hc-list .hc-list-item.active-link .hc-list-content{padding-left:4px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ChangeDetectorRef }];
    },
    {
      mobileMenu: [
        {
          type: ViewChild,
          args: ["navbarMobile", { static: false }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NavbarComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-navbar",
            template:
              '<nav #navbar class="hc-navbar" [ngClass]="{\'fixed-top\': fixedTop}">\n    <div class="navbar-brand">\n        <a [routerLink]="homeUri" class="brand" tabIndex="-1">\n            <img *ngIf="_brandIconType() == \'string\'" src="{{ brandIcon }}" />\n            <hc-icon\n                *ngIf="_brandIconType() != \'string\'"\n                [fontSet]="_brandIconSet()"\n                [fontIcon]="_brandIconGlyph()"\n                [ngStyle]="{height: _brandIconSize(), \'font-size\': _brandIconSize()}"\n            ></hc-icon>\n        </a>\n    </div>\n    <div class="navbar-app">\n        <a [routerLink]="homeUri" class="app" *ngIf="appIcon">\n            <img src="{{ appIcon }}" />\n        </a>\n    </div>\n    <div #navlinks class="hc-navbar-link-container">\n        <ng-content select="hc-navbar-link, hc-navbar-dropdown"></ng-content>\n        <div class="hc-navbar-more-links" tabindex="0" title="More" *ngIf="_collapse" [hcPop]="navbarMore" #moreLink="hcPopAnchor">\n            More\n            <hc-icon fontSet="fa" fontIcon="fa-chevron-down" hcIconSm></hc-icon>\n        </div>\n    </div>\n\n    <div #rightcontainer class="hc-navbar-right-container">\n        <ng-content></ng-content>\n    </div>\n    <div class="hc-navbar-mobile-menu" *ngIf="_mobileMenu.first" (click)="_toggleMobileMenu()">\n        <hc-icon fontSet="fa" [fontIcon]="_mobileMenuIcon" hcIconMd></hc-icon>\n    </div>\n</nav>\n<div (click)="_menuClick($event)">\n    <ng-content select="hc-navbar-mobile-menu"></ng-content>\n</div>\n\n<hc-pop #navbarMore [autoCloseOnContentClick]="true" [showArrow]="false" horizontalAlign="end">\n    <div hcMenu>\n        <ng-container *ngFor="let item of _moreList; let i = index">\n            <ng-container *ngIf="!item.dropdown">\n                <a hcMenuItem routerLinkActive="active" [routerLink]="item.uri" (click)="_moreClick()">\n                    <span hcMenuText>{{item.name}}</span>\n                </a>\n            </ng-container>\n            <ng-container *ngIf="item.dropdown">\n                <button hcMenuItem [hcPop]="item.dropdown">\n                    <span hcMenuText>{{item.name}}</span>\n                </button>\n            </ng-container>\n            <div *ngIf="i != _moreList.length - 1" hcMenuItem hcDivider></div>\n        </ng-container>\n    </div>\n</hc-pop>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              '.hc-navbar{height:53px;background-color:#384655;display:-webkit-box;display:flex;font-size:15px;line-height:1}.hc-navbar.fixed-top{top:0;position:fixed;right:0;left:0;z-index:970;box-shadow:0 2px 6px rgba(0,0,0,.15)}.hc-navbar .navbar-brand{background-color:#00aeff;flex-basis:auto;height:100%;width:55px;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center}.hc-navbar .navbar-brand .brand{-webkit-transition:background-color .25s;transition:background-color .25s;display:-webkit-box;display:flex;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center;height:100%;cursor:default;min-width:55px}.hc-navbar .navbar-brand .brand>img{height:37px;width:100%}.hc-navbar .navbar-brand .brand>hc-icon{width:100%;color:#fff}.hc-navbar .navbar-app{height:100%}.hc-navbar .navbar-app a{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;padding-left:25px;padding-right:50px;height:100%}.hc-navbar .navbar-app a img{height:30px;width:auto;padding-top:2px}.hc-navbar .navbar-app a:focus{outline-offset:-8px}@media (max-width:576px){.hc-navbar .navbar-brand{display:none}.hc-navbar .navbar-app{padding:0 0 0 5%}}.hc-navbar .hc-navbar-link-container{display:-webkit-box;display:flex;list-style-type:none;margin:0;padding:0;overflow:hidden;width:100%}@media (max-width:768px){.hc-navbar .hc-navbar-link-container{display:none}}.hc-navbar .navbar-link{display:inline-block;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;white-space:nowrap;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s;outline:0}.hc-navbar .navbar-link.inactive:hover,.hc-navbar .navbar-link:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .navbar-link:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .navbar-link.active:not(.inactive),.hc-navbar .navbar-link:active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .navbar-link:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .navbar-dropdown{display:inline-block;white-space:nowrap;cursor:pointer;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar .navbar-dropdown hc-icon{margin-left:5px;vertical-align:top;margin-top:1px;margin-right:-10px;font-size:13px!important}.hc-navbar .navbar-dropdown.inactive:hover,.hc-navbar .navbar-dropdown:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .navbar-dropdown:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .navbar-dropdown.active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .navbar-dropdown:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .hc-navbar-right-container{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;-webkit-box-align:center;align-items:center;position:relative;margin-left:auto}@media (max-width:768px){.hc-navbar .hc-navbar-right-container{display:none}}.hc-navbar .hc-navbar-icon{height:53px;color:#fff;cursor:pointer;-webkit-transition:background-color .25s;transition:background-color .25s;min-width:53px!important;padding:18px 0}.hc-navbar .hc-navbar-icon.inactive:hover,.hc-navbar .hc-navbar-icon:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-icon:focus{outline:0;background-color:#28323c}.hc-navbar .hc-navbar-username{height:53px;color:#fff;cursor:pointer;-webkit-transition:background-color .25s;transition:background-color .25s;padding:2px 15px 0;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;white-space:nowrap}.hc-navbar .hc-navbar-username.inactive:hover,.hc-navbar .hc-navbar-username:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-username:focus{outline:0;background-color:#28323c}.hc-navbar .hc-navbar-username>hc-icon{font-size:12pt;padding-top:2px}.hc-navbar .hc-navbar-username-subtext{color:#c0c5cc}.hc-navbar .hc-navbar-vertical-separator{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-navbar .hc-navbar-vertical-separator::after{content:"|";font-size:18px;color:#fff}.hc-navbar .hc-navbar-more-links{display:inline-block;white-space:nowrap;cursor:pointer;height:100%;box-sizing:border-box;padding:22px 30px 0;text-align:center;color:#ccc;border-bottom:5px solid transparent;-webkit-transition:background-color .25s;transition:background-color .25s}.hc-navbar .hc-navbar-more-links hc-icon{margin-left:5px;vertical-align:top;margin-top:1px;margin-right:-10px;font-size:13px!important}.hc-navbar .hc-navbar-more-links.inactive:hover,.hc-navbar .hc-navbar-more-links:hover:not(.active){outline:0;color:#fff;background-color:#2e3946}.hc-navbar .hc-navbar-more-links:focus{outline:0;color:#fff;background-color:#28323c}.hc-navbar .hc-navbar-more-links.active:not(.inactive){color:#fff;font-weight:600;border-bottom:5px solid #00aeff}.hc-navbar .hc-navbar-more-links:before{display:block;content:attr(title);font-weight:600;height:1px;color:transparent;overflow:hidden;visibility:hidden;margin-bottom:-1px}.hc-navbar .hc-navbar-mobile-menu{background-color:#262f34;color:#d7dde4;width:55px;flex-basis:auto;height:100%;-webkit-box-pack:center;justify-content:center;-webkit-box-align:center;align-items:center;margin-left:auto;cursor:pointer;display:none}.hc-navbar .hc-navbar-mobile-menu hc-icon{font-size:25px!important;height:25px!important;width:25px!important}@media (max-width:768px){.hc-navbar .hc-navbar-mobile-menu{display:-webkit-box;display:flex}}',
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ChangeDetectorRef }];
    },
    {
      user: [
        {
          type: Input,
        },
      ],
      appIcon: [
        {
          type: Input,
        },
      ],
      brandIcon: [
        {
          type: Input,
        },
      ],
      homeUri: [
        {
          type: Input,
        },
      ],
      fixedTop: [
        {
          type: Input,
        },
      ],
      /**
       * @return {?}
       */
      _navResize: [
        {
          type: HostListener,
          args: ["window:resize"],
        },
      ],
      _mobileMenu: [
        {
          type: ContentChildren,
          args: [NavbarMobileMenuComponent],
        },
      ],
      _navLinks: [
        {
          type: ContentChildren,
          args: [NavbarLinkComponent],
        },
      ],
      navbarContent: [
        {
          type: ViewChild,
          args: ["navbar", { static: false }],
        },
      ],
      navContent: [
        {
          type: ViewChild,
          args: ["navlinks", { static: false }],
        },
      ],
      _navbarMore: [
        {
          type: ViewChild,
          args: ["moreLink", { static: false }],
        },
      ],
      _morePop: [
        {
          type: ViewChild,
          args: ["navbarMore", { static: false }],
        },
      ],
    }
  );
})();
const ɵNavbarDropdownComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  NavbarDropdownComponent
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NavbarDropdownComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-navbar-dropdown",
            template:
              '<a\n    *ngIf="!_hidden"\n    title="{{linkText}}"\n    routerLinkActive="active"\n    class="navbar-dropdown"\n    [ngClass]="{active: this.active === true, inactive: this.active === false}"\n    [hcPop]="menuPop"\n    tabindex="0"\n>\n    {{linkText}}\n    <hc-icon fontSet="fa" fontIcon="fa-chevron-down" hcIconSm></hc-icon>\n</a>\n\n<hc-pop #menuPop [autoCloseOnContentClick]="true" [showArrow]="false">\n    <ng-content></ng-content>\n</hc-pop>\n',
            encapsulation: ViewEncapsulation.None,
            providers: [
              {
                provide: NavbarLinkComponent,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => NavbarDropdownComponent
                ),
              },
            ],
          },
        ],
      },
    ],
    null,
    {
      _menuPop: [
        {
          type: ViewChild,
          args: ["menuPop", { static: false }],
        },
      ],
      _menuItems: [
        {
          type: ContentChildren,
          args: [MenuItemDirective, { descendants: true }],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(NavbarModule, {
      declarations: function () {
        return [
          NavbarComponent,
          NavbarDropdownComponent,
          NavbarLinkComponent,
          NavbarMobileMenuComponent,
        ];
      },
      imports: function () {
        return [CommonModule, RouterModule, IconModule, PopModule];
      },
      exports: function () {
        return [
          NavbarComponent,
          NavbarDropdownComponent,
          NavbarLinkComponent,
          NavbarMobileMenuComponent,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    NavbarModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, RouterModule, IconModule, PopModule],
            declarations: [
              NavbarComponent,
              NavbarDropdownComponent,
              NavbarLinkComponent,
              NavbarMobileMenuComponent,
            ],
            exports: [
              NavbarComponent,
              NavbarDropdownComponent,
              NavbarLinkComponent,
              NavbarMobileMenuComponent,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵBasePaginationComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  BasePaginationComponent
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    BasePaginationComponent,
    [
      {
        type: Component,
        args: [
          {
            template: "",
          },
        ],
      },
    ],
    null,
    {
      page: [
        {
          type: Output,
        },
      ],
      pageNumberChange: [
        {
          type: Output,
        },
      ],
      pageSizeChange: [
        {
          type: Output,
        },
      ],
      length: [
        {
          type: Input,
        },
      ],
      pageNumber: [
        {
          type: Input,
        },
      ],
      pageSize: [
        {
          type: Input,
        },
      ],
    }
  );
})();
const ɵPaginationComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  PaginationComponent
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PaginationComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-pagination",
            template:
              '<div class="hc-pagination-container">\n    <div *ngIf="!hidePageSize" class="hc-font-sm hc-page-detail-container">\n        <label class="hc-page-detail-label">Showing:</label>\n        <hc-select class="hc-page-detail-select" [value]="pageSize" (change)="_changePageSize($event.value)" (focus)="isFocused = true" (blur)="isFocused = false">\n            <option *ngFor="let pageSizeOption of _displayedPageSizeOptions" [value]="pageSizeOption">\n                {{ isFocused ? pageSizeOption : pageSize === pageSizeOption && pageSizeOption > length ? \'all\' : pageSizeOption }}\n            </option>\n        </hc-select>\n        <label class="hc-page-detail-entries">of <strong>{{ length }}</strong> entries</label\n        >\n    </div>\n\n    <div class="hc-page-btns-container">\n        <button\n            hc-button\n            color="secondary"\n            class="hc-page-button hc-page-left-button"\n            (click)="_previousPage()"\n            [disabled]="!totalPages || _isFirstPage"\n        >\n            <span class="hc-page-button-chevron hc-page-button-chevron-left"></span>\n            <span>PREV</span>\n        </button>\n        <!-- large width page navigation buttons -->\n        <ng-container *ngIf="displayWidth === \'lg\'">\n            <button\n                hc-button\n                color="secondary"\n                class="hc-page-button hc-page-inner-button"\n                *ngFor="let page of _visiblePages"\n                [disabled]="!page"\n                [class.hc-page-button-current]="page === pageNumber"\n                (click)="_goToPage(page)"\n            >\n                <span *ngIf="!!page">{{ page }}</span>\n                <span *ngIf="!page" class="hc-page-button-ellipsis"></span>\n            </button>\n        </ng-container>\n        <!-- medium width page navigation buttons -->\n        <ng-container *ngIf="displayWidth === \'md\'">\n            <button\n                hc-button\n                color="secondary"\n                class="hc-page-button hc-page-inner-button"\n                *ngFor="let page of _collapsedVisiblePages"\n                [disabled]="!page"\n                [class.hc-page-button-current]="page === pageNumber"\n                (click)="_goToPage(page)"\n            >\n                <span *ngIf="!!page">{{ page }}</span>\n                <span *ngIf="!page" class="hc-page-button-ellipsis"></span>\n            </button>\n        </ng-container>\n        <button\n            hc-button\n            color="secondary"\n            class="hc-page-button hc-page-right-button"\n            (click)="_nextPage()"\n            [disabled]="!totalPages || _isLastPage"\n        >\n            <span>NEXT</span>\n            <span class="hc-page-button-chevron"></span>\n        </button>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-pagination-container{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;flex-wrap:wrap;-webkit-box-pack:justify;justify-content:space-between;margin-top:15px;width:100%}.hc-page-detail-container{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;margin-right:10px;padding:5px 0}.hc-page-detail-label{color:#6d6e70;-webkit-box-flex:0;flex:0 0 auto}.hc-page-detail-select{-webkit-box-flex:1;flex:1 0 65px;margin:0 7px}.hc-page-detail-entries{white-space:nowrap}.hc-range-label{-webkit-box-flex:0;flex:0 0 auto;margin-right:10px;padding:12px 0}.hc-page-btns-container{display:-webkit-inline-box;display:inline-flex;padding:5px 0}.hc-pagination-container .hc-page-btns-container .hc-page-button{background-color:#fff;border:2px solid #e0e0e0;color:#00aeff;font-weight:700;margin-right:0;min-width:40px}.hc-pagination-container .hc-page-btns-container .hc-page-button:hover{color:#008bcc}.hc-pagination-container .hc-page-btns-container .hc-page-button:focus{outline:0}.hc-pagination-container .hc-page-btns-container .hc-page-button.hc-page-button-current{background-color:#00aeff;color:#fff}.hc-pagination-container .hc-page-btns-container .hc-page-left-button{border-bottom-right-radius:0;border-top-right-radius:0;padding:0 15px}.hc-pagination-container .hc-page-btns-container .hc-page-right-button{border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0;padding:0 15px}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button{border-left-width:0;padding:0 5px;border-radius:0}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button[disabled]{border-bottom-color:rgba(204,204,204,.35);border-top-color:rgba(204,204,204,.35);color:rgba(0,174,255,.35);opacity:1}.hc-pagination-container .hc-page-btns-container .hc-page-inner-button[disabled]:hover{background-color:#fff}.hc-pagination-container .hc-page-btns-container .hc-page-button-chevron{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI3LjM4NSIgaGVpZ2h0PSIxMiIgdmlld0JveD0iMCAwIDcuMzg1IDEyIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjMDBhZWZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8cGF0aCBpZD0iUGF0aF81IiBkYXRhLW5hbWU9IlBhdGggNSIgY2xhc3M9ImNscy0xIiBkPSJNMTMuMzcxLTE0LjgyNmEuNDQ4LjQ0OCwwLDAsMCwwLS42NWwtMS4yMzYtMS4xNzhhLjQ4Ni40ODYsMCwwLDAtLjY3LDBsLTMuOTU0LDMuNzktMy45NTQtMy43OWEuNDg2LjQ4NiwwLDAsMC0uNjcsMEwxLjY1MS0xNS40NzVhLjQ0OC40NDgsMCwwLDAsMCwuNjVsNS41MjUsNS4yOWEuNDg2LjQ4NiwwLDAsMCwuNjcsMFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2Ljc4NyAxMy41MTEpIHJvdGF0ZSgtOTApIi8+Cjwvc3ZnPgo=);background-repeat:no-repeat;background-size:contain;display:inline-block;height:12px;margin:1px 3px 0 7px;width:7px}.hc-pagination-container .hc-page-btns-container .hc-page-button-chevron-left{margin:1px 7px 0 3px;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.hc-pagination-container .hc-page-btns-container .hc-page-button-ellipsis{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSI1IiB2aWV3Qm94PSIwIDAgMjAgNSI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgZmlsbDogIzAwYWVmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICA8L2RlZnM+CiAgPHBhdGggaWQ9IlBhdGhfNiIgZGF0YS1uYW1lPSJQYXRoIDYiIGNsYXNzPSJjbHMtMSIgZD0iTTUuNDU1LTEzLjc1QTEuMzExLDEuMzExLDAsMCwwLDQuMDkxLTE1SDEuMzY0QTEuMzExLDEuMzExLDAsMCwwLDAtMTMuNzV2Mi41QTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEwSDQuMDkxYTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEuMjVabTcuMjczLDBBMS4zMTEsMS4zMTEsMCwwLDAsMTEuMzY0LTE1SDguNjM2YTEuMzExLDEuMzExLDAsMCwwLTEuMzY0LDEuMjV2Mi41QTEuMzExLDEuMzExLDAsMCwwLDguNjM2LTEwaDIuNzI3YTEuMzExLDEuMzExLDAsMCwwLDEuMzY0LTEuMjVabTcuMjczLDBBMS4zMTEsMS4zMTEsMCwwLDAsMTguNjM2LTE1SDE1LjkwOWExLjMxMSwxLjMxMSwwLDAsMC0xLjM2NCwxLjI1djIuNUExLjMxMSwxLjMxMSwwLDAsMCwxNS45MDktMTBoMi43MjdBMS4zMTEsMS4zMTEsMCwwLDAsMjAtMTEuMjVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDE1KSIvPgo8L3N2Zz4K);background-repeat:no-repeat;background-size:contain;display:inline-block;height:3px;margin-bottom:1px;opacity:.4;width:11px}",
            ],
          },
        ],
      },
    ],
    null,
    {
      displayWidth: [
        {
          type: Input,
        },
      ],
      pageSizeOptions: [
        {
          type: Input,
        },
      ],
      hidePageSize: [
        {
          type: Input,
        },
      ],
    }
  );
})();
const ɵLoadMorePaginationComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  LoadMorePaginationComponent
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    LoadMorePaginationComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-load-more-pagination",
            template:
              '<button hc-button class="hc-page-load-more-button" [buttonStyle]="buttonStyle" (click)="_loadNextPage()" [disabled]="_isLastPage">\n    {{buttonText}}\n</button>',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-page-load-more-button{display:block;margin:20px auto;min-width:30%}",
            ],
          },
        ],
      },
    ],
    null,
    {
      buttonText: [
        {
          type: Input,
        },
      ],
      buttonStyle: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(PaginationModule, {
      declarations: function () {
        return [
          PaginationComponent,
          LoadMorePaginationComponent,
          BasePaginationComponent,
        ];
      },
      imports: function () {
        return [CommonModule, ButtonModule, IconModule, SelectModule];
      },
      exports: function () {
        return [
          PaginationComponent,
          LoadMorePaginationComponent,
          BasePaginationComponent,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PaginationModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, ButtonModule, IconModule, SelectModule],
            declarations: [
              PaginationComponent,
              LoadMorePaginationComponent,
              BasePaginationComponent,
            ],
            exports: [
              PaginationComponent,
              LoadMorePaginationComponent,
              BasePaginationComponent,
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-picklist",
            template:
              '<div class="hc-picklist">\n    <div class="pane-wrap">\n        <div class="pane-header">\n            <h2 *ngIf="settings.showHeaderText">{{settings.leftHeaderText}}</h2>\n            <div *ngIf="settings.useValuesets" class="pane-tabs hc-tab-bar-horizontal">\n                <a title="Search for Value Sets"\n                        (click)="setActiveValueType(\'valueSets\')"\n                        class="hc-tab-horizontal"\n                        [ngClass]="{\'active\': _available?.valueSetList.isActive}">Value Sets</a>\n                <a title="Search for Values"\n                    (click)="setActiveValueType(\'values\')"\n                    class="hc-tab-horizontal"\n                    [ngClass]="{\'active\': _available?.valueList.isActive}">Values</a>\n            </div>\n        </div>\n        <hc-picklist-pane #availableList\n            emptyMsg="No options available."\n            (moveSelectedItems)="moveSelectedItems($event);">\n        </hc-picklist-pane>\n    </div>\n\n    <div class="move-btns-wrap">\n        <button hc-button color="primary-alt" type="button" name="addBtn"\n                (click)="moveSelectedItems(availableList);"\n                [disabled]="_leftToRightMoveBtnIsDisabled">\n            <hc-icon hcIconSm fontSet="fa" fontIcon="fa-arrow-right"></hc-icon>\n        </button>\n        <button hc-button color="primary-alt" type="button" name="removeBtn"\n                (click)="moveSelectedItems(confirmedList);"\n                [disabled]="!_confirmed?.isAnySelected()">\n            <hc-icon hcIconSm fontSet="fa" fontIcon="fa-arrow-left"></hc-icon>\n        </button>\n    </div>\n\n    <div class="pane-wrap">\n        <div class="pane-header">\n            <h2 *ngIf="settings.showHeaderText">{{settings.rightHeaderText}}</h2>\n        </div>\n        <hc-picklist-pane #confirmedList\n            emptyMsg="No options selected."\n            (moveSelectedItems)="moveSelectedItems($event);">\n        </hc-picklist-pane>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            providers: [
              {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(
                  /**
                   * @return {?}
                   */ () => PicklistComponent
                ),
                multi: true,
              },
            ],
            styles: [
              ".hc-picklist{-webkit-box-align:stretch;align-items:stretch;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row;height:100%;-webkit-box-pack:justify;justify-content:space-between;min-width:650px}.hc-picklist .pane-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;width:45%}.hc-picklist .pane-header{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 30px;-webkit-box-pack:justify;justify-content:space-between}.hc-picklist .pane-header h2{font-size:16px;font-weight:700;margin:3px 0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.hc-picklist .pane-tabs{border-bottom:none;-webkit-box-flex:0;flex:0 0 auto}.hc-picklist .pane-tabs a{font-size:13px}.hc-picklist hc-picklist-pane{display:block;-webkit-box-flex:1;flex:1 1 auto;height:calc(100% - 30px)}.hc-picklist hc-picklist-pane.hide{display:none}.hc-picklist .move-btns-wrap{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;-webkit-box-pack:center;justify-content:center;padding-top:100px;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.hc-picklist .move-btns-wrap button{height:60px;margin-top:12px;min-width:0;padding:0;width:30px}.hc-picklist .move-btns-wrap button[disabled],.hc-picklist .move-btns-wrap button[disabled]:hover{background-color:#ccc;border-color:#ccc}.hc-picklist .move-btns-wrap .hc-icon{color:#fff}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      changed: [
        {
          type: Output,
        },
      ],
      settings: [
        {
          type: Input,
        },
      ],
      simpleOptions: [
        {
          type: Input,
        },
      ],
      showHeaderText: [
        {
          type: Input,
        },
      ],
      leftHeaderText: [
        {
          type: Input,
        },
      ],
      rightHeaderText: [
        {
          type: Input,
        },
      ],
      sort: [
        {
          type: Input,
        },
      ],
      _available: [
        {
          type: ViewChild,
          args: ["availableList", { static: true }],
        },
      ],
      _confirmed: [
        {
          type: ViewChild,
          args: ["confirmedList", { static: true }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistFilterLocalService,
    [
      {
        type: Injectable,
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistStateService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: PicklistFilterLocalService }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistFilterRemoteService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: PicklistStateService }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistFilterService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        { type: WorkTrackerService },
        { type: PicklistStateService },
        { type: PicklistFilterRemoteService },
        { type: PicklistFilterLocalService },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistValuesetMovingService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: PicklistFilterService }, { type: PicklistStateService }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [
        { type: WorkTrackerService },
        { type: PicklistFilterService },
        { type: PicklistFilterLocalService },
        { type: PicklistValuesetMovingService },
        { type: PicklistStateService },
      ];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistActionService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: PicklistService }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistPaneComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-picklist-pane",
            template:
              '<div class="hc-picklist-pane">\n    <div class="picklist-controls">\n        <hc-form-field>\n            <input hcInput #searchInput (keyup)="onSearchKeyup()" [(ngModel)]="searchTerm" type="text" placeholder="Search" >\n            <hc-icon hcSuffix fontSet="fa" fontIcon="fa-search"></hc-icon>\n        </hc-form-field>\n        <div class="second-row-controls">\n            <div class="hc-type-em">\n                Showing {{optionsShowingCount.toLocaleString()}} of {{optionsAvailableCount.toLocaleString()}}\n            </div>\n            <div>\n                <button type="button" class="btn-text-link" (click)="selectAll()" [disabled]="valueList.filteredOptions.length === 0 && valueSetList.filteredOptions.length === 0">\n                    Select All\n                </button>\n                <button type="button" class="btn-text-link" (click)="selectNone()" [disabled]="!isAnySelected()">\n                    Select None\n                </button>\n            </div>\n        </div>\n    </div>\n\n    <div class="list-container" #listContainer>\n        <!-- Valuesets -->\n        <div *ngIf="valueSetList.isActive && (valueSetList.loadingOptions | async)" class="loading-list"><hc-progress-dots></hc-progress-dots></div>\n        <table *ngIf="shouldShowList(valueSetList) && !(valueSetList.loadingOptions | async)" class="hc-table hc-table-small valueset-table">\n            <tbody>\n                <!-- Header, shown when both values and valuesets are sitting in list at same time -->\n                <tr *ngIf="shouldShowList(valueSetList) && shouldShowList(valueList)"><th colspan="2">Value Sets</th></tr>\n\n                <!-- Value set List Items -->\n                <tr *ngFor="let item of valueSetList.filteredOptions; let idx=index;"\n                    (mousedown)="preventIEHighlightBug()"\n                    (click)="onItemClicked($event, idx, valueSetList, item);"\n                    (dblclick)="onItemDoubleClicked($event, valueSetList, item);"\n                    [ngClass]="{\'hc-row-selected selected\': item.selected}"\n                    class="valueset-option value-option-row"><td>\n                        <div>\n                            <span class="valueset-value-toggle" (click)="onValuesetCaretClicked($event, item)">\n                                <hc-icon hcIconSm class="values-caret" fontSet="fa" [ngClass]="{\'values-caret-showing-values\': item.showValues}" fontIcon="fa-caret-right"></hc-icon>\n                                <hc-icon hcIconSm class="vs-folder" fontSet="fa" [fontIcon]="item.showValues ? \'fa-folder-open-o\' : \'fa-folder-o\'"></hc-icon>\n                            </span>\n                            <!-- TODO: more deets for the valueset -->\n                            <span class="vs-title">{{item.option.title || "Untitled"}} ({{item.option.subValueCount}})</span>\n                        </div>\n                        <div>\n                            <!-- Value set Values List (closed by default) -->\n                            <table *ngIf="item.showValues" class="valueset-sublist-table hc-table"><tbody>\n                                <tr *ngIf="item.loadingValues" class="loading-subvals"><hc-progress-dots></hc-progress-dots></tr>\n                                <tr *ngFor="let subItem of item.subValuesSelectList.filteredOptions; let idx=index;"\n                                    (mousedown)="preventIEHighlightBug()"\n                                    (click)="onItemClicked($event, idx, item.subValuesSelectList, subItem);"\n                                    (dblclick)="onItemDoubleClicked($event, item.subValuesSelectList, subItem);"\n                                    class="value-option-row hc-tr"\n                                    [ngClass]="{\'hc-row-selected\': subItem.selected}"><td>\n                                        <span *ngIf="codeIsSignificant" class="valueset-code">{{subItem.option.code}}</span>\n                                        <span>{{subItem.option.title || "Untitled"}}</span>\n                                    </td>\n                                </tr>\n                            </tbody></table>\n                        </div>\n                </td></tr>\n\n                <!-- Load More link for value sets, available when paging -->\n                <tr *ngIf="isPaged && optionsShowingCount < optionsAvailableCount" class="text-center value-option-row load-more-row">\n                    <a class="load-more-link text-link" (click)="triggerLoadMore(\'valuesets\')" *ngIf="!(valueSetList.appendingOptions | async)">Load More</a>\n                    <hc-progress-dots *ngIf="valueSetList.appendingOptions | async"></hc-progress-dots>\n                </tr>\n            </tbody>\n        </table>\n\n        <!-- Values -->\n        <div *ngIf="valueList.isActive && (valueList.loadingOptions | async)" class="loading-list"><hc-progress-dots></hc-progress-dots></div>\n        <table *ngIf="shouldShowList(valueList) && !(valueList.loadingOptions | async)" class="hc-table hc-table-small" [ngClass]="{\'no-code-column\': !codeIsSignificant}">\n            <tbody>\n                <!-- Header, shown when both values and valuesets are sitting in list at same time -->\n                <tr *ngIf="shouldShowList(valueSetList) && shouldShowList(valueList)"><th colspan="2">Individual Values</th></tr>\n\n                <!-- Show when user clicked "select all", and there are more options on server, but too many to load in at once -->\n                <tr *ngIf="showTooManyToSelectAllMsg" class="value-option-row select-all-matches-row">\n                    <td colspan="2">\n                        <span class="hc-type-bold">{{valueList.selectedOptions.size}} Selected.</span>\n                        <span>Too many results to select all.</span>\n                    </td>\n                </tr>\n\n                <!-- Value List Items -->\n                <tr *ngFor="let item of valueList.filteredOptions; let idx=index;"\n                    (mousedown)="preventIEHighlightBug()"\n                    (click)="onItemClicked($event, idx, valueList, item);"\n                    (dblclick)="onItemDoubleClicked($event, valueList, item);"\n                    class="value-option-row"\n                    [ngClass]="{\'hc-row-selected\': item.selected}">\n                        <td *ngIf="codeIsSignificant" class="col-code">{{item.option.code}}</td>\n                        <td class="col-title">{{item.option.title || "Untitled"}}</td>\n                </tr>\n\n                <!-- Load More link for values, available when paging -->\n                <tr *ngIf="isPaged && optionsShowingCount < optionsAvailableCount" class="text-center value-option-row load-more-row">\n                    <a class="load-more-link text-link" (click)="triggerLoadMore(\'values\')" *ngIf="!(valueList.appendingOptions | async)">Load More</a>\n                    <hc-progress-dots *ngIf="valueList.appendingOptions | async"></hc-progress-dots>\n                </tr>\n            </tbody>\n        </table>\n\n        <!-- Empty table -->\n        <div class="empty-table-msg hc-type-em" *ngIf="!shouldShowList(valueSetList) && !shouldShowList(valueList) && !(valueList.loadingOptions | async) && !(valueSetList.loadingOptions | async)">\n                <span *ngIf="listIsFilteredToEmpty(valueList) || listIsFilteredToEmpty(valueSetList); else emptyMessage">Nothing matches your search.</span>\n                <span><ng-template #emptyMessage>{{emptyMsg}}</ng-template></span>\n        </div>\n    </div>\n</div>\n',
            providers: [
              PicklistService,
              PicklistStateService,
              PicklistValuesetMovingService,
              PicklistActionService,
              PicklistFilterService,
              PicklistFilterRemoteService,
              PicklistFilterLocalService,
              WorkTrackerService,
            ],
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-picklist-pane{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;height:100%}.hc-picklist-pane .hc-form-field-wrapper{border:none;padding-bottom:0}.hc-picklist-pane .picklist-controls{display:-webkit-box;display:flex;-webkit-box-flex:0;flex:0 0 auto;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-flow:column;font-size:12px}.hc-picklist-pane .second-row-controls{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;-webkit-box-pack:justify;justify-content:space-between;margin:15px 0 2px}.hc-picklist-pane .picklist-controls button{font-family:'Open Sans',sans-serif;margin-left:10px}.hc-picklist-pane .picklist-controls .btn-text-link{background:0 0;border:none;color:#00aeff;cursor:pointer;font-size:12px;padding:0;text-align:left}.hc-picklist-pane .picklist-controls .btn-text-link:active{box-shadow:none;color:#008bcc;outline:0;text-decoration:underline}.hc-picklist-pane .picklist-controls .btn-text-link:hover{color:#009de6;text-decoration:underline}.hc-picklist-pane .picklist-controls .btn-text-link[disabled]{color:#c0c5cc;cursor:default;opacity:1;text-decoration:none}.hc-picklist-pane .loading-list{border:1px solid #d7dde4;height:100%}.hc-picklist-pane .list-container{background-color:#fff;border:1px solid #d7dde4;-webkit-box-flex:1;flex:1 1 300px;overflow-y:scroll;position:relative}.hc-picklist-pane .hc-table th{background-color:#e0e6ec;border-bottom:1px solid #d0dae3;border-top:1px solid #d0dae3;font-size:12px;font-style:italic;font-weight:400}.hc-picklist-pane .hc-table tbody{border:0}.hc-picklist-pane .hc-table .select-all-matches-row{background-color:#f9efce;border-color:#fff;color:#846b11;text-align:center}.hc-picklist-pane .hc-table .load-more-row{display:block;font-size:12px;font-weight:700;height:36px;padding:11px;text-align:center}.hc-picklist-pane .hc-table .load-more-link{cursor:pointer}.hc-picklist-pane .hc-table .col-code{width:20%;word-break:normal}.hc-picklist-pane .hc-table .valueset-table{display:block;width:100%}.hc-picklist-pane .hc-table .value-option-row{cursor:default;font-weight:400;line-height:1.1;user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.hc-picklist-pane .hc-table .valueset-value-toggle{color:#00aeff;cursor:pointer;-webkit-transform:color .2s;transform:color .2s}.hc-picklist-pane .hc-table .valueset-value-toggle:hover{color:#006899}.hc-picklist-pane .hc-table .values-caret:before{display:inline-block;font-size:13px;position:relative;top:-1px;-webkit-transition:-webkit-transform .2s;transition:transform .2s;transition:transform .2s,-webkit-transform .2s}.hc-picklist-pane .hc-table .values-caret-showing-values:before{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.hc-picklist-pane .hc-table .selected .values-caret{color:#fff}.hc-picklist-pane .hc-table .vs-folder{left:-3px;position:relative}.hc-picklist-pane .hc-table .selected .vs-folder{color:#fff}.hc-picklist-pane .hc-table .loading-subvals{height:40px}.hc-picklist-pane .hc-table .valueset-sublist-table{border:1px solid #d7dfe7;border-collapse:separate;border-radius:3px;font-size:13px;margin:10px 0 20px;overflow:hidden}.hc-picklist-pane .hc-table .valueset-code{margin-right:5px}.hc-picklist-pane .empty-table-msg{-webkit-box-align:center;align-items:center;display:-webkit-box;display:flex;height:100%;-webkit-box-pack:center;justify-content:center;position:absolute;width:100%}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: PicklistService },
        { type: PicklistActionService },
        { type: PicklistFilterService },
      ];
    },
    {
      emptyMsg: [
        {
          type: Input,
        },
      ],
      moveSelectedItems: [
        {
          type: Output,
        },
      ],
      listContainerEl: [
        {
          type: ViewChild,
          args: ["listContainer", { static: false }],
        },
      ],
      searchInputEl: [
        {
          type: ViewChild,
          args: ["search", { static: false }],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(PicklistModule, {
      declarations: function () {
        return [PicklistPaneComponent, PicklistComponent];
      },
      imports: function () {
        return [
          CommonModule,
          FormsModule,
          ButtonModule,
          IconModule,
          InputModule,
          FormFieldModule,
          ProgressIndicatorsModule,
        ];
      },
      exports: function () {
        return [PicklistPaneComponent, PicklistComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    PicklistModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [
              CommonModule,
              FormsModule,
              ButtonModule,
              IconModule,
              InputModule,
              FormFieldModule,
              ProgressIndicatorsModule,
            ],
            declarations: [PicklistPaneComponent, PicklistComponent],
            exports: [PicklistPaneComponent, PicklistComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ScrollNavLinkDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcScrollLink]",
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-scroll-nav-link"],
        },
      ],
      _hostIndex: [
        {
          type: HostBinding,
          args: ["attr.tabindex"],
        },
      ],
      /**
       * @return {?}
       */
      _onEnter: [
        {
          type: HostListener,
          args: ["keydown.enter"],
        },
      ],
      /**
       * @return {?}
       */
      _onClick: [
        {
          type: HostListener,
          args: ["click"],
        },
      ],
      hcScrollLink: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcScrollNavComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-scroll-nav",
            encapsulation: ViewEncapsulation.None,
            template:
              '<div class="hc-scroll-nav-links-container">\n  <ng-content></ng-content>\n</div>',
            styles: [
              ".hc-scroll-nav-links-container{margin-right:30px}.hc-scroll-nav-links-container ul{list-style:none}.hc-scroll-nav-link{font-size:1rem;background-color:transparent;color:#333;cursor:pointer;font-weight:500;padding:10px 15px}.hc-scroll-nav-link:hover{background-color:rgba(215,221,228,.25)}.hc-scroll-nav-link:active{background-color:rgba(215,221,228,.5)}.hc-scroll-nav-link:focus{outline:0;box-shadow:0 0 0 2px rgba(0,174,255,.4)}.hc-scroll-nav-link-active,.hc-scroll-nav-link-active:hover{background-color:#00aeff;color:#fff;font-weight:500}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      linkList: [
        {
          type: ContentChildren,
          args: [ScrollNavLinkDirective, { descendants: true }],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ScrollNavTargetDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcScrollTarget]",
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc0.ElementRef }];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-scroll-nav-target"],
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcScrollNavContentComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-scroll-nav-content",
            encapsulation: ViewEncapsulation.None,
            template:
              '<div #scrollContainer class="hc-scroll-nav-content-container" [ngClass]="{\'hc-scroll-nav-smooth\': shouldAnimateScroll}" cdk-scrollable>\n  <ng-content></ng-content>\n</div>',
            styles: [
              ".hc-scroll-nav-content-container{max-height:100%;overflow:scroll;overflow-x:hidden;width:100%}.hc-scroll-nav-smooth{scroll-behavior:smooth}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      makeLastTargetFullHeight: [
        {
          type: Input,
        },
      ],
      bufferSpace: [
        {
          type: Input,
        },
      ],
      shouldAnimateScroll: [
        {
          type: Input,
        },
      ],
      newSectionInView: [
        {
          type: Output,
        },
      ],
      /**
       * @return {?}
       */
      _onWindowResize: [
        {
          type: HostListener,
          args: ["window:resize"],
        },
      ],
      nav: [
        {
          type: Input,
        },
      ],
      _cdkScrollableElement: [
        {
          type: ViewChild,
          args: ["scrollContainer", { read: CdkScrollable, static: false }],
        },
      ],
      targets: [
        {
          type: ContentChildren,
          args: [ScrollNavTargetDirective],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ScrollNavModule, {
      declarations: function () {
        return [
          HcScrollNavContentComponent,
          HcScrollNavComponent,
          ScrollNavTargetDirective,
          ScrollNavLinkDirective,
        ];
      },
      imports: function () {
        return [CommonModule, ScrollingModule];
      },
      exports: function () {
        return [
          HcScrollNavContentComponent,
          HcScrollNavComponent,
          ScrollNavTargetDirective,
          ScrollNavLinkDirective,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ScrollNavModule,
    [
      {
        type: NgModule,
        args: [
          {
            declarations: [
              HcScrollNavContentComponent,
              HcScrollNavComponent,
              ScrollNavTargetDirective,
              ScrollNavLinkDirective,
            ],
            exports: [
              HcScrollNavContentComponent,
              HcScrollNavComponent,
              ScrollNavTargetDirective,
              ScrollNavLinkDirective,
            ],
            imports: [CommonModule, ScrollingModule],
            providers: [],
          },
        ],
      },
    ],
    null,
    null
  );
})();

/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    StepperComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-stepper",
            template:
              '<div [ngClass]="\'hc-stepper-\' + type">\n    <div class="hc-stepper-track">\n        <ng-content select=".before-steps-content"></ng-content>\n        <div\n            class="hc-step"\n            *ngFor="let step of steps; index as i; last as isLast; first as isFirst"\n            [routerLink]="step.routerLink"\n            [routerLinkActiveOptions]="{exact: true}"\n            routerLinkActive="active"\n            [queryParams]="step.queryParams"\n            [ngClass]="{\n                \'hc-step-arrow-active\': type === \'arrow\' && i === activeIndex,\n                \'hc-step-arrow-incomplete\': type === \'arrow\' && (activeIndex === undefined || i > activeIndex),\n                \'hc-step-arrow-complete\': type === \'arrow\' && (activeIndex !== undefined && i < activeIndex - 1),\n                \'hc-step-arrow-completed\': type === \'arrow\' && (activeIndex !== undefined && i === activeIndex - 1),\n                \'hc-step-isolated-active\': type === \'isolated\' && i === activeIndex,\n                \'hc-step-isolated-incomplete\': type === \'isolated\' && (activeIndex === undefined || i > activeIndex),\n                \'hc-step-isolated-complete\': type === \'isolated\' && (activeIndex !== undefined && i < activeIndex - 1),\n                \'hc-step-isolated-completed\': type === \'isolated\' && (activeIndex !== undefined && i === activeIndex - 1),\n                \'hc-step-last\': isLast,\n                \'hc-step-first\': isFirst,\n                \'hc-stepper-clickable\': step.disabled !== undefined ? !step.disabled : true,\n                \'hc-stepper-disabled\': step.disabled !== undefined ? step.disabled : false\n            }"\n            (click)="_stepClick(i)"\n        >\n            <span class="hc-step-disk">\n                <ng-container *ngIf="step.iconSet && step.icon; else elseBlock">\n                    <hc-icon [fontSet]="step.iconSet" [fontIcon]="step.icon" class="hc-step-icon"></hc-icon>\n                </ng-container>\n                <ng-template #elseBlock>{{ i + 1 }}</ng-template>\n            </span>\n            <span class="hc-step-label-count" *ngIf="showStepCount">{{ i + 1 }}</span>\n            <span class="hc-step-label">{{ step.label }}</span>\n            <span class="hc-step-arrow"></span>\n        </div>\n        <ng-content select=".after-steps-content"></ng-content>\n    </div>\n    <div *ngIf="useRouterOutlet" class="hc-step-content">\n        <router-outlet *ngIf="_routerEnabled"></router-outlet>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-step{-webkit-box-flex:1;flex:1;position:relative}.hc-stepper-arrow .hc-step{line-height:4rem;padding-left:3.6rem;white-space:nowrap;border-top-color:#f0f3f6}.hc-stepper-isolated .hc-step{padding-top:2rem;text-align:center}.hc-stepper-isolated .hc-step:before{background:#d7dde4;content:'';display:block;height:.5rem;left:0;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1}.hc-stepper-arrow .hc-step-disk{border-radius:50%;display:block;font-size:.9rem;height:1.6rem;left:1.2rem;line-height:1.6rem;position:absolute;text-align:center;top:1.2rem;width:1.6rem;box-shadow:0 0 0 3px #d7dde4;background-color:#fff}.hc-stepper-isolated .hc-step-disk{border-radius:50%;display:block;font-size:1rem;height:2rem;left:50%;line-height:2rem;margin-left:-1rem;position:absolute;text-align:center;top:0;width:2rem;z-index:2;box-shadow:0 0 0 3px #f0f3f6;background-color:#fff}.hc-stepper-green .hc-step-arrow-active .hc-step-disk,.hc-stepper-green .hc-step-isolated-active .hc-step-disk,.hc-stepper-green .hc-step-isolated-complete .hc-step-disk,.hc-stepper-green .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #00a859}.hc-stepper-blue .hc-step-arrow-active .hc-step-disk,.hc-stepper-blue .hc-step-isolated-active .hc-step-disk,.hc-stepper-blue .hc-step-isolated-complete .hc-step-disk,.hc-stepper-blue .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #00aeff}.hc-stepper-purple .hc-step-arrow-active .hc-step-disk,.hc-stepper-purple .hc-step-isolated-active .hc-step-disk,.hc-stepper-purple .hc-step-isolated-complete .hc-step-disk,.hc-stepper-purple .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #6e53a3}.hc-stepper-orange .hc-step-arrow-active .hc-step-disk,.hc-stepper-orange .hc-step-isolated-active .hc-step-disk,.hc-stepper-orange .hc-step-isolated-complete .hc-step-disk,.hc-stepper-orange .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #f8961d}.hc-stepper-red .hc-step-arrow-active .hc-step-disk,.hc-stepper-red .hc-step-isolated-active .hc-step-disk,.hc-stepper-red .hc-step-isolated-complete .hc-step-disk,.hc-stepper-red .hc-step-isolated-completed .hc-step-disk{box-shadow:0 0 0 3px #f13c45}.hc-stepper-green .hc-step-arrow-complete .hc-step-disk,.hc-stepper-green .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #23c077}.hc-stepper-blue .hc-step-arrow-complete .hc-step-disk,.hc-stepper-blue .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #42c3ff}.hc-stepper-purple .hc-step-arrow-complete .hc-step-disk,.hc-stepper-purple .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #8973b4}.hc-stepper-orange .hc-step-arrow-complete .hc-step-disk,.hc-stepper-orange .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #f9ab49}.hc-stepper-red .hc-step-arrow-complete .hc-step-disk,.hc-stepper-red .hc-step-arrow-completed .hc-step-disk{box-shadow:0 0 0 3px #f57178}.hc-step-arrow-active:not(.hc-step-last) .hc-step-arrow,.hc-step-arrow-incomplete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f0f3f6;border-bottom:2rem solid #f0f3f6;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-green .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #00a859;border-bottom:2rem solid #00a859;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-blue .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #00aeff;border-bottom:2rem solid #00aeff;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-purple .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #6e53a3;border-bottom:2rem solid #6e53a3;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-orange .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f8961d;border-bottom:2rem solid #f8961d;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-red .hc-step-arrow-completed .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f13c45;border-bottom:2rem solid #f13c45;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-green .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #23c077;border-bottom:2rem solid #23c077;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-blue .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #42c3ff;border-bottom:2rem solid #42c3ff;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-purple .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #8973b4;border-bottom:2rem solid #8973b4;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-orange .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f9ab49;border-bottom:2rem solid #f9ab49;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-red .hc-step-arrow-complete:not(.hc-step-last) .hc-step-arrow{border-left:1rem solid transparent;border-top:2rem solid #f57178;border-bottom:2rem solid #f57178;display:block;height:0;position:absolute;right:0;top:0;z-index:2}.hc-stepper-arrow .hc-step-label-count{display:none}.hc-stepper-isolated .hc-step-label-count{color:#333;display:inline-block;line-height:2rem;padding:0 .15rem}.hc-stepper-isolated .hc-step-label-count:after{content:'.'}.hc-step-isolated-active .hc-step-label-count{font-weight:600}.hc-stepper-arrow .hc-step-label{color:#fff}.hc-step-arrow-incomplete .hc-step-label{color:unset}.hc-stepper-isolated .hc-step-label{color:#333;display:inline-block;line-height:2rem;padding:0 .15rem}.hc-step-isolated-active .hc-step-label{font-weight:600}.hc-stepper-arrow .hc-step-icon{font-size:1rem;height:100%;line-height:1.6rem;width:100%}.hc-stepper-isolated .hc-step-icon{font-size:1.4rem;height:100%;line-height:1.92rem;width:100%}.hc-step-arrow-incomplete .hc-step-icon,.hc-step-isolated-incomplete .hc-step-icon{color:#d7dde4}.hc-stepper-green .hc-step-arrow-active .hc-step-icon,.hc-stepper-green .hc-step-isolated-active .hc-step-icon,.hc-stepper-green .hc-step-isolated-complete .hc-step-icon,.hc-stepper-green .hc-step-isolated-completed .hc-step-icon{color:#00a859}.hc-stepper-blue .hc-step-arrow-active .hc-step-icon,.hc-stepper-blue .hc-step-isolated-active .hc-step-icon,.hc-stepper-blue .hc-step-isolated-complete .hc-step-icon,.hc-stepper-blue .hc-step-isolated-completed .hc-step-icon{color:#00aeff}.hc-stepper-purple .hc-step-arrow-active .hc-step-icon,.hc-stepper-purple .hc-step-isolated-active .hc-step-icon,.hc-stepper-purple .hc-step-isolated-complete .hc-step-icon,.hc-stepper-purple .hc-step-isolated-completed .hc-step-icon{color:#6e53a3}.hc-stepper-orange .hc-step-arrow-active .hc-step-icon,.hc-stepper-orange .hc-step-isolated-active .hc-step-icon,.hc-stepper-orange .hc-step-isolated-complete .hc-step-icon,.hc-stepper-orange .hc-step-isolated-completed .hc-step-icon{color:#f8961d}.hc-stepper-red .hc-step-arrow-active .hc-step-icon,.hc-stepper-red .hc-step-isolated-active .hc-step-icon,.hc-stepper-red .hc-step-isolated-complete .hc-step-icon,.hc-stepper-red .hc-step-isolated-completed .hc-step-icon{color:#f13c45}.hc-stepper-green .hc-step-arrow-complete .hc-step-icon,.hc-stepper-green .hc-step-arrow-completed .hc-step-icon{color:#23c077}.hc-stepper-blue .hc-step-arrow-complete .hc-step-icon,.hc-stepper-blue .hc-step-arrow-completed .hc-step-icon{color:#42c3ff}.hc-stepper-purple .hc-step-arrow-complete .hc-step-icon,.hc-stepper-purple .hc-step-arrow-completed .hc-step-icon{color:#8973b4}.hc-stepper-orange .hc-step-arrow-complete .hc-step-icon,.hc-stepper-orange .hc-step-arrow-completed .hc-step-icon{color:#f9ab49}.hc-stepper-red .hc-step-arrow-complete .hc-step-icon,.hc-stepper-red .hc-step-arrow-completed .hc-step-icon{color:#f57178}.hc-stepper-clickable{cursor:pointer;outline:0}.hc-stepper-disabled{pointer-events:none}.hc-stepper-track{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.hc-stepper-arrow .hc-stepper-track{background-color:#f0f3f6}.hc-stepper-isolated .hc-step-first:before{left:50%}.hc-stepper-green .hc-step-arrow-active{background-color:#00a859}.hc-stepper-blue .hc-step-arrow-active{background-color:#00aeff}.hc-stepper-purple .hc-step-arrow-active{background-color:#6e53a3}.hc-stepper-orange .hc-step-arrow-active{background-color:#f8961d}.hc-stepper-red .hc-step-arrow-active{background-color:#f13c45}.hc-stepper-green .hc-step-isolated-active:before{background:#00a859;right:50%}.hc-stepper-green .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-blue .hc-step-isolated-active:before{background:#00aeff;right:50%}.hc-stepper-blue .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-purple .hc-step-isolated-active:before{background:#6e53a3;right:50%}.hc-stepper-purple .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-orange .hc-step-isolated-active:before{background:#f8961d;right:50%}.hc-stepper-orange .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-red .hc-step-isolated-active:before{background:#f13c45;right:50%}.hc-stepper-red .hc-step-isolated-active:after{background:#d7dde4;content:'';display:block;height:.5rem;margin-top:-.25rem;position:absolute;right:0;top:1rem;z-index:1;left:50%}.hc-stepper-isolated .hc-step-last:before{right:50%}.hc-stepper-isolated .hc-step-last:after{display:none}.hc-stepper-green .hc-step-arrow-complete,.hc-stepper-green .hc-step-arrow-completed{background-color:#23c077}.hc-stepper-blue .hc-step-arrow-complete,.hc-stepper-blue .hc-step-arrow-completed{background-color:#42c3ff}.hc-stepper-purple .hc-step-arrow-complete,.hc-stepper-purple .hc-step-arrow-completed{background-color:#8973b4}.hc-stepper-orange .hc-step-arrow-complete,.hc-stepper-orange .hc-step-arrow-completed{background-color:#f9ab49}.hc-stepper-red .hc-step-arrow-complete,.hc-stepper-red .hc-step-arrow-completed{background-color:#f57178}.hc-step-arrow-complete:not(.hc-step-last):after,.hc-step-arrow-incomplete:not(.hc-step-last):after{border-right:.2rem solid #d7dde4;border-left:1rem solid transparent;border-top:2rem solid #d7dde4;border-bottom:2rem solid #d7dde4;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-green .hc-step-isolated-complete:before,.hc-stepper-green .hc-step-isolated-completed:before{background:#00a859}.hc-stepper-blue .hc-step-isolated-complete:before,.hc-stepper-blue .hc-step-isolated-completed:before{background:#00aeff}.hc-stepper-purple .hc-step-isolated-complete:before,.hc-stepper-purple .hc-step-isolated-completed:before{background:#6e53a3}.hc-stepper-orange .hc-step-isolated-complete:before,.hc-stepper-orange .hc-step-isolated-completed:before{background:#f8961d}.hc-stepper-red .hc-step-isolated-complete:before,.hc-stepper-red .hc-step-isolated-completed:before{background:#f13c45}.hc-stepper-green .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #00a859;border-left:1rem solid transparent;border-top:2rem solid #00a859;border-bottom:2rem solid #00a859;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-blue .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #00aeff;border-left:1rem solid transparent;border-top:2rem solid #00aeff;border-bottom:2rem solid #00aeff;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-purple .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #6e53a3;border-left:1rem solid transparent;border-top:2rem solid #6e53a3;border-bottom:2rem solid #6e53a3;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-orange .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #f8961d;border-left:1rem solid transparent;border-top:2rem solid #f8961d;border-bottom:2rem solid #f8961d;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}.hc-stepper-red .hc-step-arrow-complete:not(.hc-step-last):not(.hc-step-arrow-completed):after{border-right:.2rem solid #f13c45;border-left:1rem solid transparent;border-top:2rem solid #f13c45;border-bottom:2rem solid #f13c45;display:block;height:0;position:absolute;right:0;top:0;content:'';z-index:1}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc6.Router }, { type: ɵngcc6.UrlSerializer }];
    },
    {
      type: [
        {
          type: Input,
        },
      ],
      activeIndexChange: [
        {
          type: Output,
        },
      ],
      _hostClass: [
        {
          type: HostBinding,
          args: ["class"],
        },
      ],
      color: [
        {
          type: Input,
        },
      ],
      showStepCount: [
        {
          type: Input,
        },
      ],
      useRouterOutlet: [
        {
          type: Input,
        },
      ],
      activeIndex: [
        {
          type: Input,
        },
      ],
      steps: [
        {
          type: Input,
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(StepperModule, {
      declarations: function () {
        return [StepperComponent];
      },
      imports: function () {
        return [CommonModule, RouterModule, IconModule];
      },
      exports: function () {
        return [StepperComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    StepperModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, RouterModule, IconModule],
            exports: [StepperComponent],
            declarations: [StepperComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SubnavComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-subnav",
            template: `
        <ng-content></ng-content>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-subnav"],
        },
      ],
      fixedTop: [
        {
          type: HostBinding,
          args: ["class.hc-subnav-fixed-top"],
        },
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SubnavRightDirective,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcSubnavRight]",
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-subnav-right"],
        },
      ],
    }
  );
})();
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(SubnavModule, {
      declarations: function () {
        return [SubnavComponent, SubnavRightDirective];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [SubnavComponent, SubnavRightDirective];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    SubnavModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [SubnavComponent, SubnavRightDirective],
            declarations: [SubnavComponent, SubnavRightDirective],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcTable,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-table, table[hc-table]",
            exportAs: "matTable",
            template: CDK_TABLE_TEMPLATE,
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [
              ".hc-table{border:1px solid transparent;color:#333;max-width:100%;width:100%}.hc-table td,.hc-table th{background-clip:padding-box;border-bottom:1px solid #c0c5cc;border-top:none;line-height:1.3;padding:8px 16px;position:relative}.hc-table td:focus,.hc-table th:focus{outline:0}.hc-table th{color:#006d9a;font-size:14px;font-weight:600;vertical-align:bottom}.hc-table tbody{border:1px solid #c0c5cc;font-size:15px}.hc-table tbody tr:nth-child(2n){background-color:#fff}.hc-table tbody tr:nth-child(2n+1){background-color:#f9fafb}.hc-table tbody tr:not([disabled]):hover{background-color:#e4e7ea}.hc-table td{vertical-align:top}.hc-table tfoot{font-size:14px;font-weight:600}.hc-table tfoot td{border-bottom:none}.hc-table.hc-table-small td,.hc-table.hc-table-small th{font-size:13px;padding:6px 16px}.hc-table.hc-table-small td.hc-col-sortable-left:after,.hc-table.hc-table-small td.hc-col-sortable:after,.hc-table.hc-table-small th.hc-col-sortable-left:after,.hc-table.hc-table-small th.hc-col-sortable:after{bottom:7px}.hc-table.hc-action-table tbody tr:not([disabled]):hover{background-color:#bfebff;cursor:pointer}.hc-table.hc-action-table tbody tr:not([disabled]).hc-row-selected{background-color:#007bff;color:#fff}.hc-table.hc-action-table tbody tr:not([disabled]).hc-row-selected:hover{background-color:#3395ff}.hc-cell-resizer-left,.hc-cell-resizer-right{cursor:col-resize;display:block;height:100%;position:absolute;top:0;width:10px}.hc-cell-resizer-left.disabled,.hc-cell-resizer-right.disabled{cursor:default}.hc-cell-resizer-left{left:0;margin-left:-1px}.hc-table td:first-of-type .hc-cell-resizer-left,.hc-table th:first-of-type .hc-cell-resizer-left{display:none}.hc-cell-resizer-right{margin-right:-1px;right:0}.hc-table td:last-of-type .hc-cell-resizer-right,.hc-table th:last-of-type .hc-cell-resizer-right{display:none}.hc-row-selected,.hc-table tbody tr.hc-row-selected{background-color:#007bff;color:#fff}.hc-row-selected:hover,.hc-table tbody tr.hc-row-selected:hover{background-color:#3395ff}.hc-row-selected td,.hc-table tbody tr.hc-row-selected td{border-color:#fff}.hc-action-table tbody tr:not([disabled]) .hc-row-selected:hover,.hc-action-table tbody tr:not([disabled]) .hc-table tbody tr.hc-row-selected:hover,.hc-row-selected.hc-action-row:not([disabled]):hover,.hc-table tbody tr.hc-row-selected.hc-action-row:not([disabled]):hover{background-color:#3395ff}.hc-no-hover-table tbody tr .hc-row-selected:hover,.hc-no-hover-table tbody tr .hc-table tbody tr.hc-row-selected:hover{background-color:#007bff}.hc-table tbody tr.hc-action-row:not([disabled]):hover{background-color:#bfebff;cursor:pointer}.hc-table-borders{border:1px solid transparent}.hc-table-borders td,.hc-table-borders th{border:1px solid #c0c5cc}.hc-table-borders .hc-footer-row,.hc-table-borders th{background-color:#f0f3f6}.hc-table-borders tfoot td{border:1px solid #c0c5cc}.hc-table-justify-left{text-align:left}.hc-table-justify-center{text-align:center}.hc-table-justify-right{text-align:right}.hc-table-justify-left .hc-sort-header-container{-webkit-box-pack:left;justify-content:left}.hc-table-justify-center .hc-sort-header-container{-webkit-box-pack:center;justify-content:center}.hc-table-justify-right .hc-sort-header-container{-webkit-box-pack:right;justify-content:right}.hc-table th.hc-col-sortable,.hc-table th.hc-col-sortable-left{background-clip:padding-box;cursor:pointer;padding-right:35px;position:relative}.hc-table th.hc-col-sortable-left:hover,.hc-table th.hc-col-sortable:hover{background-color:#bfebff}.hc-table th.hc-col-sortable-left:after,.hc-table th.hc-col-sortable:after{background-image:url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNzYwLjc4IDE3OTIiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojYTNhNWE3O308L3N0eWxlPjwvZGVmcz48dGl0bGU+QXJ0Ym9hcmQgMTwvdGl0bGU+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNTgyLDEzNDIuODlIODA1Ljc5cTMxLjM0LDAsMzcuMzEsMTYuNDJ0LTE0LjkxLDM3LjNMNDg1LDE3NjkuNjNRNDY0LjA3LDE3OTIsNDMyLjc3LDE3OTJ0LTUyLjIxLTIyLjM3bC0zNDMuMjEtMzczcS0yMC45MS0yMC44OC0xNC45MS0zNy4zdDM3LjMtMTYuNDJIMjgzLjU2VjBINTgyWm03OTguMjYtMTMxOSwzNDMuMiwzNzEuNTVxMjAuODUsMjAuOTEsMTQuOTIsMzYuNTV0LTM3LjMxLDE1LjY2SDE0NzcuMjRWMTc5MC41MkgxMTc4LjgyVjQ0Ny42M0g5NTVxLTMxLjMyLDAtMzcuMy0xNS42NnQxNC45MS0zNi41NWwzNDMuMi0zNzEuNTVRMTI5Ni42NiwxLjUsMTMyOCwxLjQ4VDEzODAuMjQsMjMuODdaIi8+PC9zdmc+);background-position:center center;background-repeat:no-repeat;bottom:10px;content:'';height:13px;margin-left:15px;padding-right:35px;position:absolute;right:1px;width:13px}.hc-table th.hc-col-sortable-left{padding-right:16px;padding-left:35px}.hc-table th.hc-col-sortable-left:after{left:-14px}.hc-table th.hc-active-sort{color:#00a859}.hc-table th.hc-active-sort.hc-sort-asc:after{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxNzYwLjggMTc5MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTc2MC44IDE3OTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMDBBODU5O30KPC9zdHlsZT4KPHRpdGxlPkFydGJvYXJkIDE8L3RpdGxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMCwzNTJjMC04LDMuMy0xNiwxMC0yNEwzMjksOWM2LjItNS44LDE0LjUtOS4xLDIzLTljOCwwLDE1LjcsMywyMyw5bDMyMCwzMjBjMTAsMTAuNywxMi4zLDIyLjMsNywzNQoJYy01LjMsMTMuMy0xNS4zLDIwLTMwLDIwSDQ4MHYxMzc2YzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDlIMjU2Yy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzVjM4NEgzMmMtOS4zLDAtMTctMy0yMy05CglTMCwzNjEuMywwLDM1MnogTTE3NjAuOCwxNTY4djE5MmMwLDkuMy0zLDE3LTksMjNjLTYsNi0xMy43LDktMjMsOWgtODMyYy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzdi0xOTJjMC05LjMsMy0xNyw5LTIzCglzMTMuNy05LDIzLTloODMyYzkuMywwLDE3LDMsMjMsOUMxNzU3LjgsMTU1MSwxNzYwLjgsMTU1OC43LDE3NjAuOCwxNTY4eiBNMTU2OC44LDEwNTZ2MTkyYzAsOS4zLTMsMTctOSwyM2MtNiw2LTEzLjcsOS0yMyw5aC02NDAKCWMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg2NDBjOS4zLDAsMTcsMywyMyw5QzE1NjUuOCwxMDM5LDE1NjguOCwxMDQ2LjcsMTU2OC44LDEwNTZ6CgkgTTEzNzYuOCw1NDR2MTkyYzAsOS4zLTMsMTctOSwyM2MtNiw2LTEzLjcsOS0yMyw5aC00NDhjLTkuMywwLTE3LTMtMjMtOXMtOS0xMy43LTktMjNWNTQ0YzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg0NDgKCWM5LjMsMCwxNywzLDIzLDlDMTM3My44LDUyNywxMzc2LjgsNTM0LjcsMTM3Ni44LDU0NHogTTExODQuOCwzMnYxOTJjMCw5LjMtMywxNy05LDIzcy0xMy43LDktMjMsOWgtMjU2Yy05LjMsMC0xNy0zLTIzLTkKCXMtOS0xMy43LTktMjNWMzJjMC05LjMsMy0xNyw5LTIzczEzLjctOSwyMy05aDI1NmM5LjMsMCwxNywzLDIzLDlTMTE4NC44LDIyLjcsMTE4NC44LDMyeiIvPgo8L3N2Zz4K)}.hc-table th.hc-active-sort.hc-sort-desc:after{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjEuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxNzYwLjggMTc5MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTc2MC44IDE3OTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMDBBODU5O30KPC9zdHlsZT4KPHRpdGxlPkFydGJvYXJkIDE8L3RpdGxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTE4NC44LDE1Njh2MTkyYzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDloLTI1NmMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yMwoJczEzLjctOSwyMy05aDI1NmM5LjMsMCwxNywzLDIzLDlTMTE4NC44LDE1NTguNywxMTg0LjgsMTU2OHogTTcwNC44LDE0NDBjMCw4LTMuMywxNi0xMCwyNGwtMzE5LDMxOWMtNi4yLDUuOC0xNC41LDkuMS0yMyw5CgljLTgsMC0xNS43LTMtMjMtOWwtMzIwLTMyMGMtMTAtMTAuNy0xMi4zLTIyLjMtNy0zNWM1LjMtMTMuMywxNS4zLTIwLDMwLTIwaDE5MlYzMmMwLTkuMywzLTE3LDktMjNzMTMuNy05LDIzLTloMTkyCgljOS4zLDAsMTcsMywyMyw5czksMTMuNyw5LDIzdjEzNzZoMTkyYzkuMywwLDE3LDMsMjMsOVM3MDQuOCwxNDMwLjcsNzA0LjgsMTQ0MHogTTEzNzYuOCwxMDU2djE5MmMwLDkuMy0zLDE3LTksMjNzLTEzLjcsOS0yMyw5CgloLTQ0OGMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM3YtMTkyYzAtOS4zLDMtMTcsOS0yM3MxMy43LTksMjMtOWg0NDhjOS4zLDAsMTcsMywyMyw5UzEzNzYuOCwxMDQ2LjcsMTM3Ni44LDEwNTZ6IE0xNTY4LjgsNTQ0Cgl2MTkyYzAsOS4zLTMsMTctOSwyM3MtMTMuNyw5LTIzLDloLTY0MGMtOS4zLDAtMTctMy0yMy05cy05LTEzLjctOS0yM1Y1NDRjMC05LjMsMy0xNyw5LTIzczEzLjctOSwyMy05aDY0MGM5LjMsMCwxNywzLDIzLDkKCVMxNTY4LjgsNTM0LjcsMTU2OC44LDU0NHogTTE3NjAuOCwzMnYxOTJjMCw5LjMtMywxNy05LDIzcy0xMy43LDktMjMsOWgtODMyYy05LjMsMC0xNy0zLTIzLTlzLTktMTMuNy05LTIzVjMyYzAtOS4zLDMtMTcsOS0yMwoJczEzLjctOSwyMy05aDgzMmM5LjMsMCwxNywzLDIzLDlTMTc2MC44LDIyLjcsMTc2MC44LDMyeiIvPgo8L3N2Zz4K)}.hc-no-hover-table tbody tr:nth-child(2n):hover{background-color:#fff}.hc-no-hover-table tbody tr:nth-child(2n+1):hover{background-color:#f9fafb}.hc-no-hover-table tbody tr.hc-row-selected:hover{background-color:#007bff}hc-table{display:block}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.IterableDiffers },
        { type: ɵngcc0.ChangeDetectorRef },
        { type: ɵngcc0.ElementRef },
        { type: ɵngcc9.Platform },
        {
          type: String,
          decorators: [
            {
              type: Attribute,
              args: ["role"],
            },
          ],
        },
        {
          type: ɵngcc4.Directionality,
          decorators: [
            {
              type: Optional,
            },
          ],
        },
      ];
    },
    {
      _hostHcTableClass: [
        {
          type: HostBinding,
          args: ["class.hc-table"],
        },
      ],
      _hostHcBordersClass: [
        {
          type: HostBinding,
          args: ["class.hc-table-borders"],
        },
      ],
      _hostHcTableSmall: [
        {
          type: HostBinding,
          args: ["class.hc-table-small"],
        },
      ],
      borders: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
    }
  );
})();
const ɵHcCellDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcCellDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcCellDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcCellDef]",
            providers: [{ provide: CdkCellDef, useExisting: HcCellDef }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcHeaderCellDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcHeaderCellDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcHeaderCellDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcHeaderCellDef]",
            providers: [
              { provide: CdkHeaderCellDef, useExisting: HcHeaderCellDef },
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcFooterCellDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcFooterCellDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFooterCellDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcFooterCellDef]",
            providers: [
              { provide: CdkFooterCellDef, useExisting: HcFooterCellDef },
            ],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcColumnDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcColumnDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcColumnDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcColumnDef]",
            providers: [{ provide: CdkColumnDef, useExisting: HcColumnDef }],
          },
        ],
      },
    ],
    null,
    {
      justify: [
        {
          type: Input,
        },
      ],
      name: [
        {
          type: Input,
          args: ["hcColumnDef"],
        },
      ],
      sticky: [
        {
          type: Input,
        },
      ],
      stickyEnd: [
        {
          type: Input,
        },
      ],
    }
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcHeaderCell,
    [
      {
        type: Directive,
        args: [
          {
            selector: "hc-header-cell, th[hc-header-cell]",
            host: {
              class: "hc-header-cell",
              role: "columnheader",
            },
          },
        ],
      },
    ],
    function () {
      return [{ type: HcColumnDef }, { type: ɵngcc0.ElementRef }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFooterCell,
    [
      {
        type: Directive,
        args: [
          {
            selector: "hc-footer-cell, td[hc-footer-cell]",
            host: {
              class: "hc-footer-cell",
              role: "gridcell",
            },
          },
        ],
      },
    ],
    function () {
      return [{ type: HcColumnDef }, { type: ɵngcc0.ElementRef }];
    },
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcCell,
    [
      {
        type: Directive,
        args: [
          {
            selector: "hc-cell, td[hc-cell]",
            host: {
              class: "hc-cell",
              role: "gridcell",
            },
          },
        ],
      },
    ],
    function () {
      return [{ type: HcColumnDef }, { type: ɵngcc0.ElementRef }];
    },
    null
  );
})();
const ɵHcHeaderRowDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcHeaderRowDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcHeaderRowDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcHeaderRowDef]",
            providers: [
              { provide: CdkHeaderRowDef, useExisting: HcHeaderRowDef },
            ],
            inputs: ["columns: hcHeaderRowDef", "sticky: hcHeaderRowDefSticky"],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcFooterRowDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcFooterRowDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFooterRowDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcFooterRowDef]",
            providers: [
              { provide: CdkFooterRowDef, useExisting: HcFooterRowDef },
            ],
            inputs: ["columns: hcFooterRowDef", "sticky: hcFooterRowDefSticky"],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcRowDef_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcRowDef
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcRowDef,
    [
      {
        type: Directive,
        args: [
          {
            selector: "[hcRowDef]",
            providers: [{ provide: CdkRowDef, useExisting: HcRowDef }],
            inputs: ["columns: hcRowDefColumns", "when: hcRowDefWhen"],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcHeaderRow_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcHeaderRow
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcHeaderRow,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-header-row, tr[hc-header-row]",
            template: CDK_ROW_TEMPLATE,
            host: {
              class: "hc-header-row",
              role: "row",
            },
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            exportAs: "hcHeaderRow",
            providers: [{ provide: CdkHeaderRow, useExisting: HcHeaderRow }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcFooterRow_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(
  HcFooterRow
);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcFooterRow,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-footer-row, tr[hc-footer-row]",
            template: CDK_ROW_TEMPLATE,
            host: {
              class: "hc-footer-row",
              role: "row",
            },
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            exportAs: "hcFooterRow",
            providers: [{ provide: CdkFooterRow, useExisting: HcFooterRow }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
const ɵHcRow_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(HcRow);
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcRow,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-row, tr[hc-row]",
            template: CDK_ROW_TEMPLATE,
            host: {
              class: "hc-row",
              role: "row",
            },
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
            exportAs: "hcRow",
            providers: [{ provide: CdkRow, useExisting: HcRow }],
          },
        ],
      },
    ],
    null,
    null
  );
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcCellResizer,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-cell-resizer",
            template:
              '<div class="hc-cell-resizer-left"></div><div class="hc-cell-resizer-right"></div>',
            changeDetection: ChangeDetectionStrategy.OnPush,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      disabled: [
        {
          type: HostBinding,
          args: ["class.disabled"],
        },
        {
          type: Input,
        },
      ],
      resized: [
        {
          type: Output,
        },
      ],
      resizing: [
        {
          type: Output,
        },
      ],
      width: [
        {
          type: Input,
        },
      ],
      // isResizing can be set to true only when the component is not disabled
      /**
       * @param {?} event
       * @return {?}
       */
      _startResizing: [
        {
          type: HostListener,
          args: ["mousedown", ["$event"]],
        },
      ],
    }
  );
})();

if (false) {
  /**
   * Sets whether the resizer is active or not
   * @type {?}
   */
  HcCellResizer.prototype.disabled;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype._width;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype._directionModifier;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype._mouseX;
  /**
   * Emits a `CellResizeEvent` when a cell has been resized
   * @type {?}
   */
  HcCellResizer.prototype.resized;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype.isResizing;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype.isResizing$;
  /**
   * Emits a boolean value of true while a cell is being resized
   * @type {?}
   */
  HcCellResizer.prototype.resizing;
  /**
   * @type {?}
   * @private
   */
  HcCellResizer.prototype.dragSubscription;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/table.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EXPORTED_DECLARATIONS = [
  // HcTable
  HcTable,
  // Template defs
  HcHeaderCellDef,
  HcHeaderRowDef,
  HcColumnDef,
  HcCellDef,
  HcRowDef,
  HcFooterCellDef,
  HcFooterRowDef,
  // Cell directives
  HcHeaderCell,
  HcCell,
  HcFooterCell,
  // Row directions
  HcHeaderRow,
  HcRow,
  HcFooterRow,
  // Cell resizer
  HcCellResizer,
];
class TableModule {}
TableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TableModule });
TableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function TableModule_Factory(t) {
    return new (t || TableModule)();
  },
  imports: [[CdkTableModule, CommonModule]],
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(TableModule, {
      declarations: function () {
        return [
          HcTable,
          HcHeaderCellDef,
          HcHeaderRowDef,
          HcColumnDef,
          HcCellDef,
          HcRowDef,
          HcFooterCellDef,
          HcFooterRowDef,
          HcHeaderCell,
          HcCell,
          HcFooterCell,
          HcHeaderRow,
          HcRow,
          HcFooterRow,
          HcCellResizer,
        ];
      },
      imports: function () {
        return [CdkTableModule, CommonModule];
      },
      exports: function () {
        return [
          HcTable,
          HcHeaderCellDef,
          HcHeaderRowDef,
          HcColumnDef,
          HcCellDef,
          HcRowDef,
          HcFooterCellDef,
          HcFooterRowDef,
          HcHeaderCell,
          HcCell,
          HcFooterCell,
          HcHeaderRow,
          HcRow,
          HcFooterRow,
          HcCellResizer,
        ];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TableModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CdkTableModule, CommonModule],
            exports: EXPORTED_DECLARATIONS,
            declarations: EXPORTED_DECLARATIONS,
          },
        ],
      },
    ],
    null,
    null
  );
})();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/table-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
 * flaky browser support and the value not being defined in Closure's typings.
 * @type {?}
 */
const MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Use to see what kind of pager we have
 * @param {?} pager
 * @return {?}
 */
function _isLoadMorePaginator(pager) {
  /** @type {?} */
  const loadMorePager = /** @type {?} */ (pager);
  return loadMorePager && loadMorePager.buttonText !== undefined;
}
/**
 * Data source that accepts a client-side data array and includes native support of filtering,
 * sorting (using HcSort), and pagination (using MatPaginator).
 *
 * Allows for sort customization by overriding sortingDataAccessor, which defines how data
 * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,
 * which defines how row data is converted to a string for filter matching.
 * @template T
 */
class HcTableDataSource extends DataSource {
  /**
   * @param {?=} initialData
   */
  constructor(initialData = []) {
    super();
    /**
     * Stream emitting render data to the table (depends on ordered data changes).
     */
    this._renderData = new BehaviorSubject([]);
    /**
     * Stream that emits when a new filter string is set on the data source.
     */
    this._filter = new BehaviorSubject("");
    /**
     * Subscription to the changes that should trigger an update to the table's rendered rows, such
     * as filtering, sorting, pagination, or base data changes.
     */
    this._renderChangesSubscription = Subscription.EMPTY;
    /**
     * Data accessor function that is used for accessing data properties for sorting through
     * the default sortData function.
     * This default function assumes that the sort header IDs (which defaults to the column name)
     * matches the data's properties (e.g. column Xyz represents data['Xyz']).
     * Converts strings to lowercase characters
     * May be set to a custom function for different behavior.
     * @param data Data object that is being accessed.
     * @param sortHeaderId The name of the column that represents the data.
     */
    this.sortingDataAccessor =
      /**
       * @param {?} data
       * @param {?} sortHeaderId
       * @return {?}
       */
      (data, sortHeaderId) => {
        /** @type {?} */
        const value = data[sortHeaderId];
        if (_isNumberValue(value)) {
          /** @type {?} */
          const numberValue = Number(value);
          // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
          // return them as strings. For more info: https://goo.gl/y5vbSg
          return numberValue < MAX_SAFE_INTEGER ? numberValue : `${value}`;
        }
        // lowercase strings
        if (isString(value)) {
          return value.toLocaleLowerCase();
        }
        // convert null/undefined to an empty string so they sort first
        if (value === null || value === undefined) {
          return "";
        }
        // leave dates or other values as is
        return value;
      };
    // sortingDataAccessor: ((data: T, sortHeaderId: string) => string) = (data: T, sortHeaderId: string): string => {
    //     return `${data[sortHeaderId]}`.toLocaleLowerCase();
    // };
    /**
     * Gets a sorted copy of the data array based on the state of the HcSort. Called
     * after changes are made to the filtered data or when sort changes are emitted from HcSort.
     * By default, the function retrieves the active sort and its direction and compares data
     * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
     * of data ordering.
     * @param data The array of data that should be sorted.
     * @param sort The connected HcSort that holds the current sort state.
     */
    this.sortData =
      /**
       * @param {?} data
       * @param {?} sort
       * @return {?}
       */
      (data, sort) => {
        /** @type {?} */
        const active = sort.active;
        /** @type {?} */
        const direction = sort.direction;
        if (!active || direction === "") {
          return data;
        }
        return data.sort(
          /**
           * @param {?} a
           * @param {?} b
           * @return {?}
           */
          (a, b) => {
            /** @type {?} */
            let valueA = this.sortingDataAccessor(a, active);
            /** @type {?} */
            let valueB = this.sortingDataAccessor(b, active);
            // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if
            // one value exists while the other doesn't. In this case, existing value should come first.
            // This avoids inconsistent results when comparing values to undefined/null.
            // If neither value exists, return 0 (equal).
            /** @type {?} */
            let comparatorResult = 0;
            if (valueA != null && valueB != null) {
              // Check if one value is greater than the other; if equal, comparatorResult should remain 0.
              if (valueA > valueB) {
                comparatorResult = 1;
              } else if (valueA < valueB) {
                comparatorResult = -1;
              }
            } else if (valueA != null) {
              comparatorResult = 1;
            } else if (valueB != null) {
              comparatorResult = -1;
            }
            return comparatorResult * (direction === "asc" ? 1 : -1);
          }
        );
      };
    /**
     * Checks if a data object matches the data source's filter string. By default, each data object
     * is converted to a string of its properties and returns true if the filter has
     * at least one occurrence in that string. By default, the filter string has its whitespace
     * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
     * filter matching.
     * @param data Data object used to check against the filter.
     * @param filter Filter string that has been set on the data source.
     * @return Whether the filter matches against the data
     */
    this.filterPredicate =
      /**
       * @param {?} data
       * @param {?} filter
       * @return {?}
       */
      (data, filter) => {
        // Transform the data into a lowercase string of all property values.
        /** @type {?} */
        const accumulator =
          /**
           * @param {?} currentTerm
           * @param {?} key
           * @return {?}
           */
          (currentTerm, key) => currentTerm + data[key];
        /** @type {?} */
        const dataStr = Object.keys(data).reduce(accumulator, "").toLowerCase();
        // Transform the filter by converting it to lowercase and removing whitespace.
        /** @type {?} */
        const transformedFilter = filter.trim().toLowerCase();
        return dataStr.indexOf(transformedFilter) !== -1;
      };
    this._data = new BehaviorSubject(initialData);
    this._updateChangeSubscription();
  }
  /**
   * Array of data that should be rendered by the table, where each object represents one row.
   * @return {?}
   */
  get data() {
    return this._data.value;
  }
  /**
   * @param {?} data
   * @return {?}
   */
  set data(data) {
    this._data.next(data);
  }
  /**
   * Filter term that should be used to filter out objects from the data array. To override how
   * data objects match to this filter string, provide a custom function for filterPredicate.
   * @return {?}
   */
  get filter() {
    return this._filter.value;
  }
  /**
   * @param {?} filter
   * @return {?}
   */
  set filter(filter) {
    this._filter.next(filter);
  }
  /**
   * Instance of the HcSort directive used by the table to control its sorting. Sort changes
   * emitted by the HcSort will trigger an update to the table's rendered data.
   * @return {?}
   */
  get sort() {
    return this._sort;
  }
  /**
   * @param {?} sort
   * @return {?}
   */
  set sort(sort) {
    this._sort = sort;
    this._updateChangeSubscription();
  }
  /**
   * Instance of the PaginationComponentused by the table to control what page of the data is
   * displayed. Page changes emitted by the hc-pagination will trigger an update to the
   * table's rendered data.
   *
   * Note that the data source uses the paginator's properties to calculate which page of data
   * should be displayed. If the paginator receives its properties as template inputs,
   * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
   * initialized before assigning it to this data source.
   * @return {?}
   */
  get paginator() {
    return this._paginator;
  }
  /**
   * @param {?} paginator
   * @return {?}
   */
  set paginator(paginator) {
    this._paginator = paginator;
    this._updateChangeSubscription();
  }
  /**
   * Subscribe to changes that should trigger an update to the table's rendered rows. When the
   * changes occur, process the current state of the filter, sort, and pagination along with
   * the provided base data and send it to the table for rendering.
   * @return {?}
   */
  _updateChangeSubscription() {
    // Sorting and/or pagination should be watched if HcSort and/or MatPaginator are provided.
    // The events should emit whenever the component emits a change or initializes, or if no
    // component is provided, a stream with just a null event should be provided.
    // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
    // pipeline can progress to the next step. Note that the value from these streams are not used,
    // they purely act as a signal to progress in the pipeline.
    /** @type {?} */
    const sortChange = this._sort
      ? merge(this._sort.sortChange, this._sort.initialized)
      : of(null);
    /** @type {?} */
    const pageChange = this._paginator
      ? merge(this._paginator.page, this._paginator.initialized)
      : of(null);
    /** @type {?} */
    const dataStream = this._data;
    // Watch for base data or filter changes to provide a filtered set of data.
    /** @type {?} */
    const filteredData = combineLatest(dataStream, this._filter).pipe(
      map(
        /**
         * @param {?} __0
         * @return {?}
         */
        ([data]) => this._filterData(data)
      )
    );
    // Watch for filtered data or sort changes to provide an ordered set of data.
    /** @type {?} */
    const orderedData = combineLatest(filteredData, sortChange).pipe(
      map(
        /**
         * @param {?} __0
         * @return {?}
         */
        ([data]) => this._orderData(data)
      )
    );
    // Watch for ordered data or page changes to provide a paged set of data.
    /** @type {?} */
    const paginatedData = combineLatest(orderedData, pageChange).pipe(
      map(
        /**
         * @param {?} __0
         * @return {?}
         */
        ([data]) => this._pageData(data)
      )
    );
    // Watched for paged data changes and send the result to the table to render.
    this._renderChangesSubscription.unsubscribe();
    this._renderChangesSubscription = paginatedData.subscribe(
      /**
       * @param {?} data
       * @return {?}
       */
      (data) => this._renderData.next(data)
    );
  }
  /**
   * Returns a filtered data array where each filter object contains the filter string within
   * the result of the filterTermAccessor function. If no filter is set, returns the data array
   * as provided.
   * @param {?} data
   * @return {?}
   */
  _filterData(data) {
    // If there is a filter string, filter out data that does not contain it.
    // Each data object is converted to a string using the function defined by filterTermAccessor.
    // May be overridden for customization.
    this.filteredData = !this.filter
      ? data
      : data.filter(
          /**
           * @param {?} obj
           * @return {?}
           */
          (obj) => this.filterPredicate(obj, this.filter)
        );
    if (this.paginator) {
      this._updatePaginator(this.filteredData.length);
    }
    return this.filteredData;
  }
  /**
   * Returns a sorted copy of the data if HcSort has a sort applied, otherwise just returns the
   * data array as provided. Uses the default data accessor for data lookup, unless a
   * sortDataAccessor function is defined.
   * @param {?} data
   * @return {?}
   */
  _orderData(data) {
    // If there is no active sort or direction, return the data without trying to sort.
    if (!this.sort) {
      return data;
    }
    return this.sortData(data.slice(), this.sort);
  }
  /**
   * Returns a paged splice of the provided data array according to the provided MatPaginator's page
   * index and length. If there is no paginator provided, returns the data array as provided.
   * @param {?} data
   * @return {?}
   */
  _pageData(data) {
    /** @type {?} */
    const pager = this.paginator;
    if (!pager) {
      return data;
    }
    /** @type {?} */
    const startIndex = _isLoadMorePaginator(pager)
      ? 0
      : (pager.pageNumber - 1) * pager.pageSize;
    /** @type {?} */
    const numElsToGrab = _isLoadMorePaginator(pager)
      ? pager.pageNumber * pager.pageSize
      : pager.pageSize;
    return data.slice().splice(startIndex, numElsToGrab);
  }
  /**
   * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
   * index does not exceed the paginator's last page. Values are changed in a resolved promise to
   * guard against making property changes within a round of change detection.
   * @param {?} filteredDataLength
   * @return {?}
   */
  _updatePaginator(filteredDataLength) {
    Promise.resolve().then(
      /**
       * @return {?}
       */
      () => {
        if (!this.paginator) {
          return;
        }
        this.paginator.length = filteredDataLength;
        // If the page index is set beyond the page, reduce it to the last page.
        if (this.paginator.pageNumber > 0) {
          /** @type {?} */
          const lastPageIndex =
            Math.ceil(this.paginator.length / this.paginator.pageSize) || 1;
          this.paginator.pageNumber = Math.min(
            this.paginator.pageNumber,
            lastPageIndex
          );
        }
      }
    );
  }
  /**
   * Used by the HcTable. Called when it connects to the data source.
   * \@docs-private
   * @return {?}
   */
  connect() {
    return this._renderData;
  }
  /**
   * Used by the HcTable. Called when it is destroyed. No-op.
   * \@docs-private
   * @return {?}
   */
  disconnect() {}
}
if (false) {
  /**
   * Stream that emits when a new data array is set on the data source.
   * @type {?}
   * @private
   */
  HcTableDataSource.prototype._data;
  /**
   * Stream emitting render data to the table (depends on ordered data changes).
   * @type {?}
   * @private
   */
  HcTableDataSource.prototype._renderData;
  /**
   * Stream that emits when a new filter string is set on the data source.
   * @type {?}
   * @private
   */
  HcTableDataSource.prototype._filter;
  /**
   * Subscription to the changes that should trigger an update to the table's rendered rows, such
   * as filtering, sorting, pagination, or base data changes.
   * @type {?}
   */
  HcTableDataSource.prototype._renderChangesSubscription;
  /**
   * The filtered set of data that has been matched by the filter string, or all the data if there
   * is no filter. Useful for knowing the set of data the table represents.
   * For example, a 'selectAll()' function would likely want to select the set of filtered data
   * shown to the user rather than all the data.
   * @type {?}
   */
  HcTableDataSource.prototype.filteredData;
  /**
   * @type {?}
   * @private
   */
  HcTableDataSource.prototype._sort;
  /**
   * @type {?}
   * @private
   */
  HcTableDataSource.prototype._paginator;
  /**
   * Data accessor function that is used for accessing data properties for sorting through
   * the default sortData function.
   * This default function assumes that the sort header IDs (which defaults to the column name)
   * matches the data's properties (e.g. column Xyz represents data['Xyz']).
   * Converts strings to lowercase characters
   * May be set to a custom function for different behavior.
   * \@param data Data object that is being accessed.
   * \@param sortHeaderId The name of the column that represents the data.
   * @type {?}
   */
  HcTableDataSource.prototype.sortingDataAccessor;
  /**
   * Gets a sorted copy of the data array based on the state of the HcSort. Called
   * after changes are made to the filtered data or when sort changes are emitted from HcSort.
   * By default, the function retrieves the active sort and its direction and compares data
   * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
   * of data ordering.
   * \@param data The array of data that should be sorted.
   * \@param sort The connected HcSort that holds the current sort state.
   * @type {?}
   */
  HcTableDataSource.prototype.sortData;
  /**
   * Checks if a data object matches the data source's filter string. By default, each data object
   * is converted to a string of its properties and returns true if the filter has
   * at least one occurrence in that string. By default, the filter string has its whitespace
   * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
   * filter matching.
   * \@param data Data object used to check against the filter.
   * \@param filter Filter string that has been set on the data source.
   * \@return Whether the filter matches against the data
   * @type {?}
   */
  HcTableDataSource.prototype.filterPredicate;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/table/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/tab/tab-title.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Contains the HTML markup for tab titles
 */
class HcTabTitleComponent {}
HcTabTitleComponent.ɵfac = function HcTabTitleComponent_Factory(t) {
  return new (t || HcTabTitleComponent)();
};
HcTabTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcTabTitleComponent,
  selectors: [["hc-tab-title"]],
  viewQuery: function HcTabTitleComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c72, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.tabTitle = _t.first);
    }
  },
  ngContentSelectors: _c3,
  decls: 2,
  vars: 0,
  consts: [["tabTitle", ""]],
  template: function HcTabTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(
        0,
        HcTabTitleComponent_ng_template_0_Template,
        1,
        0,
        "ng-template",
        null,
        0,
        ɵngcc0.ɵɵtemplateRefExtractor
      );
    }
  },
  encapsulation: 2,
});
HcTabTitleComponent.propDecorators = {
  tabTitle: [{ type: ViewChild, args: ["tabTitle", { static: false }] }],
};
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcTabTitleComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-tab-title",
            template:
              "<ng-template #tabTitle><ng-content></ng-content></ng-template>",
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    null,
    {
      tabTitle: [
        {
          type: ViewChild,
          args: ["tabTitle", { static: false }],
        },
      ],
    }
  );
})();
if (false) {
  /** @type {?} */
  HcTabTitleComponent.prototype.tabTitle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/tab/tab.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabComponent {
  constructor() {
    /**
     * Plain text title of the tab; for HTML support include a `hc-tab-title` element
     */
    this.tabTitle = "";
    /**
     * Emits when this tab is selected; use instead of `(click)` for click binding
     */
    this.tabClick = new EventEmitter();
    this._hostIndex = 0;
    this._active = false;
    this._tight = false;
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    if (this._tabTitle) {
      this._htmlTitle = this._tabTitle.first;
    }
  }
  /**
   * @param {?} $event
   * @return {?}
   */
  _onEnter($event) {
    this.tabClickHandler($event);
  }
  /**
   * @param {?} event
   * @return {?}
   */
  tabClickHandler(event) {
    // Prevent a tab anchor click from also calling the router on the host element
    event.preventDefault();
    event.stopPropagation();
    this.tabClick.emit();
  }
}
TabComponent.ɵfac = function TabComponent_Factory(t) {
  return new (t || TabComponent)();
};
TabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: TabComponent,
  selectors: [["hc-tab"]],
  contentQueries: function TabComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, HcTabTitleComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx._tabTitle = _t);
    }
  },
  viewQuery: function TabComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵviewQuery(_c73, true);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) &&
        (ctx.tabContent = _t.first);
    }
  },
  hostAttrs: [1, "hc-tab"],
  hostVars: 1,
  hostBindings: function TabComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵlistener(
        "keydown.enter",
        function TabComponent_keydown_enter_HostBindingHandler($event) {
          return ctx._onEnter($event);
        }
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵattribute("tabindex", ctx._hostIndex);
    }
  },
  inputs: {
    tabTitle: "tabTitle",
    routerLink: "routerLink",
    queryParams: "queryParams",
    exactRouteMatch: "exactRouteMatch",
  },
  outputs: { tabClick: "tabClick" },
  ngContentSelectors: _c3,
  decls: 5,
  vars: 1,
  consts: [
    [4, "ngIf"],
    ["tabWithoutRouting", ""],
    ["tabContent", ""],
    [
      "tabIndex",
      "-1",
      "routerLinkActive",
      "active",
      3,
      "class",
      "hc-tab-tight",
      "active",
      "routerLink",
      "queryParams",
      "routerLinkActiveOptions",
      "click",
      4,
      "ngIf",
      "ngIfElse",
    ],
    [
      "tabIndex",
      "-1",
      "routerLinkActive",
      "active",
      3,
      "routerLink",
      "queryParams",
      "routerLinkActiveOptions",
      "click",
    ],
    [3, "ngTemplateOutlet", 4, "ngIf"],
    [3, "ngTemplateOutlet"],
    ["tabIndex", "-1", 3, "click"],
  ],
  template: function TabComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵtemplate(
        0,
        TabComponent_ng_container_0_Template,
        2,
        2,
        "ng-container",
        0
      );
      ɵngcc0.ɵɵtemplate(
        1,
        TabComponent_ng_template_1_Template,
        3,
        9,
        "ng-template",
        null,
        1,
        ɵngcc0.ɵɵtemplateRefExtractor
      );
      ɵngcc0.ɵɵtemplate(
        3,
        TabComponent_ng_template_3_Template,
        1,
        0,
        "ng-template",
        null,
        2,
        ɵngcc0.ɵɵtemplateRefExtractor
      );
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("ngIf", ctx._direction);
    }
  },
  directives: [
    ɵngcc1.NgIf,
    ɵngcc6.RouterLinkWithHref,
    ɵngcc6.RouterLinkActive,
    ɵngcc1.NgTemplateOutlet,
  ],
  styles: [
    ".hc-tab{min-width:0}.hc-tab:focus{outline:0}.hc-tab:focus a{outline:rgba(0,174,255,.4) solid 2px;outline-offset:-2px}.hc-tab a:focus{box-shadow:none;outline:0}.hc-tab-vertical{background-color:#fff;color:#333;display:block;padding:20px;text-decoration:none}.hc-tab-vertical:hover{cursor:pointer}.hc-tab-vertical.active{background-color:#f0f3f6;border-left:8px solid #00aeff;color:#00aeff;font-weight:600;padding-left:12px}.hc-tab-vertical.hc-tab-tight{padding:10px 20px}.hc-tab-horizontal{background-color:inherit;color:#333;display:block;font-size:14px;min-width:100px;padding:10px 20px;text-align:center;text-decoration:none}.hc-tab-horizontal:hover{cursor:pointer}.hc-tab-horizontal.active{border-bottom:4px solid #00aeff;color:#333;font-weight:700}.hc-tab-horizontal.hc-tab-tight{padding:10px}",
  ],
  encapsulation: 2,
});
TabComponent.propDecorators = {
  tabTitle: [{ type: Input }],
  routerLink: [{ type: Input }],
  queryParams: [{ type: Input }],
  exactRouteMatch: [{ type: Input }],
  tabClick: [{ type: Output }],
  _hostIndex: [{ type: HostBinding, args: ["attr.tabindex"] }],
  tabContent: [{ type: ViewChild, args: ["tabContent", { static: false }] }],
  _tabTitle: [{ type: ContentChildren, args: [HcTabTitleComponent] }],
  _onEnter: [{ type: HostListener, args: ["keydown.enter", ["$event"]] }],
};
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TabComponent,
    [
      {
        type: Component,
        args: [
          {
            template:
              '<ng-container *ngIf="_direction">\n    <a\n        tabIndex="-1"\n        *ngIf="routerLink; else tabWithoutRouting"\n        class="hc-tab-{{ _direction }} hc-text-ellipsis"\n        [class.hc-tab-tight]="_tight"\n        [class.active]="_active"\n        [routerLink]="routerLink"\n        routerLinkActive="active"\n        [queryParams]="queryParams"\n        [routerLinkActiveOptions]="exactRouteMatch ? {exact: true} : {}"\n        (click)="tabClickHandler($event)"\n    >\n        <ng-container *ngIf="_htmlTitle" [ngTemplateOutlet]="_htmlTitle.tabTitle"></ng-container>\n        {{ tabTitle }}\n    </a>\n</ng-container>\n<ng-template #tabWithoutRouting>\n    <a\n        tabIndex="-1"\n        class="hc-tab-{{ _direction }} hc-text-ellipsis"\n        [class.hc-tab-tight]="_tight"\n        [class.active]="_active"\n        (click)="tabClickHandler($event)"\n    >\n        <ng-container *ngIf="_htmlTitle" [ngTemplateOutlet]="_htmlTitle.tabTitle"></ng-container>\n        {{ tabTitle }}\n    </a>\n</ng-template>\n<ng-template #tabContent>\n    <ng-content></ng-content>\n</ng-template>\n',
            selector: `hc-tab`,
            // tslint:disable-next-line: no-host-metadata-property
            host: { class: "hc-tab" },
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-tab{min-width:0}.hc-tab:focus{outline:0}.hc-tab:focus a{outline:rgba(0,174,255,.4) solid 2px;outline-offset:-2px}.hc-tab a:focus{box-shadow:none;outline:0}.hc-tab-vertical{background-color:#fff;color:#333;display:block;padding:20px;text-decoration:none}.hc-tab-vertical:hover{cursor:pointer}.hc-tab-vertical.active{background-color:#f0f3f6;border-left:8px solid #00aeff;color:#00aeff;font-weight:600;padding-left:12px}.hc-tab-vertical.hc-tab-tight{padding:10px 20px}.hc-tab-horizontal{background-color:inherit;color:#333;display:block;font-size:14px;min-width:100px;padding:10px 20px;text-align:center;text-decoration:none}.hc-tab-horizontal:hover{cursor:pointer}.hc-tab-horizontal.active{border-bottom:4px solid #00aeff;color:#333;font-weight:700}.hc-tab-horizontal.hc-tab-tight{padding:10px}",
            ],
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      tabTitle: [
        {
          type: Input,
        },
      ],
      tabClick: [
        {
          type: Output,
        },
      ],
      _hostIndex: [
        {
          type: HostBinding,
          args: ["attr.tabindex"],
        },
      ],
      /**
       * @param {?} $event
       * @return {?}
       */
      _onEnter: [
        {
          type: HostListener,
          args: ["keydown.enter", ["$event"]],
        },
      ],
      routerLink: [
        {
          type: Input,
        },
      ],
      queryParams: [
        {
          type: Input,
        },
      ],
      exactRouteMatch: [
        {
          type: Input,
        },
      ],
      tabContent: [
        {
          type: ViewChild,
          args: ["tabContent", { static: false }],
        },
      ],
      _tabTitle: [
        {
          type: ContentChildren,
          args: [HcTabTitleComponent],
        },
      ],
    }
  );
})();
if (false) {
  /**
   * Plain text title of the tab; for HTML support include a `hc-tab-title` element
   * @type {?}
   */
  TabComponent.prototype.tabTitle;
  /**
   * Router path that the tab routes to. If one tab uses the routerLink in a tab set, all must use the router link.
   * Can be specified as '/path/2' or ['path', '2']
   * @type {?}
   */
  TabComponent.prototype.routerLink;
  /**
   * Add queryParams to the routerLink
   * @type {?}
   */
  TabComponent.prototype.queryParams;
  /**
   * If set to true, [routerLinkActiveOptions]="{exact: true}" is added
   * @type {?}
   */
  TabComponent.prototype.exactRouteMatch;
  /**
   * Emits when this tab is selected; use instead of `(click)` for click binding
   * @type {?}
   */
  TabComponent.prototype.tabClick;
  /** @type {?} */
  TabComponent.prototype._hostIndex;
  /**
   * The template to be used when this tab is selected. Defaults to the content of this tab component.
   * Not used when the tab set uses routing.
   * @type {?}
   */
  TabComponent.prototype.tabContent;
  /** @type {?} */
  TabComponent.prototype._direction;
  /** @type {?} */
  TabComponent.prototype._active;
  /** @type {?} */
  TabComponent.prototype._tight;
  /** @type {?} */
  TabComponent.prototype._htmlTitle;
  /** @type {?} */
  TabComponent.prototype._tabTitle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/tab-set/tab-set.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabChangeEvent {
  /**
   * @param {?} index
   * @param {?} tab
   */
  constructor(index, tab) {
    this.index = index;
    this.tab = tab;
  }
}
if (false) {
  /** @type {?} */
  TabChangeEvent.prototype.index;
  /** @type {?} */
  TabChangeEvent.prototype.tab;
}
/**
 * @param {?} tabsWithoutRouterLink
 * @return {?}
 */
function throwErrorForMissingRouterLink$1(tabsWithoutRouterLink) {
  /** @type {?} */
  const tabTitles = tabsWithoutRouterLink.map(
    /**
     * @param {?} tab
     * @return {?}
     */
    (tab) => tab.tabTitle
  );
  throw Error(`Routerlink missing on ${tabTitles.join(",")}`);
}
/** @type {?} */
const supportedDirections = ["horizontal", "vertical"];
/**
 * @param {?} inputStr
 * @return {?}
 */
function validateDirectionInput(inputStr) {
  if (supportedDirections.indexOf(inputStr) < 0) {
    throw Error("Unsupported tab direction value: " + inputStr);
  }
}
/**
 * @return {?}
 */
function tabComponentMissing() {
  return new Error(
    `TabSet must contain at least one TabComponent. Make sure to add a hc-tab to the hc-tab-set element.`
  );
}
/**
 * @param {?} tabVal
 * @return {?}
 */
function invalidDefaultTab(tabVal) {
  throw Error(
    "Invalid default tab value: " +
      tabVal +
      ". Must be 'none' or a value less than the total number of tabs in the set."
  );
}
class TabSetComponent {
  /**
   * @param {?} router
   * @param {?} route
   */
  constructor(router, route) {
    this.router = router;
    this.route = route;
    this._routerEnabled = false;
    this._direction = "vertical";
    this._defaultTab = 0;
    this._stopTabSubscriptionSubject = new Subject();
    /**
     * Emits when the selected tab is changed
     */
    this.selectedTabChange = new EventEmitter();
    this._addContentContainer = true;
    this._tight = false;
  }
  /**
   * Specify direction of tabs as either `horizontal` or `vertical`. Defaults to `vertical`
   * @return {?}
   */
  get direction() {
    return this._direction;
  }
  /**
   * @param {?} directionType
   * @return {?}
   */
  set direction(directionType) {
    validateDirectionInput(directionType);
    this._direction = directionType;
  }
  /**
   * Zero-based numerical value specifying which tab to select by default, setting to `none` means no tab
   * will be immediately selected. Defaults to 0 (the first tab).
   * @return {?}
   */
  get defaultTab() {
    return this._defaultTab;
  }
  /**
   * @param {?} tabValue
   * @return {?}
   */
  set defaultTab(tabValue) {
    if (!isNaN(+tabValue) || tabValue === "none") {
      this._defaultTab = tabValue;
    } else {
      invalidDefaultTab(tabValue);
    }
  }
  /**
   * Determines whether the tab set will create a router-outlet or ng-container for the tab content.
   * If set to false, the app will need to add its own container.  Defaults to `true`.
   * @return {?}
   */
  get addContentContainer() {
    return this._addContentContainer;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set addContentContainer(value) {
    this._addContentContainer = parseBooleanAttribute(value);
  }
  /**
   * If true, condense the default padding on all included tabs. *Defaults to `false`.*
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
    this.setTabDirection();
  }
  /**
   * @return {?}
   */
  ngAfterContentInit() {
    this.setUpTabs();
    this._tabs.changes.subscribe(
      /**
       * @return {?}
       */
      () => this.setUpTabs()
    );
  }
  /**
   * @private
   * @return {?}
   */
  setUpTabs() {
    if (this._tabs.length === 0) {
      throw tabComponentMissing();
    }
    if (this.defaultTab !== "none") {
      this.defaultToFirstTab();
    }
    this.checkForRouterUse();
    this.setTabDirection();
    this.subscribeToTabClicks();
  }
  /**
   * @private
   * @return {?}
   */
  setTabDirection() {
    setTimeout(
      /**
       * @return {?}
       */
      () =>
        this._tabs.forEach(
          /**
           * @param {?} t
           * @return {?}
           */
          (t) => {
            t._direction = this.direction;
            t._tight = this.tight;
          }
        )
    );
  }
  /**
   * @private
   * @return {?}
   */
  subscribeToTabClicks() {
    this._stopTabSubscriptionSubject.next();
    this._tabs.forEach(
      /**
       * @param {?} t
       * @return {?}
       */
      (t) =>
        t.tabClick.pipe(takeUntil(this._stopTabSubscriptionSubject)).subscribe(
          /**
           * @return {?}
           */
          () => this._setActive(t)
        )
    );
  }
  /**
   * Sets the currently selected tab by either its numerical index or `TabComponent` object
   * @param {?} tab
   * @return {?}
   */
  selectTab(tab) {
    /** @type {?} */
    const activeTab = typeof tab === "number" ? this._tabs.toArray()[tab] : tab;
    this._setActive(activeTab);
  }
  /**
   * @param {?} tab
   * @return {?}
   */
  _setActive(tab) {
    /** @type {?} */
    let activeIndex = 0;
    this._tabs.toArray().forEach(
      /**
       * @param {?} t
       * @param {?} index
       * @return {?}
       */
      (t, index) => {
        t._active = false;
        if (t === tab) {
          activeIndex = index;
        }
      }
    );
    tab._active = true;
    this.tabContent = tab.tabContent;
    this.selectedTabChange.emit(new TabChangeEvent(activeIndex, tab));
  }
  /**
   * @private
   * @return {?}
   */
  defaultToFirstTab() {
    if (
      !this._tabs.find(
        /**
         * @param {?} tab
         * @return {?}
         */
        (tab) => tab._active
      )
    ) {
      // setTimeout to avoid change after checked error
      // when ngFor is used as projected nodes are registered
      // and stored as part of the existing view, not
      // the view in which they are projected
      // embedded views are checked *before* AfterContentInit
      // is triggered
      /** @type {?} */
      const tabArray = this._tabs.toArray();
      if (tabArray[Number(this.defaultTab)]) {
        setTimeout(
          /**
           * @return {?}
           */
          () => this._setActive(tabArray[Number(this.defaultTab)])
        );
      } else {
        invalidDefaultTab(this.defaultTab);
      }
    }
  }
  /**
   * @private
   * @return {?}
   */
  checkForRouterUse() {
    /** @type {?} */
    const countUsingRouter = this._tabs.filter(
      /**
       * @param {?} tab
       * @return {?}
       */
      (tab) => tab.routerLink !== undefined
    ).length;
    if (countUsingRouter > 0 && countUsingRouter < this._tabs.length) {
      /** @type {?} */
      const tabsMissingRouterLink = this._tabs.filter(
        /**
         * @param {?} tab
         * @return {?}
         */
        (tab) => tab.routerLink === undefined
      );
      throwErrorForMissingRouterLink$1(tabsMissingRouterLink);
    }
    if (countUsingRouter === this._tabs.length) {
      this._routerEnabled = true;
      if (this._defaultTab !== "none") {
        this.defaultToFirstRoute();
      }
    }
  }
  /**
   * @private
   * @return {?}
   */
  defaultToFirstRoute() {
    /** @type {?} */
    const foundRoute = this._tabs
      .map(
        /**
         * @param {?} tab
         * @return {?}
         */
        (tab) => tab.routerLink
      )
      .map(
        /**
         * @param {?} routerLink
         * @return {?}
         */
        (routerLink) => this.mapRouterLinkToString(routerLink)
      )
      .find(
        /**
         * @param {?} routerLink
         * @return {?}
         */
        (routerLink) => {
          /** @type {?} */
          let currentRoute = this.router.url;
          return (
            currentRoute === routerLink ||
            currentRoute.indexOf(`${routerLink}/`) > -1
          );
        }
      );
    if (foundRoute) {
      return;
    }
    /** @type {?} */
    const tabArray = this._tabs.toArray();
    if (tabArray[Number(this.defaultTab)]) {
      /** @type {?} */
      const firstRoute = this.mapRouterLinkToString(
        tabArray[Number(this.defaultTab)].routerLink
      );
      this.router.navigate([firstRoute], { relativeTo: this.route });
    }
  }
  /**
   * @private
   * @param {?} routerLink
   * @return {?}
   */
  mapRouterLinkToString(routerLink) {
    if (routerLink instanceof Array) {
      routerLink = routerLink.join("/").replace("//", "/");
    }
    return routerLink;
  }
}
TabSetComponent.ɵfac = function TabSetComponent_Factory(t) {
  return new (t || TabSetComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.Router),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc6.ActivatedRoute)
  );
};
TabSetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: TabSetComponent,
  selectors: [["hc-tab-set"]],
  contentQueries: function TabSetComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵngcc0.ɵɵcontentQuery(dirIndex, TabComponent, false);
    }
    if (rf & 2) {
      var _t;
      ɵngcc0.ɵɵqueryRefresh((_t = ɵngcc0.ɵɵloadQuery())) && (ctx._tabs = _t);
    }
  },
  inputs: {
    direction: "direction",
    defaultTab: "defaultTab",
    addContentContainer: "addContentContainer",
    tight: "tight",
  },
  outputs: { selectedTabChange: "selectedTabChange" },
  ngContentSelectors: _c76,
  decls: 5,
  vars: 7,
  consts: [
    [3, "class", 4, "ngIf"],
    [4, "ngIf"],
    [3, "ngTemplateOutlet", 4, "ngIf"],
    [3, "ngTemplateOutlet"],
  ],
  template: function TabSetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef(_c75);
      ɵngcc0.ɵɵelementStart(0, "div");
      ɵngcc0.ɵɵelementStart(1, "div");
      ɵngcc0.ɵɵprojection(2);
      ɵngcc0.ɵɵprojection(3, 1);
      ɵngcc0.ɵɵelementEnd();
      ɵngcc0.ɵɵtemplate(4, TabSetComponent_div_4_Template, 3, 5, "div", 0);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassMapInterpolate1("hc-", ctx.direction, "-tab-container");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵclassMapInterpolate1("hc-tab-bar-", ctx.direction, "");
      ɵngcc0.ɵɵadvance(3);
      ɵngcc0.ɵɵproperty("ngIf", ctx._addContentContainer);
    }
  },
  directives: [ɵngcc1.NgIf, ɵngcc6.RouterOutlet, ɵngcc1.NgTemplateOutlet],
  styles: [
    ".hc-horizontal-tab-container{height:auto;width:100%}.hc-tab-bar-horizontal{-webkit-box-align:baseline;align-items:baseline;background-color:inherit;border-bottom:1px solid #c0c5cc;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.hc-tab-content-horizontal{background-color:inherit;height:100%;overflow:auto;width:100%}.hc-vertical-tab-container{display:-webkit-box;display:flex;height:100%;width:100%}.hc-tab-bar-vertical{background-color:#fff;padding:15px 0;width:20%}.hc-tab-content-vertical{background-color:#f0f3f6;width:80%}",
  ],
  encapsulation: 2,
});
/** @nocollapse */
TabSetComponent.ctorParameters = () => [
  { type: Router },
  { type: ActivatedRoute },
];
TabSetComponent.propDecorators = {
  _tabs: [{ type: ContentChildren, args: [TabComponent] }],
  selectedTabChange: [{ type: Output }],
  direction: [{ type: Input }],
  defaultTab: [{ type: Input }],
  addContentContainer: [{ type: Input }],
  tight: [{ type: Input }],
};
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TabSetComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: `hc-tab-set`,
            template:
              '<div class="hc-{{direction}}-tab-container">\n    <div class="hc-tab-bar-{{direction}}">\n        <ng-content select="hc-tab"></ng-content>\n        <ng-content></ng-content>\n    </div>\n    <div *ngIf="_addContentContainer" class="hc-tab-content-{{direction}}">\n        <router-outlet *ngIf="_routerEnabled"></router-outlet>\n        <ng-container *ngIf="!_routerEnabled" [ngTemplateOutlet]="tabContent"></ng-container>\n    </div>\n</div>\n',
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-horizontal-tab-container{height:auto;width:100%}.hc-tab-bar-horizontal{-webkit-box-align:baseline;align-items:baseline;background-color:inherit;border-bottom:1px solid #c0c5cc;display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row}.hc-tab-content-horizontal{background-color:inherit;height:100%;overflow:auto;width:100%}.hc-vertical-tab-container{display:-webkit-box;display:flex;height:100%;width:100%}.hc-tab-bar-vertical{background-color:#fff;padding:15px 0;width:20%}.hc-tab-content-vertical{background-color:#f0f3f6;width:80%}",
            ],
          },
        ],
      },
    ],
    function () {
      return [{ type: ɵngcc6.Router }, { type: ɵngcc6.ActivatedRoute }];
    },
    {
      selectedTabChange: [
        {
          type: Output,
        },
      ],
      direction: [
        {
          type: Input,
        },
      ],
      defaultTab: [
        {
          type: Input,
        },
      ],
      addContentContainer: [
        {
          type: Input,
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
      _tabs: [
        {
          type: ContentChildren,
          args: [TabComponent],
        },
      ],
    }
  );
})();
if (false) {
  /** @type {?} */
  TabSetComponent.prototype._routerEnabled;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype._direction;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype._defaultTab;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype._stopTabSubscriptionSubject;
  /**
   * The content to be displayed for the currently selected tab.
   * This is read from the tab when it is selected.
   * Not used when this component uses routing.
   * @type {?}
   */
  TabSetComponent.prototype.tabContent;
  /** @type {?} */
  TabSetComponent.prototype._tabs;
  /**
   * Emits when the selected tab is changed
   * @type {?}
   */
  TabSetComponent.prototype.selectedTabChange;
  /** @type {?} */
  TabSetComponent.prototype._addContentContainer;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype._tight;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype.router;
  /**
   * @type {?}
   * @private
   */
  TabSetComponent.prototype.route;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/tabs.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsModule {}
TabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TabsModule });
TabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function TabsModule_Factory(t) {
    return new (t || TabsModule)();
  },
  imports: [[CommonModule, RouterModule]],
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(TabsModule, {
      declarations: function () {
        return [TabComponent, HcTabTitleComponent, TabSetComponent];
      },
      imports: function () {
        return [CommonModule, RouterModule];
      },
      exports: function () {
        return [TabComponent, HcTabTitleComponent, TabSetComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TabsModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, RouterModule],
            declarations: [TabComponent, HcTabTitleComponent, TabSetComponent],
            exports: [TabComponent, HcTabTitleComponent, TabSetComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tabs/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tile/tile.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Container element to help segment content visually against a gray background.
 * The tile will expand to the height and width of the content it contains.
 */
class TileComponent {
  constructor() {
    this._hostClass = true;
    this._tight = false;
  }
  /**
   * If true, compress the default padding in the tile. Defaults to false
   * @return {?}
   */
  get tight() {
    return this._tight;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  set tight(value) {
    this._tight = parseBooleanAttribute(value);
  }
}
TileComponent.ɵfac = function TileComponent_Factory(t) {
  return new (t || TileComponent)();
};
TileComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: TileComponent,
  selectors: [["hc-tile"]],
  hostVars: 4,
  hostBindings: function TileComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵngcc0.ɵɵclassProp("hc-tile", ctx._hostClass)(
        "hc-tile-tight",
        ctx._tight
      );
    }
  },
  inputs: { tight: "tight" },
  ngContentSelectors: _c3,
  decls: 1,
  vars: 0,
  template: function TileComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵprojectionDef();
      ɵngcc0.ɵɵprojection(0);
    }
  },
  encapsulation: 2,
});
/** @nocollapse */
TileComponent.ctorParameters = () => [];
TileComponent.propDecorators = {
  _hostClass: [{ type: HostBinding, args: ["class.hc-tile"] }],
  _tight: [{ type: HostBinding, args: ["class.hc-tile-tight"] }],
  tight: [{ type: Input }],
};
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TileComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-tile",
            template: "<ng-content></ng-content>",
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      _hostClass: [
        {
          type: HostBinding,
          args: ["class.hc-tile"],
        },
      ],
      _tight: [
        {
          type: HostBinding,
          args: ["class.hc-tile-tight"],
        },
      ],
      tight: [
        {
          type: Input,
        },
      ],
    }
  );
})();
if (false) {
  /** @type {?} */
  TileComponent.prototype._hostClass;
  /** @type {?} */
  TileComponent.prototype._tight;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tile/tile.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TileModule {}
TileModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TileModule });
TileModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function TileModule_Factory(t) {
    return new (t || TileModule)();
  },
  imports: [[CommonModule]],
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(TileModule, {
      declarations: function () {
        return [TileComponent];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [TileComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TileModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [TileComponent],
            declarations: [TileComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tile/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/toaster/hc-toast.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ANIMATION_TIMINGS = "400ms cubic-bezier(0.25, 0.8, 0.25, 1)";
class HcToastComponent {
  /**
   * @param {?} _el
   * @param {?} _viewContainerRef
   * @param {?} _changeRef
   */
  constructor(_el, _viewContainerRef, _changeRef) {
    this._el = _el;
    this._viewContainerRef = _viewContainerRef;
    this._changeRef = _changeRef;
    this._styleType = "success";
    this._toastIcon = "fa-check-circle";
    this._animationState = "enter";
    this._animationStateChanged = new EventEmitter();
    this._closeClick = new EventEmitter();
    this._canDismiss = false;
    this._width = 300;
    this._hasProgressBar = false;
    this._progressWidth = "100%";
    this._componentInstance = new BehaviorSubject(null);
  }
  /**
   * @return {?}
   */
  get _widthStr() {
    return this._width ? `${this._width}px` : "auto";
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onAnimationStart(event) {
    this._animationStateChanged.emit(event);
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _onAnimationDone(event) {
    this._animationStateChanged.emit(event);
  }
  /**
   * @return {?}
   */
  _startExitAnimation() {
    this._animationState = "leave";
  }
  /**
   * @param {?} event
   * @return {?}
   */
  _dismissClick(event) {
    this._closeClick.emit(event);
  }
  /**
   * @param {?} ref
   * @return {?}
   */
  _customComponentAttached(ref) {
    if (ref instanceof ComponentRef) {
      this._componentInstance.next(ref.instance);
    }
  }
}
HcToastComponent.ɵfac = function HcToastComponent_Factory(t) {
  return new (t || HcToastComponent)(
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef),
    ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)
  );
};
HcToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: HcToastComponent,
  selectors: [["hc-toaster"]],
  hostAttrs: [1, "hc-toaster"],
  decls: 4,
  vars: 12,
  consts: [
    [3, "ngClass", "click"],
    [4, "ngIf"],
    ["class", "hc-toast-content", 3, "ngClass", 4, "ngIf"],
    ["class", "hc-toast-progress", 3, "ngClass", "ngStyle", 4, "ngIf"],
    [3, "cdkPortalOutlet", "attached"],
    [1, "hc-toast-content", 3, "ngClass"],
    [1, "hc-toast-icon-container"],
    [1, "hc-toast-icon"],
    [1, "hc-toast-header"],
    [1, "hc-toast-body"],
    ["class", "hc-toast-close", 4, "ngIf"],
    [1, "hc-toast-close"],
    [1, "hc-toast-close-icon"],
    [1, "hc-toast-progress", 3, "ngClass", "ngStyle"],
  ],
  template: function HcToastComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelementStart(0, "div", 0);
      ɵngcc0.ɵɵlistener(
        "@fade.start",
        function HcToastComponent_Template_div_animation_fade_start_0_listener(
          $event
        ) {
          return ctx._onAnimationStart($event);
        }
      )(
        "@fade.done",
        function HcToastComponent_Template_div_animation_fade_done_0_listener(
          $event
        ) {
          return ctx._onAnimationDone($event);
        }
      )("click", function HcToastComponent_Template_div_click_0_listener(
        $event
      ) {
        return ctx._dismissClick($event);
      });
      ɵngcc0.ɵɵtemplate(1, HcToastComponent_div_1_Template, 2, 1, "div", 1);
      ɵngcc0.ɵɵtemplate(2, HcToastComponent_div_2_Template, 9, 6, "div", 2);
      ɵngcc0.ɵɵtemplate(3, HcToastComponent_div_3_Template, 1, 6, "div", 3);
      ɵngcc0.ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵngcc0.ɵɵclassMapInterpolate1("hc-toast hc-toast-", ctx._styleType, "");
      ɵngcc0.ɵɵstyleProp("width", ctx._widthStr);
      ɵngcc0.ɵɵproperty("@fade", ctx._animationState)(
        "ngClass",
        ɵngcc0.ɵɵpureFunction1(10, _c80, ctx._canDismiss)
      );
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._styleType === "custom");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._styleType !== "custom");
      ɵngcc0.ɵɵadvance(1);
      ɵngcc0.ɵɵproperty("ngIf", ctx._hasProgressBar);
    }
  },
  directives: [
    ɵngcc1.NgClass,
    ɵngcc1.NgIf,
    ɵngcc8.CdkPortalOutlet,
    ɵngcc1.NgStyle,
  ],
  styles: [
    ".hc-toaster{width:100%}.hc-toast{box-sizing:border-box;margin:10px 0;border-radius:5px;display:block;box-shadow:0 2px 5px rgba(0,0,0,.2);min-width:300px;position:relative}.hc-toast-dismiss{cursor:pointer;pointer-events:all}.hc-toast-success{background-color:#00a859}.hc-toast-success.hc-toast-dismiss:hover{background-color:#009951}.hc-toast-success .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0ibm91bl9DaGVja2JveF8xMDU1NzI1X0ZGRkZGRiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYgLTk1OC4zNjIpIj4KICAgIDxwYXRoIGlkPSJQYXRoXzUwNyIgZGF0YS1uYW1lPSJQYXRoIDUwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTUuOTY0LDk1OC4zNjJhNTAsNTAsMCwxLDAsNTAuMDM2LDUwQTUwLDUwLDAsMCwwLDU1Ljk2NCw5NTguMzYyWm0yMC45NTIsMjIuNTg0YTIuMywyLjMsMCwwLDEsMS44NDcuNjc1bDguNDE2LDguNzM2YTIuMzYsMi4zNiwwLDAsMSwwLDMuMTZsLTMxLjMyMSwzMi42Ny0xLjQ5MSwxLjU2M0w0Ny4zLDEwMzUuMWEyLjM2NiwyLjM2NiwwLDAsMS0zLjI2NywwbC04LjQxNi04Ljc3Mi0xMC44MzEtMTEuMjkzYTIuMzU5LDIuMzU5LDAsMCwxLDAtMy4xNmw4LjU1OC04LjkxM2EyLjM2NiwyLjM2NiwwLDAsMSwzLjI2NywwbDkuMiw5LjU4OEw3NS41LDk4MS42MjFhMi4yOCwyLjI4LDAsMCwxLDEuNDItLjY3NVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz4KICA8L2c+Cjwvc3ZnPgo=)}.hc-toast-info{background-color:#00aeff}.hc-toast-info.hc-toast-dismiss:hover{background-color:#00a4f0}.hc-toast-info .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fSW5mb18yMjMzNzBfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0xNy4yNjksMTcuMjY5YTUwLDUwLDAsMSwwLDcwLjcxMiwwQTUwLDUwLDAsMCwwLDE3LjI2OSwxNy4yNjlaTTU0LjYzLDIzLjZhNy43MDUsNy43MDUsMCwwLDEsMCwxNS40MDksNy43Nyw3Ljc3LDAsMCwxLTcuNy03LjgxQTcuNjU4LDcuNjU4LDAsMCwxLDU0LjYzLDIzLjZaTTY1LjUsNzUuMjExQTUuMDQ5LDUuMDQ5LDAsMCwxLDY0LjQ0Niw3N2ExMy43NiwxMy43NiwwLDAsMS0xMC4xMzIsNC41MzgsMzMuMTU4LDMzLjE1OCwwLDAsMS01LjU5NC0uMzE3QzQ1LjY1OSw4MC44LDQxLjc1NCw3Nyw0Mi4yODIsNzIuOTk0bDEuMjY2LTguMjMyYy44NDQtNC43NDksMS42ODktOS42LDIuNTMzLTE0LjM1NCwwLS4zMTcuMTA2LS42MzMuMTA2LS45NSwwLTIuMDA1LS42MzMtMi43NDQtMi42MzktMi45NTVhMjEuMTMyLDIxLjEzMiwwLDAsMS0yLjUzMy0uNDIyLDEuODU3LDEuODU3LDAsMCwxLTEuMzcyLTEuOWMuMTA2LS44NDQuNjMzLTEuMzcyLDEuNjg5LTEuNTgzYTkuNjU3LDkuNjU3LDAsMCwxLDEuNzk0LS4xMDZINTcuNjkxYzEuNzk0LDAsMi44NS44NDQsMi44NSwyLjYzOWEyMS4xODUsMjEuMTg1LDAsMCwxLS41MjgsNC40MzNjLS45NSw1LjQ4OC0yLjAwNSwxMC44NzEtMi45NTUsMTYuMzU5LS4zMTcsMS43OTQtLjczOSwzLjU4OC0uOTUsNS4zODNhNy40NTksNy40NTksMCwwLDAsLjIxMSwyLjYzOSwyLjA5MSwyLjA5MSwwLDAsMCwyLjMyMiwxLjY4OSw5Ljc1MSw5Ljc1MSwwLDAsMCwyLjg1LS44NDRBMTkuNjc5LDE5LjY3OSwwLDAsMSw2My42LDczLjczM0M2NC44NjgsNzMuMzExLDY1LjgxOCw3NC4wNSw2NS41LDc1LjIxMVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjYyNSAtMi42MjUpIi8+CiAgPC9nPgo8L3N2Zz4K)}.hc-toast-warning{background-color:#f8961d}.hc-toast-warning.hc-toast-dismiss:hover{background-color:#f48a08}.hc-toast-warning .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fQ2F1dGlvbl80NDU2NjJfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDIuNTUsODEuMzIsNjUuNDM5LDE3LjAzOWMtNS43NC05Ljk0NC0xNS4xMzQtOS45NDQtMjAuODc0LDBMNy40NSw4MS4zMkMxLjcxLDkxLjI2NCw2LjQwNyw5OS40LDE3Ljg4OSw5OS40SDkyLjExMUMxMDMuNTkzLDk5LjQsMTA4LjI5Miw5MS4yNjQsMTAyLjU1LDgxLjMyWk00OS40NDQsMzcuMjY5YTUuNTU2LDUuNTU2LDAsMCwxLDExLjExMSwwVjYyLjE0YTUuNTU2LDUuNTU2LDAsMSwxLTExLjExMSwwWk01NSw4Ny44MjRBNi43MjEsNi43MjEsMCwxLDEsNjEuNzIxLDgxLjEsNi43Myw2LjczLDAsMCwxLDU1LDg3LjgyNFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01IC00LjU4MSkiLz4KICA8L2c+Cjwvc3ZnPgo=)}.hc-toast-alert{background-color:#f13c45}.hc-toast-alert.hc-toast-dismiss:hover{background-color:#ef242e}.hc-toast-alert .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fV2FybmluZ18xODI1NTNfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0tMTIyLjY3MywyMTguN2gtNDEuMzg0TC0xOTMuMywyNDcuOTQzdjQxLjUxNGwyOS4yNDMsMjkuMjQzaDQxLjUxNEwtOTMuMywyODkuNDU3VjI0Ny45NDNMLTEyMi42NzMsMjE4LjdabS0yMi4xOTMsMjEuMDE4YTYuNDg2LDYuNDg2LDAsMCwxLDYuNzg4LDIuNDgsNi43Myw2LjczLDAsMCwxLDEuMTc1LDQuNDM5Yy0uMTMxLDMuMTMzLS4zOTIsNi4yNjYtLjUyMiw5LjUzLS4yNjEsNC45NjEtLjUyMiwxMC4wNTItLjkxNCwxNS4wMTMtLjEzMSwxLjU2Ny0uMTMxLDMuMTMzLS4yNjEsNC43YTQuNzA5LDQuNzA5LDAsMCwxLTQuODMsNC43LDQuODU1LDQuODU1LDAsMCwxLTQuODMtNC41NjljLS4zOTItNy43LS43ODMtMTUuNC0xLjMwNS0yMy4xMDdsLS4zOTItNi4yNjZBNy4wNTMsNy4wNTMsMCwwLDEtMTQ0Ljg2NywyMzkuNzE4Wm0xLjU2Nyw1OC4wOTRhNi40MDcsNi40MDcsMCwwLDEtNi40LTYuNCw2LjQzNiw2LjQzNiwwLDAsMSw2LjUyNy02LjQsNi41Miw2LjUyLDAsMCwxLDYuNCw2LjUyN0E2LjY3OSw2LjY3OSwwLDAsMS0xNDMuMywyOTcuODEyWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTkzLjMgLTIxOC43KSIvPgogIDwvZz4KPC9zdmc+Cg==)}.hc-toast-content{color:#fff;display:-webkit-box;display:flex;align-content:center;padding:15px}.hc-toast-progress-offset{padding-bottom:19px}.hc-toast-icon-container{margin-right:20px;margin-left:5px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-toast-close{padding-left:20px;padding-right:3px;margin-left:auto;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-toast-close-icon{height:16px;width:16px;opacity:.6;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNmZmY7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=)}.hc-toast-header{font-weight:600;font-size:1.28571rem;margin-bottom:4px;word-break:break-word}.hc-toast-body{font-size:1rem;word-break:break-word}.hc-toast-progress{position:absolute;border-bottom-right-radius:4px;border-bottom-left-radius:4px;left:0;bottom:0;height:4px;min-width:100%;background-color:rgba(215,221,228,.2);overflow:hidden;opacity:1}.hc-toast-progress:before{content:' ';display:block;height:4px;width:inherit;background-color:#006d9a}.hc-toast-progress-indeterminate:before{-webkit-animation:2.5s ease-in-out infinite ProgressShift;animation:2.5s ease-in-out infinite ProgressShift}.hc-toast-alert .hc-toast-progress:before{background-color:#e9111c}.hc-toast-warning .hc-toast-progress:before{background-color:#db7c07}.hc-toast-info .hc-toast-progress:before{background-color:#008bcc}.hc-toast-success .hc-toast-progress:before{background-color:#00753e}@-webkit-keyframes ProgressShift{0%{-webkit-transform:translateX(-100%);transform:translateX(-100%)}50%{-webkit-transform:translateX(0);transform:translateX(0)}100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}@keyframes ProgressShift{0%{-webkit-transform:translateX(-100%);transform:translateX(-100%)}50%{-webkit-transform:translateX(0);transform:translateX(0)}100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}",
  ],
  encapsulation: 2,
  data: {
    animation: [
      trigger("fade", [
        state("void", style({ transform: "none", opacity: 0 })),
        state("enter", style({ transform: "none", opacity: 1 })),
        state("leave", style({ transform: "none", opacity: 0 })),
        transition("* => *", animate(ANIMATION_TIMINGS)),
      ]),
    ],
  },
});
/** @nocollapse */
HcToastComponent.ctorParameters = () => [
  { type: ElementRef },
  { type: ViewContainerRef },
  { type: ChangeDetectorRef },
];
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcToastComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-toaster",
            template:
              '<div class="hc-toast hc-toast-{{_styleType}}"\n    [@fade]="_animationState"\n    (@fade.start)="_onAnimationStart($event)"\n    (@fade.done)="_onAnimationDone($event)"\n    (click)="_dismissClick($event)"\n    [style.width]="_widthStr"\n    [ngClass]="{\'hc-toast-dismiss\': _canDismiss}">\n    <div *ngIf="_styleType === \'custom\'">\n        <ng-template (attached)="_customComponentAttached($event)" [cdkPortalOutlet]="_toastPortal"></ng-template>\n    </div>\n    <div *ngIf="_styleType !== \'custom\'" class="hc-toast-content" [ngClass]="{\'hc-toast-progress-offset\': _hasProgressBar}">\n        <div class="hc-toast-icon-container">\n            <div class="hc-toast-icon"></div>\n        </div>\n        <div>\n            <div class="hc-toast-header">{{_headerText}}</div>\n            <div class="hc-toast-body">{{_bodyText}}</div>\n        </div>\n        <div *ngIf="_canDismiss" class="hc-toast-close">\n            <div class="hc-toast-close-icon"></div>\n        </div>\n    </div>\n    <div *ngIf="_hasProgressBar" class="hc-toast-progress"\n        [ngClass]="{\'hc-toast-progress-indeterminate\': !_progressVal}"\n        [ngStyle]="{\'width\': _progressWidth}">\n    </div>\n</div>\n',
            // tslint:disable-next-line: no-host-metadata-property
            host: { class: "hc-toaster" },
            animations: [
              trigger("fade", [
                state("void", style({ transform: "none", opacity: 0 })),
                state("enter", style({ transform: "none", opacity: 1 })),
                state("leave", style({ transform: "none", opacity: 0 })),
                transition("* => *", animate(ANIMATION_TIMINGS)),
              ]),
            ],
            encapsulation: ViewEncapsulation.None,
            styles: [
              ".hc-toaster{width:100%}.hc-toast{box-sizing:border-box;margin:10px 0;border-radius:5px;display:block;box-shadow:0 2px 5px rgba(0,0,0,.2);min-width:300px;position:relative}.hc-toast-dismiss{cursor:pointer;pointer-events:all}.hc-toast-success{background-color:#00a859}.hc-toast-success.hc-toast-dismiss:hover{background-color:#009951}.hc-toast-success .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8ZGVmcz4KICAgIDxzdHlsZT4KICAgICAgLmNscy0xIHsKICAgICAgICBmaWxsOiAjZmZmOwogICAgICB9CiAgICA8L3N0eWxlPgogIDwvZGVmcz4KICA8ZyBpZD0ibm91bl9DaGVja2JveF8xMDU1NzI1X0ZGRkZGRiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYgLTk1OC4zNjIpIj4KICAgIDxwYXRoIGlkPSJQYXRoXzUwNyIgZGF0YS1uYW1lPSJQYXRoIDUwNyIgY2xhc3M9ImNscy0xIiBkPSJNNTUuOTY0LDk1OC4zNjJhNTAsNTAsMCwxLDAsNTAuMDM2LDUwQTUwLDUwLDAsMCwwLDU1Ljk2NCw5NTguMzYyWm0yMC45NTIsMjIuNTg0YTIuMywyLjMsMCwwLDEsMS44NDcuNjc1bDguNDE2LDguNzM2YTIuMzYsMi4zNiwwLDAsMSwwLDMuMTZsLTMxLjMyMSwzMi42Ny0xLjQ5MSwxLjU2M0w0Ny4zLDEwMzUuMWEyLjM2NiwyLjM2NiwwLDAsMS0zLjI2NywwbC04LjQxNi04Ljc3Mi0xMC44MzEtMTEuMjkzYTIuMzU5LDIuMzU5LDAsMCwxLDAtMy4xNmw4LjU1OC04LjkxM2EyLjM2NiwyLjM2NiwwLDAsMSwzLjI2NywwbDkuMiw5LjU4OEw3NS41LDk4MS42MjFhMi4yOCwyLjI4LDAsMCwxLDEuNDItLjY3NVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgMCkiLz4KICA8L2c+Cjwvc3ZnPgo=)}.hc-toast-info{background-color:#00aeff}.hc-toast-info.hc-toast-dismiss:hover{background-color:#00a4f0}.hc-toast-info .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fSW5mb18yMjMzNzBfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0xNy4yNjksMTcuMjY5YTUwLDUwLDAsMSwwLDcwLjcxMiwwQTUwLDUwLDAsMCwwLDE3LjI2OSwxNy4yNjlaTTU0LjYzLDIzLjZhNy43MDUsNy43MDUsMCwwLDEsMCwxNS40MDksNy43Nyw3Ljc3LDAsMCwxLTcuNy03LjgxQTcuNjU4LDcuNjU4LDAsMCwxLDU0LjYzLDIzLjZaTTY1LjUsNzUuMjExQTUuMDQ5LDUuMDQ5LDAsMCwxLDY0LjQ0Niw3N2ExMy43NiwxMy43NiwwLDAsMS0xMC4xMzIsNC41MzgsMzMuMTU4LDMzLjE1OCwwLDAsMS01LjU5NC0uMzE3QzQ1LjY1OSw4MC44LDQxLjc1NCw3Nyw0Mi4yODIsNzIuOTk0bDEuMjY2LTguMjMyYy44NDQtNC43NDksMS42ODktOS42LDIuNTMzLTE0LjM1NCwwLS4zMTcuMTA2LS42MzMuMTA2LS45NSwwLTIuMDA1LS42MzMtMi43NDQtMi42MzktMi45NTVhMjEuMTMyLDIxLjEzMiwwLDAsMS0yLjUzMy0uNDIyLDEuODU3LDEuODU3LDAsMCwxLTEuMzcyLTEuOWMuMTA2LS44NDQuNjMzLTEuMzcyLDEuNjg5LTEuNTgzYTkuNjU3LDkuNjU3LDAsMCwxLDEuNzk0LS4xMDZINTcuNjkxYzEuNzk0LDAsMi44NS44NDQsMi44NSwyLjYzOWEyMS4xODUsMjEuMTg1LDAsMCwxLS41MjgsNC40MzNjLS45NSw1LjQ4OC0yLjAwNSwxMC44NzEtMi45NTUsMTYuMzU5LS4zMTcsMS43OTQtLjczOSwzLjU4OC0uOTUsNS4zODNhNy40NTksNy40NTksMCwwLDAsLjIxMSwyLjYzOSwyLjA5MSwyLjA5MSwwLDAsMCwyLjMyMiwxLjY4OSw5Ljc1MSw5Ljc1MSwwLDAsMCwyLjg1LS44NDRBMTkuNjc5LDE5LjY3OSwwLDAsMSw2My42LDczLjczM0M2NC44NjgsNzMuMzExLDY1LjgxOCw3NC4wNSw2NS41LDc1LjIxMVoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjYyNSAtMi42MjUpIi8+CiAgPC9nPgo8L3N2Zz4K)}.hc-toast-warning{background-color:#f8961d}.hc-toast-warning.hc-toast-dismiss:hover{background-color:#f48a08}.hc-toast-warning .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fQ2F1dGlvbl80NDU2NjJfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0xMDIuNTUsODEuMzIsNjUuNDM5LDE3LjAzOWMtNS43NC05Ljk0NC0xNS4xMzQtOS45NDQtMjAuODc0LDBMNy40NSw4MS4zMkMxLjcxLDkxLjI2NCw2LjQwNyw5OS40LDE3Ljg4OSw5OS40SDkyLjExMUMxMDMuNTkzLDk5LjQsMTA4LjI5Miw5MS4yNjQsMTAyLjU1LDgxLjMyWk00OS40NDQsMzcuMjY5YTUuNTU2LDUuNTU2LDAsMCwxLDExLjExMSwwVjYyLjE0YTUuNTU2LDUuNTU2LDAsMSwxLTExLjExMSwwWk01NSw4Ny44MjRBNi43MjEsNi43MjEsMCwxLDEsNjEuNzIxLDgxLjEsNi43Myw2LjczLDAsMCwxLDU1LDg3LjgyNFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC01IC00LjU4MSkiLz4KICA8L2c+Cjwvc3ZnPgo=)}.hc-toast-alert{background-color:#f13c45}.hc-toast-alert.hc-toast-dismiss:hover{background-color:#ef242e}.hc-toast-alert .hc-toast-icon{width:30px;height:30px;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+CiAgPGRlZnM+CiAgICA8c3R5bGU+CiAgICAgIC5jbHMtMSB7CiAgICAgICAgY2xpcC1wYXRoOiB1cmwoI2NsaXAtQXJ0Ym9hcmRfMSk7CiAgICAgIH0KCiAgICAgIC5jbHMtMiB7CiAgICAgICAgZmlsbDogI2ZmZjsKICAgICAgfQogICAgPC9zdHlsZT4KICAgIDxjbGlwUGF0aCBpZD0iY2xpcC1BcnRib2FyZF8xIj4KICAgICAgPHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgogIDxnIGlkPSJBcnRib2FyZF8xIiBkYXRhLW5hbWU9IkFydGJvYXJkIOKAkyAxIiBjbGFzcz0iY2xzLTEiPgogICAgPHBhdGggaWQ9Im5vdW5fV2FybmluZ18xODI1NTNfRkZGRkZGIiBjbGFzcz0iY2xzLTIiIGQ9Ik0tMTIyLjY3MywyMTguN2gtNDEuMzg0TC0xOTMuMywyNDcuOTQzdjQxLjUxNGwyOS4yNDMsMjkuMjQzaDQxLjUxNEwtOTMuMywyODkuNDU3VjI0Ny45NDNMLTEyMi42NzMsMjE4LjdabS0yMi4xOTMsMjEuMDE4YTYuNDg2LDYuNDg2LDAsMCwxLDYuNzg4LDIuNDgsNi43Myw2LjczLDAsMCwxLDEuMTc1LDQuNDM5Yy0uMTMxLDMuMTMzLS4zOTIsNi4yNjYtLjUyMiw5LjUzLS4yNjEsNC45NjEtLjUyMiwxMC4wNTItLjkxNCwxNS4wMTMtLjEzMSwxLjU2Ny0uMTMxLDMuMTMzLS4yNjEsNC43YTQuNzA5LDQuNzA5LDAsMCwxLTQuODMsNC43LDQuODU1LDQuODU1LDAsMCwxLTQuODMtNC41NjljLS4zOTItNy43LS43ODMtMTUuNC0xLjMwNS0yMy4xMDdsLS4zOTItNi4yNjZBNy4wNTMsNy4wNTMsMCwwLDEtMTQ0Ljg2NywyMzkuNzE4Wm0xLjU2Nyw1OC4wOTRhNi40MDcsNi40MDcsMCwwLDEtNi40LTYuNCw2LjQzNiw2LjQzNiwwLDAsMSw2LjUyNy02LjQsNi41Miw2LjUyLDAsMCwxLDYuNCw2LjUyN0E2LjY3OSw2LjY3OSwwLDAsMS0xNDMuMywyOTcuODEyWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTkzLjMgLTIxOC43KSIvPgogIDwvZz4KPC9zdmc+Cg==)}.hc-toast-content{color:#fff;display:-webkit-box;display:flex;align-content:center;padding:15px}.hc-toast-progress-offset{padding-bottom:19px}.hc-toast-icon-container{margin-right:20px;margin-left:5px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-toast-close{padding-left:20px;padding-right:3px;margin-left:auto;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.hc-toast-close-icon{height:16px;width:16px;opacity:.6;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NjIuOTQ3IDY2Mi45NDciPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNmZmY7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxwYXRoIGlkPSJQYXRoXzc0NCIgZGF0YS1uYW1lPSJQYXRoIDc0NCIgY2xhc3M9ImNscy0xIiBkPSJNMzMxLjQ3NC0xMTkuNDJhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUtMzcuOTQ2TDE1MS43ODYtMzIxLjQyOSwzMTUuODQ5LTQ4NS40OTJhNTQuMTE2LDU0LjExNiwwLDAsMCwxNS42MjUtMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LTM3Ljk0N2wtNzUuODkzLTc1Ljg5M0E1NC4xMTYsNTQuMTE2LDAsMCwwLDIwMi4wMS02NTIuOWE1NC4xMTYsNTQuMTE2LDAsMCwwLTM3Ljk0NiwxNS42MjVMMC00NzMuMjE1LTE2NC4wNjItNjM3LjI3OEE1NC4xMTYsNTQuMTE2LDAsMCwwLTIwMi4wMDktNjUyLjlhNTQuMTE2LDU0LjExNiwwLDAsMC0zNy45NDYsMTUuNjI1bC03NS44OTMsNzUuODkzYTU0LjExNiw1NC4xMTYsMCwwLDAtMTUuNjI1LDM3Ljk0Nyw1NC4xMTYsNTQuMTE2LDAsMCwwLDE1LjYyNSwzNy45NDZsMTY0LjA2MywxNjQuMDYzTC0zMTUuODQ4LTE1Ny4zNjZhNTQuMTE2LDU0LjExNiwwLDAsMC0xNS42MjUsMzcuOTQ2LDU0LjExNiw1NC4xMTYsMCwwLDAsMTUuNjI1LDM3Ljk0NkwtMjM5Ljk1NS01LjU4YTU0LjExNiw1NC4xMTYsMCwwLDAsMzcuOTQ2LDE1LjYyNUE1NC4xMTYsNTQuMTE2LDAsMCwwLTE2NC4wNjItNS41OEwwLTE2OS42NDMsMTY0LjA2My01LjU4QTU0LjExNiw1NC4xMTYsMCwwLDAsMjAyLjAxLDEwLjA0NSw1NC4xMTYsNTQuMTE2LDAsMCwwLDIzOS45NTYtNS41OGw3NS44OTMtNzUuODkzQTU0LjExNiw1NC4xMTYsMCwwLDAsMzMxLjQ3NC0xMTkuNDJaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMzEuNDczIDY1Mi45MDMpIi8+Cjwvc3ZnPgo=)}.hc-toast-header{font-weight:600;font-size:1.28571rem;margin-bottom:4px;word-break:break-word}.hc-toast-body{font-size:1rem;word-break:break-word}.hc-toast-progress{position:absolute;border-bottom-right-radius:4px;border-bottom-left-radius:4px;left:0;bottom:0;height:4px;min-width:100%;background-color:rgba(215,221,228,.2);overflow:hidden;opacity:1}.hc-toast-progress:before{content:' ';display:block;height:4px;width:inherit;background-color:#006d9a}.hc-toast-progress-indeterminate:before{-webkit-animation:2.5s ease-in-out infinite ProgressShift;animation:2.5s ease-in-out infinite ProgressShift}.hc-toast-alert .hc-toast-progress:before{background-color:#e9111c}.hc-toast-warning .hc-toast-progress:before{background-color:#db7c07}.hc-toast-info .hc-toast-progress:before{background-color:#008bcc}.hc-toast-success .hc-toast-progress:before{background-color:#00753e}@-webkit-keyframes ProgressShift{0%{-webkit-transform:translateX(-100%);transform:translateX(-100%)}50%{-webkit-transform:translateX(0);transform:translateX(0)}100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}@keyframes ProgressShift{0%{-webkit-transform:translateX(-100%);transform:translateX(-100%)}50%{-webkit-transform:translateX(0);transform:translateX(0)}100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}",
            ],
          },
        ],
      },
    ],
    function () {
      return [
        { type: ɵngcc0.ElementRef },
        { type: ɵngcc0.ViewContainerRef },
        { type: ɵngcc0.ChangeDetectorRef },
      ];
    },
    null
  );
})();
if (false) {
  /** @type {?} */
  HcToastComponent.prototype._styleType;
  /** @type {?} */
  HcToastComponent.prototype._toastIcon;
  /** @type {?} */
  HcToastComponent.prototype._headerText;
  /** @type {?} */
  HcToastComponent.prototype._bodyText;
  /** @type {?} */
  HcToastComponent.prototype._animationState;
  /** @type {?} */
  HcToastComponent.prototype._animationStateChanged;
  /** @type {?} */
  HcToastComponent.prototype._closeClick;
  /** @type {?} */
  HcToastComponent.prototype._canDismiss;
  /** @type {?} */
  HcToastComponent.prototype._toastPortal;
  /** @type {?} */
  HcToastComponent.prototype._width;
  /** @type {?} */
  HcToastComponent.prototype._hasProgressBar;
  /** @type {?} */
  HcToastComponent.prototype._progressVal;
  /** @type {?} */
  HcToastComponent.prototype._progressWidth;
  /** @type {?} */
  HcToastComponent.prototype._componentInstance;
  /** @type {?} */
  HcToastComponent.prototype._el;
  /** @type {?} */
  HcToastComponent.prototype._viewContainerRef;
  /** @type {?} */
  HcToastComponent.prototype._changeRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/toaster/hc-toast-ref.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HcToastRef {
  /**
   * @param {?} _overlayRef
   */
  constructor(_overlayRef) {
    this._overlayRef = _overlayRef;
    this._beforeClose = new Subject();
    this._afterClosed = new Subject();
  }
  /**
   * If the `hasProgressBar` option is set to true in `hc-toast-options`, this 0-100 value can
   * be used to make it a determinate progress bar. If the progress bar is on but a value is not set,
   * the progress bar will be indeterminate.
   * @return {?}
   */
  get progress() {
    return this.componentInstance._progressVal;
  }
  /**
   * @param {?} progVal
   * @return {?}
   */
  set progress(progVal) {
    if (progVal < 0) {
      progVal = 0;
    } else if (progVal > 100) {
      progVal = 100;
    }
    this.componentInstance._progressVal = progVal;
    this.componentInstance._progressWidth = progVal + "%";
  }
  /**
   * Closes the associated toast message with this reference
   * @return {?}
   */
  close() {
    if (this.componentInstance._animationState !== "leave") {
      this.componentInstance._animationStateChanged
        .pipe(
          filter(
            /**
             * @param {?} event
             * @return {?}
             */
            (event) => event.phaseName === "start"
          ),
          take(1)
        )
        .subscribe(
          /**
           * @return {?}
           */
          () => {
            this._beforeClose.next();
            this._beforeClose.complete();
          }
        );
      this.componentInstance._animationStateChanged
        .pipe(
          filter(
            /**
             * @param {?} event
             * @return {?}
             */
            (event) => event.phaseName === "done" && event.toState === "leave"
          ),
          take(1)
        )
        .subscribe(
          /**
           * @return {?}
           */
          () => {
            this._overlayRef.dispose();
            this._afterClosed.next();
            this._afterClosed.complete();
            this.componentInstance._componentInstance.unsubscribe();
            this.componentInstance = /** @type {?} */ (null);
          }
        );
      this.componentInstance._startExitAnimation();
    }
  }
}
HcToastRef.ɵfac = function HcToastRef_Factory(t) {
  ɵngcc0.ɵɵinvalidFactory();
};
HcToastRef.ɵdir = ɵngcc0.ɵɵdefineDirective({
  type: HcToastRef,
  inputs: { progress: "progress" },
});
HcToastRef.propDecorators = {
  progress: [{ type: Input }],
};

if (false) {
  /**
   * @type {?}
   * @private
   */
  HcToastRef.prototype._beforeClose;
  /**
   * @type {?}
   * @private
   */
  HcToastRef.prototype._afterClosed;
  /** @type {?} */
  HcToastRef.prototype._toastPosition;
  /**
   * The HcToast component associated with the toast reference
   * @type {?}
   */
  HcToastRef.prototype.componentInstance;
  /** @type {?} */
  HcToastRef.prototype._overlayRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/toaster/hc-toaster.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Toasts provide users with instant feedback on actions they've taken. For more general information,
 * use a `hc-banner`.
 */
class HcToasterService {
  // Inject overlay service
  /**
   * @param {?} injector
   * @param {?} _overlay
   */
  constructor(injector, _overlay) {
    this.injector = injector;
    this._overlay = _overlay;
    this._toasts = [];
  }
  /**
   * Displays a new toaster message with the settings included in `toastOptions`. `toastContent` can be used to
   * create entirely custom toasts, but only if the type in toastOptions is set to `custom`. Be sure to set `border-radius: 5px`
   * in the style of your custom content template so it matches the toast container. If your custom toast is
   * using a component, the `componentSetup` parameter accepts an object or function to configure that component.
   * @template T
   * @param {?=} toastOptions
   * @param {?=} toastContent
   * @param {?=} componentSetup
   * @return {?}
   */
  addToast(toastOptions, toastContent, componentSetup) {
    /** @type {?} */
    const defaultOptions = {
      type: "success",
      position: "bottom-right",
      timeout: 5000,
      clickDismiss: false,
    };
    /** @type {?} */
    const options = Object.assign({}, defaultOptions, toastOptions);
    // Returns an OverlayRef (which is a PortalHost)
    /** @type {?} */
    const _overlayRef = this._createOverlay(options);
    // Instantiate remote control
    /** @type {?} */
    const _toastRef = new HcToastRef(_overlayRef);
    /** @type {?} */
    const overlayComponent = this._attachToastContainer(_overlayRef, _toastRef);
    _toastRef.componentInstance = overlayComponent;
    if (options.type === "custom" && toastContent) {
      if (toastContent instanceof TemplateRef) {
        _toastRef.componentInstance._toastPortal = new TemplatePortal(
          toastContent,
          _toastRef.componentInstance._viewContainerRef
        );
      } else {
        _toastRef.componentInstance._toastPortal = new ComponentPortal(
          toastContent
        );
        if (componentSetup) {
          _toastRef.componentInstance._componentInstance
            .pipe(
              filter(
                /**
                 * @param {?} c
                 * @return {?}
                 */
                (c) => !!c
              )
            )
            .subscribe(
              /**
               * @param {?} c
               * @return {?}
               */
              (c) => {
                if (componentSetup instanceof Function) {
                  componentSetup(c);
                } else {
                  Object.keys(componentSetup).forEach(
                    /**
                     * @param {?} k
                     * @return {?}
                     */
                    (k) => (c[k] = componentSetup[k])
                  );
                }
              }
            );
        }
      }
    }
    // Listen for click events to close the toast if the option is set
    if (options.clickDismiss) {
      _toastRef.componentInstance._canDismiss = options.clickDismiss;
      _toastRef.componentInstance._closeClick.subscribe(
        /**
         * @return {?}
         */
        () => {
          _toastRef.close();
        }
      );
    }
    // Set the class for the type set in options
    if (options.type) {
      if (
        options.type === "success" ||
        options.type === "info" ||
        options.type === "warning" ||
        options.type === "alert" ||
        options.type === "custom"
      ) {
        _toastRef.componentInstance._styleType = options.type;
      } else {
        throw Error("Unsupported toaster type: " + options.type);
      }
    }
    // Set the header text
    if (options.header) {
      _toastRef.componentInstance._headerText = options.header;
    }
    // Set the toast width
    if (options.width || options.width === 0) {
      _toastRef.componentInstance._width = options.width;
    }
    // Set the body text
    if (options.body) {
      _toastRef.componentInstance._bodyText = options.body;
    }
    // Store the positioning of the toast
    _toastRef._toastPosition = String(options.position);
    // Set progress bar
    if (options.hasProgressBar) {
      _toastRef.componentInstance._hasProgressBar = options.hasProgressBar;
    }
    // Set the timeout interval to close the toast if non-zero
    if (options.timeout !== 0) {
      setTimeout(
        /**
         * @return {?}
         */
        () => {
          if (_toastRef.componentInstance) {
            _toastRef.close();
          }
        },
        options.timeout
      );
    }
    // Cleanup functions called when the toast close animation is triggered
    _toastRef.componentInstance._animationStateChanged
      .pipe(
        filter(
          /**
           * @param {?} event
           * @return {?}
           */
          (event) => event.phaseName === "done" && event.toState === "leave"
        ),
        take(1)
      )
      .subscribe(
        /**
         * @return {?}
         */
        () => {
          this._removeToastPointer(_toastRef);
          if (options.toastClosed) {
            options.toastClosed();
          }
          this._updateToastPositions();
          _toastRef.componentInstance._closeClick.unsubscribe();
        }
      );
    _toastRef.componentInstance._changeRef.detectChanges();
    this._toasts.push(_toastRef);
    return _toastRef;
  }
  /**
   * Closes the most recent toast displayed
   * @return {?}
   */
  closeLastToast() {
    if (this._toasts.length > 0) {
      /** @type {?} */
      const element = this._toasts[this._toasts.length - 1];
      if (element) {
        element.close();
      }
    }
  }
  /**
   * Closes currently visible toasts
   * @return {?}
   */
  closeAllToasts() {
    /** @type {?} */
    let len = this._toasts.length;
    for (let index = 0; index < len; index++) {
      /** @type {?} */
      const element = this._toasts[index];
      if (element) {
        element.close();
      }
    }
  }
  /**
   * @private
   * @param {?} config
   * @return {?}
   */
  _createOverlay(config) {
    /** @type {?} */
    const overlayConfig = this._getOverlayConfig(config);
    return this._overlay.create(overlayConfig);
  }
  /**
   * @private
   * @param {?} overlayRef
   * @param {?} toastRef
   * @return {?}
   */
  _attachToastContainer(overlayRef, toastRef) {
    /** @type {?} */
    const injector = this._createInjector(toastRef);
    /** @type {?} */
    const containerPortal = new ComponentPortal(
      HcToastComponent,
      null,
      injector
    );
    /** @type {?} */
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  /**
   * @private
   * @param {?} toastRef
   * @return {?}
   */
  _createInjector(toastRef) {
    /** @type {?} */
    const injectionTokens = new WeakMap();
    injectionTokens.set(HcToastRef, toastRef);
    return new PortalInjector(this.injector, injectionTokens);
  }
  /**
   * @private
   * @param {?} config
   * @return {?}
   */
  _getOverlayConfig(config) {
    /** @type {?} */
    let overlayConfig;
    /** @type {?} */
    let positionStrategy = this._getPositionStrategy(
      String(config.position),
      this._toasts.length
    );
    if (
      config.position === "top-full-width" ||
      config.position === "bottom-full-width"
    ) {
      overlayConfig = new OverlayConfig({
        positionStrategy,
        width: "96%",
        panelClass: "overlay-pointer-events",
      });
    } else {
      overlayConfig = new OverlayConfig({
        positionStrategy,
        panelClass: "overlay-pointer-events",
      });
    }
    return overlayConfig;
  }
  /**
   * @private
   * @param {?} position
   * @param {?} index
   * @return {?}
   */
  _getPositionStrategy(position, index) {
    /** @type {?} */
    let positionStrategy;
    /** @type {?} */
    let toastIndex = this._getLastToast(position, index);
    switch (position) {
      case "top-right":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "end",
                overlayY: "top",
                originX: "end",
                originY: "bottom",
              },
            ]);
        } else {
          positionStrategy = this._overlay.position().global().right("10px");
        }
        break;
      case "top-center":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "center",
                overlayY: "top",
                originX: "center",
                originY: "bottom",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .centerHorizontally();
        }
        break;
      case "top-left":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "start",
                overlayY: "top",
                originX: "start",
                originY: "bottom",
              },
            ]);
        } else {
          positionStrategy = this._overlay.position().global().left("10px");
        }
        break;
      case "top-full-width":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withFlexibleDimensions(false)
            .withPositions([
              {
                overlayX: "center",
                overlayY: "top",
                originX: "center",
                originY: "bottom",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .centerHorizontally();
        }
        break;
      case "bottom-right":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "end",
                overlayY: "bottom",
                originX: "end",
                originY: "top",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .bottom()
            .right("10px");
        }
        break;
      case "bottom-center":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "center",
                overlayY: "bottom",
                originX: "center",
                originY: "top",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .bottom()
            .centerHorizontally();
        }
        break;
      case "bottom-left":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withPositions([
              {
                overlayX: "start",
                overlayY: "bottom",
                originX: "start",
                originY: "top",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .bottom()
            .left("10px");
        }
        break;
      case "bottom-full-width":
        if (toastIndex !== -1) {
          positionStrategy = this._overlay
            .position()
            .flexibleConnectedTo(
              this._toasts[toastIndex].componentInstance._el.nativeElement
                .children[0]
            )
            .withFlexibleDimensions(false)
            .withPositions([
              {
                overlayX: "center",
                overlayY: "bottom",
                originX: "center",
                originY: "top",
              },
            ]);
        } else {
          positionStrategy = this._overlay
            .position()
            .global()
            .bottom()
            .centerHorizontally();
        }
        break;
      default:
        throw Error("Unsupported toaster message position: " + position);
    }
    return positionStrategy;
  }
  // Removes the toast that was closed from the storage array
  /**
   * @private
   * @param {?} toastRef
   * @return {?}
   */
  _removeToastPointer(toastRef) {
    for (let index = 0; index < this._toasts.length; index++) {
      if (this._toasts[index] === toastRef) {
        this._toasts.splice(index, 1);
      }
    }
  }
  // Returns one toast back from the index provided in the position provided
  /**
   * @private
   * @param {?} toastPos
   * @param {?} startIndex
   * @return {?}
   */
  _getLastToast(toastPos, startIndex) {
    /** @type {?} */
    let toastIndex = -1;
    for (let index = startIndex - 1; index >= 0; index--) {
      if (this._toasts[index]._toastPosition === toastPos) {
        toastIndex = index;
        break;
      }
    }
    return toastIndex;
  }
  // Updates the position strategy for what toasts are connected after one is closed
  /**
   * @private
   * @return {?}
   */
  _updateToastPositions() {
    for (let index = 0; index < this._toasts.length; index++) {
      this._toasts[index]._overlayRef.updatePositionStrategy(
        this._getPositionStrategy(this._toasts[index]._toastPosition, index)
      );
    }
  }
}
HcToasterService.ɵfac = function HcToasterService_Factory(t) {
  return new (t || HcToasterService)(
    ɵngcc0.ɵɵinject(ɵngcc0.Injector),
    ɵngcc0.ɵɵinject(ɵngcc3.Overlay)
  );
};
HcToasterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({
  token: HcToasterService,
  factory: HcToasterService.ɵfac,
});
/** @nocollapse */
HcToasterService.ctorParameters = () => [{ type: Injector }, { type: Overlay }];
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    HcToasterService,
    [
      {
        type: Injectable,
      },
    ],
    function () {
      return [{ type: ɵngcc0.Injector }, { type: ɵngcc3.Overlay }];
    },
    null
  );
})();
if (false) {
  /** @type {?} */
  HcToasterService.prototype._toasts;
  /**
   * @type {?}
   * @private
   */
  HcToasterService.prototype.injector;
  /**
   * @type {?}
   * @private
   */
  HcToasterService.prototype._overlay;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/toaster/hc-toaster.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToasterModule {}
ToasterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ToasterModule });
ToasterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function ToasterModule_Factory(t) {
    return new (t || ToasterModule)();
  },
  providers: [HcToasterService],
  imports: [[CommonModule, PortalModule, OverlayModule]],
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(ToasterModule, {
      declarations: function () {
        return [HcToastComponent];
      },
      imports: function () {
        return [CommonModule, PortalModule, OverlayModule];
      },
      exports: function () {
        return [HcToastComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    ToasterModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule, PortalModule, OverlayModule],
            exports: [HcToastComponent],
            declarations: [HcToastComponent],
            providers: [HcToasterService],
            entryComponents: [HcToastComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/toaster/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/typeform-survey/typeform-survey.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function throwErrorForMissingSurveyUri() {
  throw Error(`SurveyUri must be specified on element hc-typeform-survey`);
}
class TypeformWindow extends Window {}
if (false) {
  /** @type {?} */
  TypeformWindow.prototype.typeformEmbed;
}
class TypeformSurveyComponent {
  constructor() {
    this._surveyUri = "";
    this._id = "typef_orm_share";
  }
  /**
   * TypeForm survey URI you want to use. Example: https://somecompany.typeform.com/to/surveyId?parameter=parametervalue
   * @param {?} uri
   * @return {?}
   */
  set surveyUri(uri) {
    this._surveyUri = uri;
    this.refreshFullUri();
  }
  /**
   * @return {?}
   */
  get surveyUri() {
    return this._surveyUri;
  }
  /**
   * App version which will be passed to the survey in a hidden field. Ensures you know what version the feedback is referencing.
   * @param {?} version
   * @return {?}
   */
  set appVersion(version) {
    this._appVersion = version;
    this.refreshFullUri();
  }
  /**
   * @return {?}
   */
  get appVersion() {
    return this._appVersion;
  }
  /**
   * Opens the survey specified in the surveyUri
   * @return {?}
   */
  open() {
    if (!document.getElementById(this._id)) {
      this.getScripts();
    } else {
      /** @type {?} */ (/** @type {?} */ (window)).typeformEmbed.makePopup(
        this._fullUri,
        {
          mode: "drawer_right",
          autoOpen: true,
          opacity: 100,
          autoClose: 0,
          hideScrollbars: true,
        }
      );
    }
  }
  /**
   * @private
   * @return {?}
   */
  refreshFullUri() {
    /** @type {?} */
    let varChar = this.surveyUri.includes("?") ? "&" : "?";
    this._fullUri = this.appVersion
      ? this.surveyUri + varChar + "app_version=" + this.appVersion
      : this.surveyUri;
  }
  /**
   * @private
   * @return {?}
   */
  getScripts() {
    if (!this.surveyUri) {
      throwErrorForMissingSurveyUri();
    }
    /* this is directly from the embed
                   markup given from TypeForm */
    /** @type {?} */
    let embedScript;
    /** @type {?} */
    let firstScript;
    if (!document.getElementById(this._id)) {
      // create new embed script with typeform cdn source
      embedScript = document.createElement("script");
      embedScript.id = this._id;
      embedScript.src = `https://embed.typeform.com/embed.js`;
      // insert embed script before other js scripts
      firstScript = document.getElementsByTagName.call(document, "script")[0];
      if (firstScript.parentNode) {
        firstScript.parentNode.insertBefore(embedScript, firstScript);
      }
    }
  }
}
TypeformSurveyComponent.ɵfac = function TypeformSurveyComponent_Factory(t) {
  return new (t || TypeformSurveyComponent)();
};
TypeformSurveyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({
  type: TypeformSurveyComponent,
  selectors: [["hc-typeform-survey"]],
  inputs: { surveyUri: "surveyUri", appVersion: "appVersion" },
  decls: 1,
  vars: 1,
  consts: [
    [
      "data-mode",
      "drawer_right",
      "data-auto-open",
      "true",
      "data-submit-close-delay",
      "0",
      "target",
      "_blank",
      "rel",
      "noopener",
      1,
      "typeform-share",
      "link",
      3,
      "href",
    ],
  ],
  template: function TypeformSurveyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵngcc0.ɵɵelement(0, "a", 0);
    }
    if (rf & 2) {
      ɵngcc0.ɵɵproperty("href", ctx._fullUri, ɵngcc0.ɵɵsanitizeUrl);
    }
  },
  encapsulation: 2,
});
TypeformSurveyComponent.propDecorators = {
  surveyUri: [{ type: Input }],
  appVersion: [{ type: Input }],
};
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TypeformSurveyComponent,
    [
      {
        type: Component,
        args: [
          {
            selector: "hc-typeform-survey",
            template: `
        <a
            class="typeform-share link"
            [href]="_fullUri"
            data-mode="drawer_right"
            data-auto-open="true"
            data-submit-close-delay="0"
            target="_blank"
            rel="noopener"
        ></a>
    `,
            encapsulation: ViewEncapsulation.None,
          },
        ],
      },
    ],
    function () {
      return [];
    },
    {
      surveyUri: [
        {
          type: Input,
        },
      ],
      appVersion: [
        {
          type: Input,
        },
      ],
    }
  );
})();
if (false) {
  /** @type {?} */
  TypeformSurveyComponent.prototype._fullUri;
  /**
   * @type {?}
   * @private
   */
  TypeformSurveyComponent.prototype._surveyUri;
  /**
   * @type {?}
   * @private
   */
  TypeformSurveyComponent.prototype._appVersion;
  /**
   * @type {?}
   * @private
   */
  TypeformSurveyComponent.prototype._id;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/typeform-survey/typeform-survey.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TypeformSurveyModule {}
TypeformSurveyModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({
  type: TypeformSurveyModule,
});
TypeformSurveyModule.ɵinj = ɵngcc0.ɵɵdefineInjector({
  factory: function TypeformSurveyModule_Factory(t) {
    return new (t || TypeformSurveyModule)();
  },
  imports: [[CommonModule]],
});
(function () {
  (typeof ngJitMode === "undefined" || ngJitMode) &&
    ɵngcc0.ɵɵsetNgModuleScope(TypeformSurveyModule, {
      declarations: function () {
        return [TypeformSurveyComponent];
      },
      imports: function () {
        return [CommonModule];
      },
      exports: function () {
        return [TypeformSurveyComponent];
      },
    });
})();
/*@__PURE__*/ (function () {
  ɵngcc0.ɵsetClassMetadata(
    TypeformSurveyModule,
    [
      {
        type: NgModule,
        args: [
          {
            imports: [CommonModule],
            exports: [TypeformSurveyComponent],
            declarations: [TypeformSurveyComponent],
          },
        ],
      },
    ],
    null,
    null
  );
})();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/typeform-survey/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: healthcatalyst-cashmere.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export {
  APP_SWITCHER_CONFIG,
  APP_SWITCHER_SERVICE,
  AccordionComponent,
  AccordionModule,
  AccordionToolbarComponent,
  ActiveModal,
  AnchorComponent,
  AppSwitcherComponent,
  AppSwitcherLinksComponent,
  AppSwitcherModule,
  AppSwitcherService,
  BannerModule,
  BannerStampDirective,
  BasePaginationComponent,
  BreadcrumbsComponent,
  BreadcrumbsModule,
  ButtonComponent,
  ButtonModule,
  CalendarBodyComponent,
  CalendarComponent,
  CalendarHeaderComponent,
  CalendarOverlayService,
  CalendarWrapperComponent,
  CellResizeEvent,
  CheckboxChangeEvent,
  CheckboxComponent,
  CheckboxGroup,
  CheckboxModule,
  ChipComponent,
  ChipModule,
  ChipRowComponent,
  ConfigStoreService,
  DateAdapter,
  DateRangeDirective,
  DateRangeModule,
  DatepickerComponent,
  DatepickerContentComponent,
  DatepickerInputDirective,
  DatepickerModule,
  DatepickerToggleComponent,
  DatepickerToggleIconDirective,
  DividerDirective,
  Drawer,
  DrawerContainer,
  DrawerItem,
  DrawerModule,
  DrawerPromiseResult,
  DrawerToolbar,
  EllipsisPipe,
  EllipsisPipeModule,
  FileSizePipe,
  FileSizePipeModule,
  FormFieldModule,
  HC_DATEPICKER_SCROLL_STRATEGY,
  HC_DATEPICKER_SCROLL_STRATEGY_FACTORY,
  HC_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
  HC_DATEPICKER_VALIDATORS,
  HC_DATEPICKER_VALUE_ACCESSOR,
  HC_DATE_FORMATS,
  HC_DATE_LOCALE,
  HC_DATE_LOCALE_FACTORY,
  HC_DATE_LOCALE_PROVIDER,
  HC_NATIVE_DATE_FORMATS,
  HcBannerComponent,
  HcCalendarCell,
  HcCell,
  HcCellDef,
  HcCellResizer,
  HcCheckboxRequiredValidatorDirective,
  HcColumnDef,
  HcDatepickerAnimations,
  HcDatepickerContentBase,
  HcDatepickerInputEvent,
  HcDatepickerIntl,
  HcErrorComponent,
  HcFooterCell,
  HcFooterCellDef,
  HcFooterRow,
  HcFooterRowDef,
  HcFormControlComponent,
  HcFormDirective,
  HcFormFieldComponent,
  HcHeaderCell,
  HcHeaderCellDef,
  HcHeaderRow,
  HcHeaderRowDef,
  HcIconLargeDirective,
  HcIconMediumDirective,
  HcIconSmallDirective,
  HcLabelComponent,
  HcLabelExtensionComponent,
  HcModal,
  HcNativeDateModule,
  HcPopComponent,
  HcPopoverAnchorDirective,
  HcPrefixDirective,
  HcRow,
  HcRowDef,
  HcScrollNavComponent,
  HcScrollNavContentComponent,
  HcSuffixDirective,
  HcTabTitleComponent,
  HcTable,
  HcTableDataSource,
  HcToastComponent,
  HcToastRef,
  HcToasterService,
  HighlightPipe,
  HighlightPipeModule,
  IconComponent,
  IconModule,
  InputDirective,
  InputModule,
  ListAvatarDirective,
  ListComponent,
  ListIconDirective,
  ListItemComponent,
  ListLineDirective,
  ListModule,
  LoadMorePaginationComponent,
  MenuDirective,
  MenuDrawer,
  MenuIconDirective,
  MenuItemDirective,
  MenuSubTextDirective,
  MenuTextDirective,
  ModalBodyComponent,
  ModalComponent,
  ModalFooterComponent,
  ModalHeaderComponent,
  ModalModule,
  ModalOverlayComponent,
  ModalService,
  ModalWindowComponent,
  MonthViewComponent,
  MultiYearViewComponent,
  NativeDateAdapter,
  NativeDateModule,
  NavbarComponent,
  NavbarDropdownComponent,
  NavbarLinkComponent,
  NavbarMobileMenuComponent,
  NavbarModule,
  NullOrEmptyStringPipe,
  NullOrEmptyStringPipeModule,
  NumberAbbreviatorPipe,
  NumberAbbreviatorPipeModule,
  PageEvent,
  PaginationComponent,
  PaginationModule,
  PickerOverlayComponent,
  PicklistComponent,
  PicklistModule,
  PicklistRemoteQueryOptions,
  PipesModule,
  PopModule,
  ProgressDotsComponent,
  ProgressIndicatorsModule,
  ProgressSpinnerComponent,
  RadioButtonChangeEvent,
  RadioButtonComponent,
  RadioButtonModule,
  RadioGroupDirective,
  ScrollNavLinkDirective,
  ScrollNavModule,
  ScrollNavTargetDirective,
  SelectChangeEvent,
  SelectComponent,
  SelectModule,
  SplitButtonClickEvent,
  SplitButtonComponent,
  StepperComponent,
  StepperModule,
  SubnavComponent,
  SubnavModule,
  SubnavRightDirective,
  TabChangeEvent,
  TabComponent,
  TabSetComponent,
  TableModule,
  TabsModule,
  TileComponent,
  TileModule,
  ToasterModule,
  TypeformSurveyComponent,
  TypeformSurveyModule,
  YearViewComponent,
  HC_CHECKBOX_REQUIRED_VALIDATOR as ɵa,
  PicklistComponent as ɵb,
  PicklistPaneComponent as ɵc,
  transformPopover as ɵg,
  HcTooltipComponent as ɵh,
  HcPopoverAnchoringService as ɵi,
  HcPopoverAccessibilityService as ɵj,
  HcOptionDirective as ɵk,
  Initializable as ɵl,
  PicklistService as ɵm,
  PicklistFilterService as ɵn,
  PicklistStateService as ɵo,
  PicklistFilterLocalService as ɵp,
  PicklistFilterRemoteService as ɵq,
  PicklistValuesetMovingService as ɵr,
  PicklistActionService as ɵs,
  BindObservable as ɵt,
};

//# sourceMappingURL=healthcatalyst-cashmere.js.map
